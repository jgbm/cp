% -*- fill-column: 100 -*-

% easychair.tex,v 3.2 2012/05/15
%
% Select appropriate paper format in your document class as
% instructed by your conference organizers. Only withtimes
% and notimes can be used in proceedings created by EasyChair
%
% The available formats are 'letterpaper' and 'a4paper' with
% the former being the default if omitted as in the example
% below.
%
\documentclass{easychair}
%\documentclass[debug]{easychair}
%\documentclass[verbose]{easychair}
%\documentclass[notimes]{easychair}
%\documentclass[withtimes]{easychair}
%\documentclass[a4paper]{easychair}
%\documentclass[letterpaper]{easychair}

% This provides the \BibTeX macro
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{color}
\usepackage{doc}
\usepackage{makeidx}
\usepackage{stmaryrd}
\usepackage{mathpartir}
\usepackage{xspace}

% In order to save space or manage large tables or figures in a
% landcape-like text, you can use the rotating and pdflscape
% packages. Uncomment the desired from the below.
%
% \usepackage{rotating}
% \usepackage{pdflscape}

% If you plan on including some algorithm specification, we recommend
% the below package. Read more details on the custom options of the
% package documentation.
%
% \usepackage{algorithm2e}


%%% macros

\newtheorem{theorem}{Theorem}
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{corollary}[theorem]{Corollary}
\newtheorem{proposition}[theorem]{Proposition}
\newtheorem{definition}[theorem]{Definition}

\newcommand{\ba}{\begin{array}}
\newcommand{\ea}{\end{array}}

\newenvironment{equations}{\[\ba{@{}r@{~}c@{~}l@{}}}{\ea\]}
\newenvironment{eqs}{\ba{@{}r@{~}c@{~}l@{}}}{\ea}



\newcommand{\key}{\mathsf}

\newcommand{\set}[1]{\{ #1 \}}


\newcommand{\gvtocp}[1]{\llbracket{#1}\rrbracket}
\newcommand{\cptogv}[1]{\llparenthesis{#1}\rrparenthesis}

\newcommand{\row}[2]{\set{#1}_{#2}}

\newcommand{\gvOutput}[2]{\mathord{!}{#1}.{#2}}
\newcommand{\gvInput}[2]{\mathord{?}{#1}.{#2}}
\newcommand{\gvEndOutput}{\key{end}_!}
\newcommand{\gvEndInput}{\key{end}_?}
\newcommand{\gvPlus}[2]{\oplus \row{#1}{#2}}
\newcommand{\gvChoice}[2]{\binampersand \row{#1}{#2}}
\newcommand{\gvServer}[1]{\flat {#1}}
\newcommand{\gvService}[1]{\sharp {#1}}
\newcommand{\gvDual}[1]{\overline{#1}}
\newcommand{\gvOutputType}[2]{![{#1}].{#2}}
\newcommand{\gvInputType}[2]{?[{#1}].{#2}}

\newcommand{\cpj}[2]{{#1} \vdash {#2}}
\newcommand{\gvj}[3]{{#1} \vdash {#2} : {#3}}

\newcommand{\la}{l}
\newcommand{\G}{\Gamma}
\newcommand{\D}{\Delta}

\newcommand{\lolli}{\multimap}

\newcommand{\gvLinFun}[2]{{#1} \lolli {#2}}
\newcommand{\gvUnFun}[2]{{#1} \to {#2}}
\newcommand{\gvTimes}[2]{{#1} \otimes {#2}}
\newcommand{\gvUnitType}{\key{Unit}}

\newcommand{\gvUnit}{\key{unit}}
\newcommand{\gvLink}[2]{\key{link}~{#1}~{#2}}
\newcommand{\gvLam}[2]{\lambda {#1}.{#2}}
\newcommand{\gvApp}[2]{{#1}~{#2}}
\newcommand{\gvPair}[2]{({#1},{#2})}
\newcommand{\gvLet}[3]{\key{let}~{#1}={#2}~\key{in}~{#3}}
\newcommand{\gvSend}[2]{\key{send}~{#1}~{#2}}
\newcommand{\gvReceive}[1]{\key{receive}~{#1}}
\newcommand{\gvSelect}[2]{\key{select}~{#1}~{#2}}
\newcommand{\gvCase}[2]{\key{case}~{#1}~\key{of}~{#2}}

\newcommand{\gvFork}[2]{\key{fork}~{#1}.{#2}}

\newcommand{\gvWith}[3]{\key{with}~{#1}~\key{connect}~{#2}~\key{to}~{#3}}
\newcommand{\gvTerminate}[1]{\key{terminate}~{#1}}


% receive with continuation
\newcommand{\gvReceiveK}[4]{\gvLet{\gvPair{#1}{#2}}{\gvReceive{#3}}{#4}}

\newcommand{\gvSendType}[2]{\key{sendType}~{#1}~{#2}}
\newcommand{\gvReceiveType}[1]{\key{receiveType}~{#1}}


\newcommand{\gvServeOld}[3]{\key{serve}~{#1}({#2})={#3}}

\newcommand{\gvServe}[2]{\key{serve}~{#1}.{#2}}
\newcommand{\gvRequest}[1]{\key{request}~{#1}}

\newcommand{\cpLink}[2]{{#1} \leftrightarrow {#2}}
\newcommand{\cpCut}[3]{\nu {#1}.({#2} \mid {#3})}
\newcommand{\cpOutput}[4]{{#1}[{#2}].({#3} \mid {#4})}
\newcommand{\cpInput}[3]{{#1}({#2}).{#3}}
\newcommand{\cpInject}[3]{{#1}[{#2}].{#3}}
\newcommand{\cpCase}[2]{{#1}.\key{case}~{#2}}
\newcommand{\cpServe}[3]{!{#1}({#2}).{#3}}
\newcommand{\cpRequest}[3]{?{#1}[{#2}].{#3}}
\newcommand{\cpEmptyOut}[1]{{#1}[].0}
\newcommand{\cpEmptyIn}[2]{{#1}().{#2}}
\newcommand{\cpSendType}[3]{{#1}[{#2}].{#3}}
\newcommand{\cpReceiveType}[3]{{#1}({#2}).{#3}}


\newcommand{\cpTimes}[2]{{#1} \otimes {#2}}
\newcommand{\cpPar}[2]{{#1} \mathbin{\bindnasrepma} {#2}}
\newcommand{\cpPlus}[2]{\oplus \row{#1}{#2}}
\newcommand{\cpWith}[2]{\binampersand \row{#1}{#2}}
\newcommand{\cpOne}{1}
\newcommand{\cpBottom}{\bot}
\newcommand{\cpOfCourse}[1]{!{#1}}
\newcommand{\cpWhyNot}[1]{?{#1}}
\newcommand{\cpDual}[1]{{#1}^\bot}
\newcommand{\cpExists}[2]{\exists {#1}.{#2}}
\newcommand{\cpForall}[2]{\forall {#1}.{#2}}

\newcommand{\cpZero}{0}    % 0   == +{}
\newcommand{\cpTop}{\top}  % top == &{}

\newcommand{\un}[1]{\mathit{un}(#1)}
\newcommand{\lin}[1]{\mathit{lin}(#1)}

\newcommand{\FV}[1]{\mathit{FV}(#1)}
\newcommand{\subst}[3]{{#1}[{#2}/{#3}]}

\newcommand{\gvtocps}[1]{\gvtocp{#1}}
\newcommand{\gvtocpd}[1]{\gvtocp{#1}}

\newcommand{\cpMix}[2]{({#1} \mid {#2})}
\newcommand{\cpCutOutput}[5]{{#2}[{#3}].\nu{#1}.\cpMix{#4}{#5}}

\newcommand{\hgv}{HGV\xspace}
\newcommand{\hgvpi}{HGV$\pi$\xspace}

\newcommand{\lampi}[1]{({#1})^\star}
\newcommand{\hgvcp}[1]{\llbracket{#1}\rrbracket}

\newcommand{\todo}[1]{\textbf{\color{red}TODO: #1}}

%\makeindex

%% Document
%%
\begin{document}

\title{Sessions as propositions}

% \titlerunning{} has to be set to either the main title or its shorter
% version for the running heads. When processed by
% EasyChair, this command is mandatory: a document without \titlerunning
% will be rejected by EasyChair

\titlerunning{Sessions as propositions}

% Authors are joined by \and. Their affiliations are given by \inst, which indexes
% into the list defined using \institute
%
\author{
  Sam Lindley
  \and
  J. Garrett Morris
}
%% \author{
%% Serguei A. Mokhov\inst{1}\thanks{Designed and implemented the class style}
%% \and
%%     Geoff Sutcliffe\inst{2}\thanks{Did numerous tests and provided a lot of suggestions}
%% \and
%%    Andrei Voronkov\inst{3}\thanks{Masterminded EasyChair and created versions
%%      3.0--3.1 of the class style}\\
%% \and
%%    Graham Gough\inst{3}\thanks{Changed author list format.}\\
%% }


% Institutes for affiliations are also joined by \and,
\institute{The University of Edinburgh \\
           \email{Sam.Lindley@ed.ac.uk, Garrett.Morris@ed.ac.uk}
}
%% \institute{
%%   Concordia University,
%%   Montreal, Quebec, Canada\\
%%   \email{mokhov@cse.concordia.ca}
%% \and
%%    University of Miami,
%%    Miami, Florida, U.S.A.\\
%%    \email{geoff@cs.miami.edu}\\
%% \and
%%    University of Manchester,
%%    Manchester, U.K.\\
%%    \email{andrei@voronkov.com, graham@cs.man.ac.uk}\\
%%  }
%  \authorrunning{} has to be set for the shorter version of the authors' names;
% otherwise a warning will be rendered in the running heads. When processed by
% EasyChair, this command is mandatory: a document without \authorrunning
% will be rejected by EasyChair

\authorrunning{Lindley and Morris}


\clearpage

\maketitle


\begin{abstract}
Recently, Wadler presented a continuation-passing translation from a session-typed functional
language, called GV, to a process calculus, called CP, based on classical linear logic. However,
this translation is one-way: CP is more expressive than GV. We propose an extension to GV, called
\hgv, which bridges the expressiveness gap. We provide direct translations from CP into the session
fragment of \hgv, called \hgvpi, and from \hgv to \hgvpi. We prove that the original
qcontinuation-passing translation from GV to CP factors through the direct translation to
\hgvpi. The new translations shed light both on the original translation from GV to CP, and on the
limitations in expressiveness of GV.
\end{abstract}


%\section{To mention}
%
%Processing in EasyChair - number of pages.
%
%Examples of how EasyChair processes papers. Caveats (replacement of EC
%class, errors).

% \pagestyle{empty}


\section{Introduction}

Linear logic has long been seen as a possible typing discipline for concurrent programming.
Girard~\cite{Girard87} originally identified that the connectives of linear logic could be
interpreted as parallel computation.  Abramsky~\cite{Abramsky92} and Bellin and
Scott~\cite{BellinScott94} demonstrated an interpretation of linear logic proofs as processes in
Milner's $\pi$-calculus; however, while their system provided $\pi$-calculus interprations of all
linear logic proofs, it did not provide a proof-theoretic interpretation for arbitrary
$\pi$-calculus terms.  Caires and Pfenning~\cite{CairesPfenning10} observed that the multiplicative
connectives could be interpreted in the style of session types; however, their underlying process
calculus is more similar to the $\pi$-calculus than to traditional session-typed languages, and is
based on intuitionistic linear logic.  Finally, Wadler~\cite{Wadler12} showed that a simple
session-typed linear functional language, patterned after that of Gay and
Vasconselos~\cite{GayVasconcelos10}, could be mapped into a process calculus based on the classical
linear logic.

Wadler's work showed that linear session-typed programs could be interpreted as proofs in linear
logic.  However, his session-typed language (called GV) is less expressive than the linear
logic---thus, there are linear logic proofs, with corresponding terms of his process calculus
(called CP), which do not correspond to any GV program.  This work begins by defining an extension
of GV, called \hgv, sufficient to express all proofs in the linear logic. To demonstrate \hgv's
expressiveness, we both give a direct translation from CP into \hgv and extend Wadler's
continuation-passing translation from GV into CP to one from \hgv into CP.

As CP only describes process communication, our translation maps all of CP into the session-oriented
fragment of HGV (which we call \hgvpi), avoiding the functional features of \hgv entirely.  Thus, by
composing the translation from \hgv to CP with that from CP to \hgvpi, we obtain a translation of
the functional features of \hgv into their process counterparts.  Because the translation from \hgv
to CP is continuation-passing, the composed translation from \hgv into \hgvpi is also
continuation-passing.  As an alternative approach, we give a direct translation from \hgv to \hgvpi.
These translations illustrate several points.  First, they show the increased exprsesivityof \hgv:
as GV's session types contained no notion of replication or recursion, they could not express the
non-linear features of its functional fragment; \hgv, in contrast, can be reduced to \hgvpi.
Second, factoring the translation of \hgv into CP over that from \hgv into \hgvpi simplifies the
translation, and illuminates regularities that were not apparent in Wadler's original translation.

\section{The \hgv Language}

This section describes our session-typed language \hgv, constrasting it with Gay and Vasconcelos's
functional session-typed language~\cite{GayVasconcelos10} and Wadler's language GV~\cite{Wadler12}.
Our language's features are closer to those of Gay and Vasconcelos, but retains a type system
closely corresponding to linear logic.

\hgv's session types are given by
\[\begin{eqs}
  S & ::= & \gvOutput{T}{S} \mid \gvInput{T}{S} \mid
           \gvPlus{\la_i:S_i}{i} \mid \gvChoice{\la_i:S_i}{i} \mid
           \gvEndOutput \mid \gvEndInput \\
    & \mid & X \mid \gvDual{X} \mid
            \gvOutputType{X}{S} \mid \gvInputType{X}{S} \mid
            \gvServer{S} \mid \gvService{S}
\end{eqs}\]
The types for input ($\gvInput{T}{S}$), output ($\gvOutput{T}{S}$), selection
($\gvPlus{\la_i:S_i}{i}$) and choice ($\gvChoice{\la_i:\S_i}{i}$) are standard.  Like GV, but unlike
most session typed systems, we distinguish output ($\gvEndOutput$) and input ($\gvEndInput$) session
ends; this matches the situation in linear logic, where there is no convenient self-dual proposition
to represent the end of a session.  Finally, \hgv contains several less usual session types.  We
include variables and their duals ($X,\gvDual{X}$) and type input ($\gvInputType{X}{S}$) and output
($\gvOutputType{X}{S}$), permitting the definition of polymorphic sessions.  Finally, we include a
notion of replicated sessions: a session of type $\gvService{S}$ can be thought of as a ``service'',
providing any number of copies of a session of type $S$; a ssession of type $\gvServer{S}$ can be
thought of as the ``server'' providing that service.

The notion of duals for \hgv sessions is standard, with the expected addition for services and their
servers:
\begin{align*}
  \gvDual{\gvOutput{T}{S}} &= \gvInput{T}{\gvDual{S}} & \gvDual{\gvOutputType{X}{S}} &= \gvInputType{X}{\gvDual{S}} \\
  \gvDual{\gvPlus{\la_i:S_i}{i}} &= \gvChoice{\la_i:\gvDual{S_i}}{i} & \gvDual{\gvService{S}} &= \gvServer{\gvDual{S}} \\
  \gvDual{\gvEndOutput} &= \gvEndInput
\end{align*}

In addition to sessions, \hgv's types include pairs, and linear and unlimited functions:
\[
T,U,V ::= S \mid \gvTimes{T}{U} \mid \gvLinFun{T}{U} \mid \gvUnFun{T}{U}
\]

%% Each type $T$ is classified as either linear ($\lin{T}$) or unlimited
%% ($\un{T}$).
%% \[
%% \begin{array}{l}
%% \lin{\gvOutput{T}{S}}  \quad \lin{\gvInput{T}{S}} \quad
%% \lin{\gvPlus{\la_i:S_i}{i}} \quad \lin{\gvChoice{\la_i:S_i}{i}} \quad
%% \lin{\gvEndOutput} \quad \un{\gvEndInput} \\
%% \lin{X} \quad
%% \lin{\gvOutputType{X}{S}} \quad \lin{\gvInputType{X}{S}} \quad
%% \lin{\gvServer{S}} \quad \un{\gvService{S}} \\
%% \lin{\gvTimes{T}{U}} \quad \lin{\gvLinFun{T}{U}} \quad \un{\gvUnFun{T}{U}}
%% \end{array}
%% \]
%% The only unlimited type constructors are those for end input,
%% services, and unlimited functions.

%% Apart from the extensions, the two differences in the types of GV are
%% that there is no unit type (called $\gvUnitType$ in GV), and
%% $\gvEndInput$ is unlimited. We omit unit because it is isomorphic to
%% both $\gvEndInput$ and $\gvService{(\gvPlus{}{})}$.

%% TODO: fork vs with

%% The terms and typing rules for \hgv are given in
%% Figure~\ref{fig:hgv-typing}. The first three rules are structural. The
%% next six rules cover the non-session fragment of \hgv. The remaining
%% rules cover the session fragment of \hgv.

%% Notice that the non-session and session fragments are orthogonal, in
%% that the non-session rules mention only non-session type constructors,
%% and the session rules mention only session type constructors. This is
%% a useful property which does not hold of the original GV. As we shall
%% see, it enables us to compile away the non-session fragment into the
%% session fragment.

%% Vanilla GV, has session constructs $\key{receive}$ and
%% $\key{terminate}$, both of whose typing rules mention non-session
%% types.
%% \begin{mathpar}
%% \inferrule[Receive-$\otimes$]
%% {\gvj{\Phi}{M}{\gvInput{T}{S}}}
%% {\gvj{\Phi}{\gvReceive{M}}{\gvTimes{T}{S}}}

%% \inferrule[Terminate-$\otimes$]
%% {\gvj{\Phi}{M}{\gvTimes{T}{\gvEndInput}}}
%% {\gvj{\Phi}{\gvTerminate{M}}{T}}
%% \end{mathpar}
%% \hgv dispenses with $\key{terminate}$ by making $\gvEndOutput$
%% unlimited, and builds a pair binding into $\key{receive}$, thus
%% immediately eliminating the tensor.

%% The final five typing rules of Figure~\ref{fig:hgv-typing} extend the
%% functionality of \hgv with respect to GV: $\gvLink{M}{N}$ links
%% channel $M$ to channel $N$, $\gvSendType{S}{M}$ sends session type $S$
%% along $M$, $\gvReceiveType{M}$ receives a type along $M$,
%% $\gvServe{x}{M}$ defines a server as $M$ parameterised by channel $x$,
%% and $\gvRequest{M}$ requests a fresh instance of service $M$.
%% %

%% We argue that each of the five new constructs adds expressive power to
%% GV.
%% %
%% It seems clear that the ability to send and receive types adds
%% expressive power.
%% %
%% One can straightforwardly simulate $\gvLink{M}{N}$ in terms of other
%% constructs for monomorphic types, but not for polymorphic types.
%% %
%% There are parallels between servers and unlimited functions. One might
%% expect to be able to simulate the former in terms of the latter --- a
%% server is much like an unlimited function parameterised by a
%% channel. A key difference is that functions are not session types, so
%% cannot appear everywhere that a server type can.
%% %% Maybe not...
%% %%
%% %% We believe that servers can be simulated by unlimited functions,
%% %% but only if one performs a global translation.
%% %
%% %% A key difference is that we can disassociate a server declaration
%% %% ($\gvWith{s}{\dots}{\dots}$) from its definition
%% %% ($\gvServeOld{s}{x}{\dots}$). Thus, servers support a very limited
%% %% form of linear dynamic binding, which functions do not. We believe
%% %% that servers can be simulated by unlimited functions, but only if one
%% %% performs a global translation similar to closure conversion.
%% %
%% %% In fact, we will be more interested in going the other way,
%% %% translating away functions as sessions.


Each type $T$ is classified as either linear ($\lin{T}$) or unlimited ($\un{T}$); the only unlimited
types are those for services ($\un{\gvService{S}}$), unlimited functions ($\un{\gvUnFun{T}{U}}$) and
input end session ($\un{\gvEndInput}$).

\begin{figure}
\begin{mathpar}
\inferrule[Id]
{ }
{\gvj{x:T}{X}{T}}

\inferrule[Weaken]
{\gvj{\Phi}{N}{U} \\ \un{T}}
{\gvj{\Phi,x:T}{N}{U}}

\inferrule[Contract]
{\gvj{\Phi,x:T,x':T}{N}{U} \\ \un{T}}
{\gvj{\Phi,x:T}{\subst{N}{x}{x'}}{U}}
\end{mathpar}
\hrule
\begin{mathpar}
\inferrule[$\lolli$-I]
{\gvj{\Phi,x:T}{N}{U}}
{\gvj{\Phi}{\gvLam{x}{N}}{\gvLinFun{T}{U}}}

\inferrule[$\lolli$-E]
{\gvj{\Phi}{L}{\gvLinFun{T}{U}} \\ \gvj{\Psi}{M}{T}}
{\gvj{\Phi,\Psi}{\gvApp{L}{M}}{U}}

\\

\inferrule[$\to$-I]
{\gvj{\Phi}{L}{\gvLinFun{T}{U}} \\ \un{\Phi}}
{\gvj{\Phi}{L}{\gvUnFun{T}{U}}}

\inferrule[$\to$-E]
{\gvj{\Phi}{L}{\gvUnFun{T}{U}}}
{\gvj{\Phi}{L}{\gvLinFun{T}{U}}}

\\

%% \inferrule[Unit]
%% { }
%% {\gvj{}{\gvUnit}{\gvUnitType}}

\inferrule[$\otimes$-I]
{\gvj{\Phi}{M}{T} \\ \gvj{\Psi}{N}{U}}
{\gvj{\Phi,\Psi}{\gvPair{M}{N}}{\gvTimes{T}{U}}}

\inferrule[$\otimes$-E]
{\gvj{\Phi}{M}{\gvTimes{T}{U}} \\ \gvj{\Psi,x:T,y:U}{N}{V}}
{\gvj{\Phi,\Psi}{\gvLet{\gvPair{x}{y}}{M}{N}}{V}}
\end{mathpar}
\hrule
\begin{mathpar}
\inferrule[Send]
{\gvj{\Phi}{M}{T} \\ \gvj{\Psi}{N}{\gvOutput{T}{S}}}
{\gvj{\Phi}{\gvSend{M}{N}}{S}}
%% \inferrule[Receive]
%% {\gvj{\Phi}{M}{\gvInput{T}{S}} \\ \gvj{\Psi,x:T,y:S}{N}{V}}
%% {\gvj{\Phi,\Psi}{\gvReceiveK{x}{y}{M}{N}}{V}}

\inferrule[Receive]
{\gvj{\Phi}{M}{\gvInput{T}{S}}}
{\gvj{\Phi}{\gvReceive{M}}{\gvTimes{T}{S}}}
\\
\inferrule[Select]
{\gvj{\Phi}{M}{\gvPlus{\la_i:S_i}{i}}}
{\gvj{\Phi}{\gvSelect{\la_j}{M}}{S_j}}

\inferrule[Case]
{\gvj{\Phi}{M}{\gvChoice{\la_i:S_i}{i}} \\ \row{\gvj{\Psi,x:S_i}{N_i}{T}}{i}}
{\gvj{\Phi,\Psi}{\gvCase{M}{\row{\la_i(x).N_i}{i}}}{T}}
\\
\inferrule[Fork]
{\gvj{\Phi,x:S}{M}{\gvEndOutput}}
{\gvj{\Phi}{\gvFork{x}{M}}{\gvDual{S}}}

%% \inferrule[Connect]
%% {\gvj{\Phi,x:S}{M}{\gvEndOutput} \\ \gvj{\Psi,x:\gvDual{S}}{N}{T}}
%% {\gvj{\Phi,\Psi}{\gvWith{x}{M}{N}}{T}}

\inferrule[Link]
{\gvj{\Phi}{M}{S} \\ \gvj{\Phi}{N}{\gvDual{S}}}
{\gvj{\Phi}{\gvLink{M}{N}}{\gvEndOutput}}

\inferrule[SendType]
{\gvj{\Phi}{M}{\gvOutputType{X}{S}}}
{\gvj{\Phi}{\gvSendType{S}{M}}{\subst{S'}{S}{X}}}

\inferrule[ReceiveType]
{\gvj{\Phi}{M}{\gvInputType{X}{S}} \\ X \notin \FV{\Phi}}
{\gvj{\Phi}{\gvReceiveType M}{S}}

\inferrule[Serve]
{\gvj{\Phi,x : S}{M}{\gvEndOutput} \\ \un{\Phi}}
{\gvj{\Phi}{\gvServe{x}{M}}{\gvService{S}}}

\inferrule[Request]
{\gvj{\Phi}{M}{\gvService{S}}}
{\gvj{\Phi}{\gvRequest{M}}{S}}
\end{mathpar}

\caption{Typing rules for \hgv}
\label{fig:hgv-typing}
\end{figure}

\hgv's terms and their typing rules are given in Figure~\ref{fig:hgv-typing}; the top three rules
are structural, followed by the rules for the functional forms and then those for the session-typed
fragment.  The unusual features of \hgv are captured in the final six rules.  We replace Wadler's
\textsf{with \dots connect \dots to} construct with \textsf{fork}; the two are interdefinable, but
we found \textsf{fork} to be more natural and better aligned with the language of Gay and
Vasconcelos.  We add a term $\gvLink{M}{N}$ to implement channel forwarding; this is provided in
neither Wadler's nor Gay and Vasconcelos's languages, but is necessary to equal the expressivity of
CP.  Finally, we add terms $\gvSendType{S}{M}$ and $\gvReceiveType{S}$ to provide polymorphism, and
$\gvServe{x}{M}$ and $\gvRequest{M}$ to implement replicated sessions.  Note that, as the body $M$
of \textsf{serve} can be arbitrarily replicated, it can only refer to the unlimited portion of the
environment.

We argue that each of the added forms add expressivity to \hgv.  Channel forwarding can be
implemented in a type-directed fashion for any given channel in either Wadler's GV or Gay and
Vasconcelos's language, but neither allows a generic description of forwarding, nor one that would
account for polymorphic sessions.  GV supports no notion of replication; Gay and Vasconcelos provide
arbitrary recursive sessions instead of replication, which do not admit an interpretation in linear
logic.

\todo{Say something about unlimited functions and replication.}

%% Notice that the non-session and session fragments are orthogonal, in
%% that the non-session rules mention only non-session type constructors,
%% and the session rules mention only session type constructors. This is
%% a useful property which does not hold of the original GV. As we shall
%% see, it enables us to compile away the non-session fragment into the
%% session fragment.
%%
%% Vanilla GV, has session constructs $\key{receive}$ and
%% $\key{terminate}$, both of whose typing rules mention non-session
%% types.
%% \begin{mathpar}
%% \inferrule[Receive-$\otimes$]
%% {\gvj{\Phi}{M}{\gvInput{T}{S}}}
%% {\gvj{\Phi}{\gvReceive{M}}{\gvTimes{T}{S}}}
%%
%% \inferrule[Terminate-$\otimes$]
%% {\gvj{\Phi}{M}{\gvTimes{T}{\gvEndInput}}}
%% {\gvj{\Phi}{\gvTerminate{M}}{T}}
%% \end{mathpar}
%% \hgv dispenses with $\key{terminate}$ by making $\gvEndOutput$
%% unlimited, and builds a pair binding into $\key{receive}$, thus
%% immediately eliminating the tensor.
%%
%% The final five typing rules of Figure~\ref{fig:hgv-typing} extend the
%% functionality of \hgv with respect to GV: $\gvLink{M}{N}$ links
%% channel $M$ to channel $N$, $\gvSendType{S}{M}$ sends session type $S$
%% along $M$, $\gvReceiveType{M}$ receives a type along $M$,
%% $\gvServe{x}{M}$ defines a server as $M$ parameterised by channel $x$,
%% and $\gvRequest{M}$ requests a fresh instance of service $M$.
%% %
%%
%% We argue that each of the five new constructs adds expressive power to
%% GV.
%% %
%% It seems clear that the ability to send and receive types adds
%% expressive power.
%% %
%% One can straightforwardly simulate $\gvLink{M}{N}$ in terms of other
%% constructs for monomorphic types, but not for polymorphic types.
%% %
%% There are parallels between servers and unlimited functions. One might
%% expect to be able to simulate the former in terms of the latter --- a
%% server is much like an unlimited function parameterised by a
%% channel. A key difference is that functions are not session types, so
%% cannot appear everywhere that a server type can. We believe that
%% servers can be simulated by unlimited functions, but only if one
%% performs a global translation.
%% %
%% %% A key difference is that we can disassociate a server declaration
%% %% ($\gvWith{s}{\dots}{\dots}$) from its definition
%% %% ($\gvServeOld{s}{x}{\dots}$). Thus, servers support a very limited
%% %% form of linear dynamic binding, which functions do not. We believe
%% %% that servers can be simulated by unlimited functions, but only if one
%% %% performs a global translation similar to closure conversion.
%% %
%% In fact, we will be more interested in going the other way,
%% translating away functions as sessions.

\section{From CP to \hgvpi}
~

As a convenience we will use the following syntactic sugar in this
section.
\[
\gvLet{x}{M}{N} = \gvSend{M}{(\gvFork{z}{\gvReceiveK{x}{z}{z}{\gvLink{N}{z}}})}
\]
This may look surprising, but the $\gvLet{x}{M}{N}$ is commonly used
as syntactic sugar for $\gvApp{(\gvLam{x}{N})}{M}$, and the right hand
side is identical to $\lampi{\gvApp{(\gvLam{x}{N})}{M}}$ where the
translation $\lampi{-}$ is defined in the next section.

Types
\begin{align*}
\cptogv{\cpTimes{A}{B}} &= \gvOutput{\gvDual{\cptogv{A}}}{\cptogv{B}} & \cptogv{\cpOne} &= \gvEndOutput \\
\cptogv{\cpPar{A}{B}} &= \gvInput{\cptogv{A}}{\cptogv{B}} & \cptogv{\cpBottom} &= \gvEndInput \\
\cptogv{\cpPlus{\la_i:A_i}{i}} &= \gvPlus{\la_i:\cptogv{A_i}}{i} & \cptogv{\cpOfCourse{A}} &= \gvServer{\cptogv{A}} \\
\cptogv{\cpWith{\la_i:A_i}{i}} &= \gvChoice{\la_i:\cptogv{A_i}}{i} & \cptogv{\cpWhyNot{A}} &= \gvService{\cptogv{A}} \\
\cptogv{\cpExists{X}{A}} &= \gvOutputType{X}{\cptogv{A}} & \cptogv{X} &= X \\
\cptogv{\cpForall{X}{A}} &= \gvInputType{X}{\cptogv{A}} \\
\end{align*}

Terms
\begin{equations}
\cptogv{\cpCut{x}{P}{Q}} &=&
  \gvLet{x}{\gvFork{x}{\cptogv{P}}}{\cptogv{Q}} \\
\cptogv{\cpOutput{x}{y}{P}{Q}} &=&
  \gvLet{x}{\gvSend{(\gvFork{y}{\cptogv{P}})}{x}}{\cptogv{Q}} \\
\cptogv{\cpInput{x}{y}{P}} &=&
  \gvLet{\gvPair{y}{x}}{\gvReceive{x}}{\cptogv{P}} \\
\cptogv{\cpInject{x}{\la}{P}} &=&
  \gvLet{x}{\gvSelect{\la}{x}}{\cptogv{P}} \\
\cptogv{\cpCase{x}{\row{\la_i.P_i}{i}}} &=&
  \gvCase{x}{\row{\la_i(x).\cptogv{P_i}}{i}} \\
\cptogv{\cpEmptyOut{x}} &=& x \\
\cptogv{\cpEmptyIn{x}{P}} &=& \cptogv{P} \\[1ex]
  %% \gvLet{z}{\gvTerminate{x}}{\cptogv{P}} \\[1ex]

\cptogv{\cpSendType{x}{A}{P}} &=&
  \gvLet{x}{\gvSendType{\cptogv{A}}{x}}{\cptogv{P}} \\
\cptogv{\cpReceiveType{x}{X}{P}} &=&
  \gvLet{x}{\gvReceiveType{x}}{\cptogv{P}} \\[1ex]

\cptogv{\cpLink{x}{y}} &=& \gvLink{x}{y} \\
\cptogv{\cpServe{s}{x}{P}} &=&
  \gvLink{s}{(\gvServe{x}{\cptogv{P}})} \\
\cptogv{\cpRequest{s}{x}{P}} &=&
  \gvLet{x}{\gvFork{x}{\gvLink{(\gvRequest{s})}{x}}}{\cptogv{P}} \\
\end{equations}

Judgements
\begin{equations}
\cptogv{\cpj{P}{\G}} = \gvj{\cptogv{\G}}{\cptogv{P}}{\gvEndOutput}
\end{equations}

\section{From \hgv to \hgvpi}


The language \hgvpi is the restriction of \hgv to session types,
that is, \hgv without $\lolli$, $\to$, or $\otimes$.

The translation on types is given by the homomorphic extension of the
following equations.
\[
\lampi{\gvLinFun{T}{U}} = \gvOutput{\lampi{T}}{\gvDual{\lampi{U}}} \qquad
\lampi{\gvUnFun{T}{U}} = \gvService{(\gvOutput{\lampi{T}}{\gvDual{\lampi{U}}})} \qquad
\lampi{\gvTimes{T}{U}} = \gvInput{\lampi{T}}{\gvDual{\lampi{U}}}
\]%
Each target type is the \emph{interface} to the simulated source
type. A linear function is simulated by input on a channel; its
interface is output on the other end of the channel. An unlimited
function is simulated by a server; its interface is a client. A tensor
is simulated by output on a channel; its interface is input on the
other end of that channel.
%
This duality between implementation and interface explains the
dualisation of types in Wadler's original CPS translation from GV to
CP.

The translation on terms is given by the homomorphic extension of the
following equations.
\begin{equations}
\lampi{\gvLam{x}{M}} &=& \gvFork{z}{\gvLet{\gvPair{x}{z}}{\gvReceive{z}}{\gvLink{\lampi{M}}{z}}} \\
\lampi{\gvApp{L}{M}} &=& \gvSend{\lampi{M}}{\lampi{L}} \\
\lampi{\gvTimes{M}{N}} &=&
  \gvFork{z}
    {\gvLink{(\gvSend{\lampi{M}}{z})}{\lampi{N}}} \\
\lampi{\gvLet{\gvPair{x}{y}}{M}{N}} &=&
    \gvLet{\gvPair{x}{y}}{\gvReceive{\lampi{M}}}{\lampi{N}} \\
\lampi{L : \gvUnFun{T}{U}} &=&
  \gvFork{z}{\gvLink{z}{(\gvServe{y}{\gvLink{\lampi{L}}{y}})}} \\
\lampi{L : \gvLinFun{T}{U}} &=& \gvRequest{\lampi{L}} \\
\lampi{\gvReceive{M}} &=& \lampi{M} \\
\end{equations}%
Each introduction form translates to a term $\gvFork{z}{M}$, where $M
: \gvEndOutput$ provides the simulated implementation of the
introduction form with $z : S$ bound in $M$, and $\gvDual{S}$ provides
its interface.

The translation on contexts is pointwise.
\begin{equations}
\lampi{x_1:T_1, \dots, x_n:T_n} &=& x_1:\lampi{T_1}, \dots, x_n:\lampi{T_n} \\
\end{equations}%
It is straightforward to verify that the translation preserves typing.
\begin{theorem}
If $\gvj{\Phi}{M}{T}$ then $\gvj{\lampi{\Phi}}{\lampi{M}}{\lampi{T}}$.
\end{theorem}

%% \begin{equations}
%% \lampi{\gvj{\Phi}{M}{T}} &=& \gvj{\lampi{\Phi}}{\lampi{M}}{\lampi{T}} \\
%% \end{equations}%



\section{From \hgvpi to CP}
~



Session types
\begin{align*}
\hgvcp{\gvOutput{T}{S}}        &= \cpTimes{\cpDual{\hgvcp{T}}}{\hgvcp{S}} & \hgvcp{X}                       &= X \\
\hgvcp{\gvInput{T}{S}}         &= \cpPar{\hgvcp{T}}{\hgvcp{S}} & \hgvcp{\gvOutputType{X}{S}}     &= \cpExists{X}{\hgvcp{S}} \\
\hgvcp{\gvPlus{\la_i:S_i}{i}}   &= \cpPlus{\la_i:\hgvcp{S_i}}{i} & \hgvcp{\gvInputType{X}{S}}      &= \cpForall{X}{\hgvcp{S}} \\
\hgvcp{\gvChoice{\la_i:S_i}{i}} &= \cpWith{\la_i:\hgvcp{S_i}}{i} & \hgvcp{\gvServer{S}}  &=\: \cpOfCourse{\hgvcp{S}} \\
\hgvcp{\gvEndOutput}              &= \cpOne & \hgvcp{\gvService{S}} &= \: \cpWhyNot{\hgvcp{S}} \\
\hgvcp{\gvEndInput}               &= \cpBottom
\end{align*}

Terms

\newcommand{\hgvcpl}{\left\llbracket}
\newcommand{\hgvcpr}{\right\rrbracket}

\begin{mathpar}
\hgvcpl \inferrule{\gvj{\Phi}{N}{S}}{\gvj{\Phi,x:\gvEndInput}{N}{S}} \hgvcpr z =
  \inferrule
    {\cpj{\hgvcp{N}z}{\hgvcp{\Phi},z:\cpDual{\hgvcp{S}}}}
    {\cpj{\cpEmptyIn{x}{\hgvcp{N}z}}{\hgvcp{\Phi},x:\cpBottom,z:\cpDual{\hgvcp{S}}}}
\\
\hgvcpl \inferrule{\gvj{\Phi,x:\gvEndInput,x':\gvEndInput}{N}{S}}
                          {\gvj{\Phi,x:\gvEndInput}{\subst{N}{x}{x'}}{S}} \hgvcpr z =
  \inferrule
    {\cpj{\hgvcp{N}z}{\hgvcp{\Phi},x:\cpBottom,x':\cpBottom,z:\cpDual{\hgvcp{S}}}}
    {\cpj{\cpCut{x'}{\hgvcp{N}z}{\cpEmptyOut{x'}}}{\hgvcp{\Phi},x:\cpBottom,z:\cpDual{\hgvcp{S}}}}
\end{mathpar}
\begin{equations}
\hgvcp{x}z &=& \cpLink{x}z \\
\hgvcp{\gvSend{M}{N}}z &=& \cpCut{x}{\cpOutput{x}{y}{\hgvcp{M}y}{\cpLink{x}{z}}}{\hgvcp{N}x} \\
\hgvcp{\gvReceiveK{y}{x}{M}{N}}z &=&
  \cpCut{x}{\hgvcp{M}x}{\cpInput{x}{y}{\hgvcp{N}z}} \\
\hgvcp{\gvSelect{\la}{M}}z &=&
  \cpCut{x}{\hgvcp{M}x}{\cpInject{x}{\la}{\cpLink{x}{z}}} \\
\hgvcp{\gvCase{M}{\row{\la_i(x).N_i}{i}}}z &=&
  \cpCut{x}{\hgvcp{M}x}{\cpCase{x}{\row{\la_i.N_i}{i}}} \\
\hgvcp{\gvFork{x}{M}}z &=&
  \cpCut{x}{\cpCut{y}{\hgvcp{M}y}{\cpEmptyOut{y}}}{\cpLink{x}{z}} \\[1ex]

\hgvcp{\gvSendType{S}{M}}z &=&
  \cpCut{x}{\hgvcp{M}x}{\cpSendType{x}{\hgvcp{S}}{\cpLink{x}{z}}} \\
\hgvcp{\gvReceiveType{(M \mathbin{:} {\gvInputType{X}{S}})}}z &=&
  \cpCut{x}{\hgvcp{M}x}{\cpReceiveType{x}{X}{\cpLink{x}{z}}} \\[1ex]

\hgvcp{\gvLink{M}{N}}z &=& \cpEmptyIn{z}{\cpCut{x}{\hgvcp{M}x}{\cpCut{y}{\hgvcp{N}y}{\cpLink{x}{y}}}} \\
\hgvcp{\gvServe{y}{M}}z &=&
   \cpServe{z}{y}
      {\cpCut{x}{\hgvcp{M}x}{\cpEmptyOut{x}}} \\
\hgvcp{\gvRequest{M}}z &=& \cpCut{x}{\hgvcp{M}x}{\cpRequest{x}{y}{\cpLink{y}{z}}} \\
\end{equations}

%% Horrible verbose versions of the rules for sending and receiving types
%% \begin{mathpar}
%% \left\llbracket
%%   \inferrule
%%      {\gvj{\Phi}{M}{\gvOutputType{X}{S}}}
%%      {\gvj{\Phi}{\gvSendType{S'}{M}}{\subst{S}{S'}{X}}}
%% \right\rrbracket z =
%%   \inferrule*
%%     {
%%       \inferrule*
%%         {}
%%         {\cpj{\hgvcp{M}x}{\hgvcp{\Phi},x:\cpForall{X}{\cpDual{\hgvcp{S}}}}}
%%       \\
%%       \inferrule*
%%         {\inferrule*
%%            { }
%%            {\cpj{\cpLink{x}{z}}
%%              {\hgvcp{\Phi},x:\hgvcp{\subst{S}{S'}{X}},
%%                            z:\cpDual{\hgvcp{\subst{S}{S'}{X}}}}}}
%%         {\cpj{\cpSendType{x}{\hgvcp{S'}}{\cpLink{x}{z}}}
%%              {\hgvcp{\Phi},x:\cpExists{X}{\hgvcp{S}},
%%                            z:\cpDual{\hgvcp{\subst{S}{S'}{X}}}}}
%%     }
%%     {\cpj{\cpCut{x}{\hgvcp{M}x}{\cpSendType{x}{\hgvcp{S'}}{\cpLink{x}{z}}}}
%%          {\hgvcp{\Phi},z:\cpDual{\hgvcp{\subst{S}{S'}{X}}}}}
%% \\
%% \left\llbracket
%%   \inferrule
%%      {\gvj{\Phi}{M}{\gvInputType{X}{S}} \\ X \notin \FV{\Phi}}
%%      {\gvj{\Phi}{\gvReceiveType{M}}{S}}
%% \right\rrbracket z =
%%   \inferrule*
%%     {\inferrule*
%%        {}
%%        {\cpj{\hgvcp{M}x}{\hgvcp{\Phi},x:\cpExists{X}{\cpDual{\hgvcp{S}}}}}
%%      \\
%%      \inferrule*
%%        {\inferrule*
%%             { }
%%             {\cpj{\cpLink{x}{z}}
%%               {\hgvcp{\Phi},x:\hgvcp{S}
%%                            ,z:\cpDual{\hgvcp{S}}}}
%%         \\ X \notin \FV{\hgvcp{\Phi}}
%%        }
%%        {\cpj{\cpReceiveType{x}{X}{\cpLink{x}{z}}}
%%           {\hgvcp{\Phi},x:\cpForall{X}{\hgvcp{S}}
%%                        ,z:\cpDual{\hgvcp{S}}}}
%%     }
%%     {\cpj{\cpCut{x}{\hgvcp{M}x}{\cpReceiveType{x}{X}{\cpLink{x}{z}}}}
%%          {\hgvcp{\Phi},z:\cpDual{\hgvcp{S}}}} \\
%% \end{mathpar}

The translation on contexts is pointwise.
\begin{equations}
\hgvcp{x_1:T_1, \dots, x_n:T_n} &=& x_1:\hgvcp{T_1}, \dots, x_n:\hgvcp{T_n} \\
\end{equations}%
It is straightforward to verify that the translation preserves typing.
\begin{theorem}
If $\gvj{\Phi}{M}{S}$ then $\cpj{\hgvcp{M}}{\hgvcp{\Phi},z:\cpDual{\hgvcp{S}}}$.
\end{theorem}


%% Judgements
%% \begin{equations}
%% \hgvcp{\gvj{\Phi}{M}{T}} &=& \cpj{\hgvcp{M}z}{\hgvcp{\Phi}, z:\cpDual{\hgvcp{T}}}
%% \end{equations}



\section{Conclusions and Future Work}

In this paper, we have proposed a session-typed functional language, \hgv, which builds on the
similar languages of Wadler and Gay and Vasconcelos.  We have demonstrated that \hgv is sufficient
to encode arbitrary linear logic proofs, completing the correspondence between linear logic and
session typing.  We have also demonstrated that we can code the functional fragment of \hgv in terms
of its session fragment, simplifying the translation from \hgv to CP.  To conclude, we identify
three important areas for continued research.
\begin{itemize}
\item In this paper, we have given a semantics to \hgv only via its translation to CP.  We would
  like to give \hgv a semantics directly, in terms of reductions of configurations of processes, and
  then to show that such an approach is equivalent to translation to CP.
\item Replication has limited expressive power compared to recursion; in particular, it cannot
  express services whose behavior changes over time or in response to client requests.  We believe
  that the study of fixed points in linear logic provides a mechanism to support more expressive
  recursive behavior without sacrificing the logical interpretation of \hgv.
\item The semantics of \hgv is equivalent to that of cut elimination in linear logic.  As linear
  logic proofs enjoy weak normalization, \hgv programs are also deterministic.  We hope to identify
  further extensions of \hgv that would introduce non-determinism, and thus allow \hgv programs with
  a wider variety of concurrent behaviors, while preserving as much of the connection to linear
  logic as possible.
\end{itemize}





\label{sect:bib}
\bibliographystyle{plain}
%\bibliographystyle{alpha}
%\bibliographystyle{unsrt}
%\bibliographystyle{abbrv}
\bibliography{cpgv}

\appendix

%% \subsection{GV extensions}

%% \begin{mathpar}
%% \inferrule
%% {\gvj{\Phi}{M}{\gvInputType{X}{S}}}
%% {\gvj{\Phi}{\gvSendType{S}{M}}{S'[S/X]}}

%% \inferrule
%% {\gvj{\Phi}{M}{\gvOutputType{X}{S}} \\ X \notin \FV{\Phi}}
%% {\gvj{\Phi}{\gvReceiveType M}{S'}}
%% \end{mathpar}

%% \begin{mathpar}
%% \inferrule
%% {\gvj{\Phi}{M}{S} \\ \gvj{\Phi}{N}{\gvDual{S}}}
%% {\gvj{\Phi}{\gvLink{M}{N}}{\gvEndOutput}}

%% \inferrule
%% {\gvj{\Phi, s : \gvServer{S}, x : S}{M}{\gvEndOutput}}
%% {\gvj{\Phi}{\gvServeOld{s}{x}{M}}{\gvEndOutput}}

%% \inferrule
%% { }
%% {\gvj{\Phi, s : \gvService{S}}{\gvRequest{s}}{S}}
%% \end{mathpar}


\newpage

\section{From GV to CP}
~

Session types
\begin{equations}
\gvtocp{\gvOutput{T}{S}}        &=& \cpPar{\cpDual{\gvtocp{T}}}{\gvtocp{S}} \\
\gvtocp{\gvInput{T}{S}}         &=& \cpTimes{\gvtocp{T}}{\gvtocp{S}} \\
\gvtocp{\gvPlus{\la_i:S_i}{i}}   &=& \cpWith{\la_i:\gvtocp{S_i}}{i} \\
\gvtocp{\gvChoice{\la_i:S_i}{i}} &=& \cpPlus{\la_i:\gvtocp{S_i}}{i} \\
\gvtocp{\gvEndOutput}              &=& \cpBottom \\
\gvtocp{\gvEndInput}               &=& \cpOne \\[1ex]

\gvtocp{X}                       &=& X \\
\gvtocp{\gvOutputType{X}{S}}     &=& \cpForall{X}{\gvtocp{S}} \\
\gvtocp{\gvInputType{X}{S}}      &=& \cpExists{X}{\gvtocp{S}} \\[1ex]

\gvtocp{\gvServer{S}}  &=& \cpWhyNot{\gvtocp{S}} \\
\gvtocp{\gvService{S}} &=& \cpOfCourse{\gvtocp{S}} \\[1ex]
\end{equations}

Non-session types
\begin{equations}
\gvtocp{\gvLinFun{T}{U}} &=& \cpPar{\cpDual{\gvtocp{T}}}{\gvtocp{U}} \\
\gvtocp{\gvUnFun{T}{U}} &=& \cpOfCourse{(\cpPar{\cpDual{\gvtocp{T}}}{\gvtocp{U}})} \\
\gvtocp{\gvTimes{T}{U}} &=& \cpTimes{\gvtocp{T}}{\gvtocp{U}} \\
\gvtocp{\gvUnitType} &=& \cpOfCourse{(\cpWith{}{})} \\
\end{equations}

Terms
\begin{equations}
\gvtocp{\gvSendType{S}{(M : \cpForall{X}{S'})}}z &=&
  \cpCut{(x:\cpExists{X}{\cpDual{\gvtocp{S'}}})}{\cpSendType{x}{\gvtocp{S}}{\cpLink{x}{z}}}{\gvtocp{M}x} \\
\gvtocp{\gvReceiveType{(M : \cpExists{X}{S'})}}z &=&
  \cpCut{(x:\cpForall{X}{\cpDual{\gvtocp{S'}}})}{\cpReceiveType{x}{X}{\cpLink{x}{z}}}{\gvtocp{M}x} \\
\\[1ex]
\gvtocp{\gvLink{M}{N}}z &=& \cpCut{x}{\gvtocp{M}x}{\cpCut{y}{\gvtocp{N}y}{\cpEmptyIn{z}{\cpLink{x}{y}}}} \\
\gvtocp{\gvServeOld{s}{x}{M}}z &=&
  \cpEmptyIn{z}
            {\cpServe{s}{x}
                     {\cpCut{y}{\cpEmptyOut{y}}{\gvtocp{M}y}}} \\
\gvtocp{\gvRequest{s}}z &=& \cpRequest{s}{x}{\cpLink{x}{z}} \\
\end{equations}

Horrible verbose versions of the rules for sending and receiving types
\begin{mathpar}
\left\llbracket
  \inferrule
     {\gvj{\Phi}{M}{\gvOutputType{X}{S}}}
     {\gvj{\Phi}{\gvSendType{S'}{M}}{\subst{S}{S'}{X}}}
\right\rrbracket z =
  \inferrule*
    {
      \inferrule*
        {}
        {\cpj{\hgvcp{M}x}{\hgvcp{\Phi},x:\cpForall{X}{\cpDual{\hgvcp{S}}}}}
      \\
      \inferrule*
        {\inferrule*
           { }
           {\cpj{\cpLink{x}{z}}
             {\hgvcp{\Phi},x:\hgvcp{\subst{S}{S'}{X}},
                           z:\cpDual{\hgvcp{\subst{S}{S'}{X}}}}}}
        {\cpj{\cpSendType{x}{\hgvcp{S'}}{\cpLink{x}{z}}}
             {\hgvcp{\Phi},x:\cpExists{X}{\hgvcp{S}},
                           z:\cpDual{\hgvcp{\subst{S}{S'}{X}}}}}
    }
    {\cpj{\cpCut{x}{\hgvcp{M}x}{\cpSendType{x}{\hgvcp{S'}}{\cpLink{x}{z}}}}
         {\hgvcp{\Phi},z:\cpDual{\hgvcp{\subst{S}{S'}{X}}}}}
\\
\left\llbracket
  \inferrule
     {\gvj{\Phi}{M}{\gvInputType{X}{S}} \\ X \notin \FV{\Phi}}
     {\gvj{\Phi}{\gvReceiveType{M}}{S}}
\right\rrbracket z =
  \inferrule*
    {\inferrule*
       {}
       {\cpj{\hgvcp{M}x}{\hgvcp{\Phi},x:\cpExists{X}{\cpDual{\hgvcp{S}}}}}
     \\
     \inferrule*
       {\inferrule*
            { }
            {\cpj{\cpLink{x}{z}}
              {\hgvcp{\Phi},x:\hgvcp{S}
                           ,z:\cpDual{\hgvcp{S}}}}
        \\ X \notin \FV{\hgvcp{\Phi}}
       }
       {\cpj{\cpReceiveType{x}{X}{\cpLink{x}{z}}}
          {\hgvcp{\Phi},x:\cpForall{X}{\hgvcp{S}}
                       ,z:\cpDual{\hgvcp{S}}}}
    }
    {\cpj{\cpCut{x}{\hgvcp{M}x}{\cpReceiveType{x}{X}{\cpLink{x}{z}}}}
         {\hgvcp{\Phi},z:\cpDual{\hgvcp{S}}}} \\
\end{mathpar}

Judgements
\begin{equations}
\gvtocp{\gvj{\Phi}{M}{T}} &=& \cpj{\gvtocp{M}z}{\cpDual{\gvtocp{\Phi}}, z:\gvtocp{T}}
\end{equations}


%% Theorem:

%%   [[((A))]] = ~A
%%   [[((P |- G))]] = Q |- G, z : bot
%%     where nu z.(z[].0|Q) --> P

%%   (([[S]])) = ~S
%%   (([[Phi |- M : S]] z)) = Phi |- N : end!
%%     where
%%       nu w.(w[].0|[[N]]w) --> [[M]]z

\section{Alternative translations from GV to CP}

\subsection{Dualising the interpretation of judgements}

It is possible to avoid the dualisation of session types in the type
translation by dualising the interpretation of judgements.

Judgements
\begin{equations}
\gvtocps{\gvj{\Phi}{M}{T}} &=& \cpj{\gvtocp{M} z}{\gvtocps{\Phi}, z:\cpDual{(\gvtocps{T})}}
\end{equations}

Session types
\begin{equations}
\gvtocps{\gvOutput{T}{S}}        &=& \cpTimes{\cpDual{\gvtocps{T}}}{\gvtocps{S}} \\
\gvtocps{\gvInput{T}{S}}         &=& \cpPar{\gvtocps{T}}{\gvtocps{S}} \\
\gvtocps{\gvPlus{\la_i:S_i}{i}}   &=& \cpPlus{\la_i:\gvtocps{S_i}}{i} \\
\gvtocps{\gvChoice{\la_i:S_i}{i}} &=& \cpWith{\la_i:\gvtocps{S_i}}{i} \\
\gvtocps{\gvEndOutput}              &=& \cpOne \\
\gvtocps{\gvEndInput}               &=& \cpBottom \\[1ex]

\gvtocps{\gvServer{S}}  &=& \cpOfCourse{\gvtocps{S}} \\
\gvtocps{\gvService{S}} &=& \cpWhyNot{\gvtocps{S}} \\[1ex]
\end{equations}


The idea is that the term translation stays exactly the same. This
approach fits with the view of $z$ as a negative continuation
parameter. It yields a straightforward interpretation of session
types, but then the interpretation of non-session types (linear
functions, unrestricted functions, tensor, and unit), becomes dual to
what one would normally expect.

Non-session types
\begin{equations}
\gvtocps{\gvLinFun{T}{U}} &=& \cpTimes{\gvtocp{T}}{\cpDual{\gvtocp{U}}} \\
\gvtocps{\gvUnFun{T}{U}} &=& \cpWhyNot{(\cpTimes{\gvtocp{T}}{\cpDual{\gvtocp{U}}})} \\
\gvtocps{\gvTimes{T}{U}} &=& \cpPar{\cpDual{\gvtocp{T}}}{\cpDual{\gvtocp{U}}} \\
\gvtocps{\gvUnitType} &=& \cpWhyNot{(\cpPlus{}{})} \\
\end{equations}

\subsection{Adapting the translation on terms}

As an alternative to dualising the interpretation of non-session
types, we can attempt to keep the standard interpretation of
non-session types and instead adapt the translation on terms.

Judgements
\begin{equations}
\gvtocpd{\gvj{\Phi}{M}{T}} &=& \cpj{\gvtocpd{M} z}{\gvtocpd{\Phi}, z:{\gvtocpd{T}}}
\end{equations}

This looks like it might work if we add the Mix rule to CP along with
another rule which can be derived from BiCut, but which appears to
be weaker.

\begin{mathpar}
\inferrule
{\cpj{P}{\G, y:A, z:C} \\ \cpj{Q}{\D, x:B, z:\cpDual{C}}}
{\cpj{\cpCutOutput{z}{x}{y}{P}{Q}}{\G, \D, x : \cpTimes{A}{B}}}
\end{mathpar}

%%   [[
%%   Phi |- L : T -o U  un(Phi)
%%   --------------------------
%%   Phi |- L : T -> U
%%   ]] z
%% =
%%   [[L]]y |- [[Phi]], y:~[[T -o U]]
%%   --------------------------------------------
%%   ?z[y].[[L]]y |- [[Phi]], z:?(~[[T -o U]])

%%   [[
%%   Phi |- L : T -> U
%%   -----------------
%%   Phi |- L : T -o U
%%   ]] z
%% =
%%                                            x <-> z |- x:[[T -o U]], z:~([[T -o U]])
%%                                         ---------------------------------------------------
%%   [[L]]y |- [[Phi]], y:?(~[[T -o U]])   !y(x).x <-> z |- y:!([[T -o U]]), z:~([[T -o U]])
%%   ------------------------------------------------------------------------------------------
%%   nu y.([[L]]y | !y(x).x <-> z) |- [[Phi]], z:~[[T -o U]]
%%
%% Oops! z can't appear inside the server output!


%% z : [[T]] * ~[[U]]
%% [[\x.M]]z = nu y.z[x].([[M]]y | y <-> z)
%% [[\x.M]]z = nu y x.([[M]]y | z[w].(w <-> x | y <-> z))

%% z : ~[[U]]
%% [[L M]]z = nu y.([[L]]y | y(x).([[M]]x | y <-> z))

%% z : ~[[T]] || ~[[U]]
%% [[(M, N)]]z = z(x).([[M]]x | [[N]]z)

%% z : ~[[V]]
%% [[let (x,y)=M in N]]z = nu w.([[M]]w | nu y.w[x].([[N]]z | w <-> y))

%% Cutting an output with a private channel against an input with a
%% mix would appear to yield a term containing a plain bicut and a mix

%%    nu x.(x[y].nu z.(P | Q) | x(y).(R | S))
%%  -->
%%    nu y z.(P | nu x.(Q | (R | S)))


Non-session terms
\begin{equations}
\gvtocpd{\lambda x:T.M}z &=&
  \cpCutOutput{y:{\cpDual{\gvtocpd{U}}}}{z}{x:{\gvtocpd{T}}}
              {\gvtocpd{M}y}{\cpLink{y}{z}} \\
\gvtocpd{L~M}z &=&
  \cpCut{y:\cpTimes{\gvtocpd{T}}{\cpDual{\gvtocpd{U}}}}
        {\gvtocpd{L}y}
        {\cpInput{y}{x:\cpDual{\gvtocpd{U}}}{\cpMix{\gvtocpd{M}x}{\cpLink{y}{z}}}} \\
\gvtocpd{\gvPair{M}{N}}z &=&
  \cpInput{z}{x:\cpDual{\gvtocpd{T}}}{\cpMix{\gvtocpd{M}x}{\gvtocpd{N}z}} \\
\gvtocpd{\gvLet{\gvPair{x}{y}}{M}{N}}z &=&
  \cpCut{w:\cpPar{\cpDual{\gvtocpd{T}}}{\cpDual{\gvtocpd{U}}}}
    {\gvtocpd{M}w}
    {\cpCutOutput{y:\gvtocpd{U}}{w}{x:\gvtocpd{T}}{\gvtocpd{N}z}{\cpLink{w}{y}}} \\
\end{equations}

Where this approach seems to completely break down is in the
translation of the elimination rule for unrestricted functions. We
might reasonably hope to simulate linear lambdas using output rather
than input, but it seems unreasonable to expect to simulate
unrestricted lambda application using a linear server rather than an
unrestricted client.

\subsection{Compiling away non-session types}

Another option is to compile away non-session types in GV as a
pre-processing step, where the type translation is given by
$\cptogv{\gvtocp{-}}$ and the term translation by
$\cptogv{\gvtocp{-}z}$.

%% T -o U --> ~[[T]] || [[U]] --> ?~T*.U*
%% T -> U --> !(~[[T]] || [[U]]) --> $(?~T*.U*)
%% T * U --> [[T]] * [[U]] --> !~T*.U*
%% Unit --> !&{} --> $&{}

%% Hmmm... Looks like things are the wrong way round in the GV to CP
%% translation: input types should be negated and output types
%% should't.

We could simply compose the translations as described, but then it
would seem that we would have to perform a global CPS transformation
on all terms including the session typing constructs. This would be
rather disappointing, as then we would appear to have to effectively
perform a CPS transformation twice on such terms in order to generate
a CP term.

% channel passing translation
\newcommand{\gvtogv}[1]{({#1})^\star}

We can do better, though, by performing a local transformation. The
key observation is that we can locally abstract over the continuation
channel $z$ in a term $M$ using $\gvWith{z}{M}{z}$.

This is where the dualisation of types arises: the type of the whole
expression must be dual to the type of $z$ in $M$. For instance, we
implement a lambda of type $\gvLinFun{T}{U}$ with a channel $z$ of
type $\gvInput{\gvDual{\gvtogv{T}}}{\gvtogv{U}}$, but the interface to
the lambda is the other end of the channel $z$ which has type
$\gvOutput{\gvtogv{T}}{\gvDual{\gvtogv{U}}}$ (and application becomes
simply sending the argument along this channel).

\begin{equations}
\gvtogv{\gvLinFun{T}{U}} &=& \gvOutput{\gvtogv{T}}{\gvDual{\gvtogv{U}}} \\
\gvtogv{\gvUnFun{T}{U}} &=& \gvService{(\gvOutput{\gvtogv{T}}{\gvDual{\gvtogv{U}}})} \\
\gvtogv{\gvTimes{T}{U}} &=& \gvInput{\gvtogv{T}}{\gvDual{\gvtogv{U}}} \\
\gvtogv{\gvUnitType} &=& \gvService{(\gvPlus{}{})} \\
\end{equations}%

\begin{equations}
\gvtogv{\gvj{\Phi}{M}{T}} &=& \gvj{\gvtogv{\Phi}}{\gvtogv{M}}{\gvtogv{T}} \\
\end{equations}%

\begin{equations}
\gvtogv{\gvLam{x}{M}} &=& \gvWith{z}{\gvLet{\gvPair{x}{z}}{\gvReceive{z}}{\gvLink{\gvtogv{M}}{z}}}{z} \\
\gvtogv{\gvApp{L}{M}} &=& \gvSend{\gvtogv{M}}{\gvtogv{L}} \\
\gvtogv{\gvTimes{M}{N}} &=&
  \gvWith{z}
    {\gvLink{(\gvSend{\gvtogv{M}}{z})}{\gvtogv{N}}}
    {z} \\
\gvtogv{\gvLet{\gvPair{x}{y}}{M}{N}} &=&
    \gvLet{\gvPair{x}{y}}{\gvReceive{\gvtogv{M}}}{\gvtogv{N}} \\
\gvtogv{\gvReceive{M}} &=& M \\
\gvtogv{\gvUnit} &=&
    \gvWith{z}
    {\gvServeOld{z}{x}{\gvCase{x}{\row{}{}}}}
    {z} \\
%% Unnecessary as we don't have a linear unit!
%%
%% \gvtogv{\gvLet{\gvUnit}{M}{N}} &=&
%%   \gvLet{z}{\gvtogv{M}}{\gvtogv{N}} \\
\gvtogv{L : \gvUnFun{T}{U}} &=&
  \gvWith{z}{\gvServeOld{z}{y}{\gvLink{\gvtogv{L}}{y}}}{z} \\
\gvtogv{L : \gvLinFun{T}{U}} &=& \gvRequest{\gvtogv{L}} \\
\end{equations}

A problem we run into is that $\gvReceive{M}$ has tensor type, and yet
our translation is supposed to compile away non-session types,
including tensors. Similarly, $\gvTerminate{M}$ has unit type. The
problem illustrates an irregularity in GV. All of the typing rules for
the other session typing constructs mention only session types.

Dealing with $\key{terminate}$ is easy. We just amend our target
language such that $\gvTerminate{M}$ has type
$\gvService{(\gvPlus{}{})}$, the interpretation of the unit type.
%
Dealing with $\key{receive}$ is a little harder. We still need some
way of binding the two values returned by $\key{receive}$. The
solution is to fuse $\key{receive}$ with the pair elimination
construct. Notice that this is more or less what CP server input does
already. Because we interpret $\gvTimes{T}{U}$ as
$\gvInput{\gvtogv{T}}{\gvDual{\gvtogv{U}}}$, instances of
$\key{receive}$ from the source term are all erased. The only
instances of $\key{receive}$ in the target term arise from
interpreting lambdas and pair elimination. This may seem strange until
one considers that the only way to use the pair resulting from a
$\key{receive}$ in GV is to eliminate it. The transformation shunts
each receive up to the point at which the resulting pair is
eliminated.

\begin{mathpar}
\inferrule
  {\gvj{\Phi}{M}{\gvEndInput}}
  {\gvj{\Phi}{\gvTerminate{M}}{\gvService{(\gvPlus{}{})}}}

\inferrule
  {\gvj{\Phi}{M}{\gvInput{T}{S}} \\ \gvj{\Psi, x:T, y:S}{N}{U}}
  {\gvj{\Phi, \Psi}{\gvLet{\gvPair{x}{y}}{\gvReceive{M}}{N}}{U}}
\end{mathpar}

Another alternative is to get rid of terminate altogether and change
$\gvEndInput$ to be an unrestricted session type. Correspondingly, we
could also interpret the unit type as $\gvEndInput$ and $\gvUnit$ as
$\gvWith{x}{x}{x}$. Making $\gvEndInput$ unrestricted makes sense as
$\gvEndInput = \cptogv{\cpBottom}$, and weakening and contraction are
derivable for $\cpBottom$ in CP.

%------------------------------------------------------------------------------
%%

%------------------------------------------------------------------------------
% Index
%\printindex

%------------------------------------------------------------------------------
\end{document}

Composing the translations

(([[T -o U]])) = ?~(([[T]])).(([[U]]))
(([[T * U]])) = !(([[T]])).(([[U]]))




\x.M --> ((z(x).[[M]]z))  --> let (x,z)=receive z in (([[M]]z))
[[L M]]z --> nu y.([[L]]y | y[x].([[M]]x | y <-> z)) -->
       with y connect
         (([[L]]y))
       to
         with x connect
           (([[M]]x))
         to
           let y=send x y in link y z
(M,N) --> z[y].([[M]]y | [[N]]z) --> with y connect (([[M]]y)) to let z = send y z in (([[N]]z))
let (x, y) = M in N
   --> nu y.([[M]]y | y(x).[[N]]z)
   --> with y connect
         (([[M]]y))
       to
         let (x, y) = receive y in (([[N]]z))

Phi |- L : T -o U  un(Phi)
--------------------------
Phi |- L : T -> U
  --> !z(y).[[L]]y
  --> serve z(y) = (([[L]]y))

Phi |- L : T -> U
-----------------
Phi |- L : T -o U
  --> nu y.([[L]]y | ?y[x].x <-> z)
  --> with y connect
        (([[L]]z))
      to
        with x connect link (request y) x to link x z
  ==
     with y connect
       (([[L]]z))
     to
       link (request y) z

A problem is that we appear to have to CPS transform everything
globally - including the session typing constructs. For instance:

send M N --> nu x.(x[y].([[M]]y | x <-> z) | [[N]]x)
         --> with x connect
               with y connect
                 (([[M]]y))
               to
                 let x = send y x in link x z
             to
               (([[N]]))x

send (\v.v) w -->
    with x connect
      with y connect
        let (v,y) = receive y in link v y
      to
        let x = send y x in link x z
    to
      link w x
  ==
    with y connect
      let (v,y) = receive y in link v y
    to
      let w = send y w in link w z

If we do this as a pre-processing step, then we effectively end up
doing a CPS transformation twice! Can we do some kind of local CPS
transformation:

send (\v.v) w -->
    with y connect
      let (v,y) = receive y in link v y
    to
      send y w
  ==
    send
      (with y connect
        let (v,y) = receive y in link v y
       to
         y)
    w


let syntactic sugar after translating away lambdas:

  let x = M in N
  ==
  send M (with z connect let (x,z)=receive z in link N z to z)



Attempting to undualise the GV to CP translation on types

[[T -o U]] = [[~T || U]]

z : [[T]] * ~[[U]]
[[\x.N]]z = nu y:[[U]].z[x].([[N]]y|y <-> z)



P |- x : A, y : B
----------------------------------------------------
y[x].(P | nu r s.(r <-> x | s <-> y))) |- y : A * B


P |- x : A, x : C     Q |- x : ~C, y : B
----------------------------------------
     nu x.y[z].(P | Q) |- y : A * B

z : ~[[U]]
[[L M]]z = nu y.([[L]]y | y(x).([[M]]x | y <-> z))



y(x).x().y <->z  |- y : bot || 1, z:bot

y(x).y <->z  |- y : 1 || 1, z:bot


[[L]]y |- [[Phi]],y:[[T]]*~[[U]]   ? |- [[Psi]],y:~[[T]] || [[U]],z:~[[U]]
--------------------------------------------------------------------------
? |- [[Phi]],[[Psi]],z:~[[U]]



P |- G,x:~A

? |- G,x:~A,y:B,z:~B
----------------------------------
y(x).? |- y:~A || B,z:~B

z : ~[[T]] || ~[[U]]
[[(M, N)]]z = z(x).([[M]]x || [[N]]z)


x(y).x(z).x().y <-> z |- x:1||(bot || bot)



nu y1 : !top * !top . (foo <-> y1 |  y1(x2).!z0(y3).y3.case(){}) |- foo : ~(!top * !top),z0:!top


  foo : ?#+{}.#+{}, z0 : $&{}
|-
  with y1 : !#+{}.$&{}
  connect
    link foo y1
  to
    let (x2, y1)=receive y1 in serve z0 (y3)=case y3 of {}
: end!


((!top*!top)) = !~((!top)).((!top)) = !#+{}.$&{}

foo : ?#+{}.#+{}, z0 : $&{} |- with y1 : !#+{}.$&{} connect link foo y1 to let (x2, y1)=receive y1 in serve z0 (y3)=case y3 of {} : end!

New version of terminate:

[[terminate M]](z : !top) = nu (x:1).([[M]]x|x().!z(y).y.case())

Let unit:

[[ let () = m in n ]]z = [[ (\().n)m ]] z
  = nu y.(y(x).[[n]]y | y[x].([[m]]x | y <-> z))
  = nu x.(nu y.([[n]]y | y <-> z) | [[m]]x)
  = nu x.([[m]]x | [[n]]z)

Rules for sendType and receiveType

G |- M : ??X.S'
---------------------------
G |- sendType S M : S'[S/X]

G |- M : !!X.S'   X notin FV(G)
-------------------------------
G |- receiveType M : S'

[[sendType S M]](z : S'[S/X]) = nu (x:exists X.[[S']]).(x[S].x <-> z | [[M]]x)
[[receiveType M]](z : S')     = nu.(x:forall X.[[S']]).(x(X).x <-> z | [[M]]x)
