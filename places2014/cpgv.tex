% easychair.tex,v 3.2 2012/05/15
%
% Select appropriate paper format in your document class as
% instructed by your conference organizers. Only withtimes
% and notimes can be used in proceedings created by EasyChair
%
% The available formats are 'letterpaper' and 'a4paper' with
% the former being the default if omitted as in the example
% below.
%
\documentclass{easychair}
%\documentclass[debug]{easychair}
%\documentclass[verbose]{easychair}
%\documentclass[notimes]{easychair}
%\documentclass[withtimes]{easychair}
%\documentclass[a4paper]{easychair}
%\documentclass[letterpaper]{easychair}

% This provides the \BibTeX macro
\usepackage{doc}
\usepackage{makeidx}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{stmaryrd}
\usepackage{mathpartir}

% In order to save space or manage large tables or figures in a
% landcape-like text, you can use the rotating and pdflscape
% packages. Uncomment the desired from the below.
%
% \usepackage{rotating}
% \usepackage{pdflscape}

% If you plan on including some algorithm specification, we recommend
% the below package. Read more details on the custom options of the
% package documentation.
%
% \usepackage{algorithm2e}


%%% macros

\newcommand{\ba}{\begin{array}}
\newcommand{\ea}{\end{array}}

\newenvironment{equations}{\[\ba{@{}r@{~}c@{~}l@{}}}{\ea\]}


\newcommand{\key}{\mathsf}

\newcommand{\set}[1]{\{ #1 \}}


\newcommand{\gvtocp}[1]{\llbracket{#1}\rrbracket}
\newcommand{\cptogv}[1]{\llparenthesis{#1}\rrparenthesis}

\newcommand{\row}[2]{\set{#1}_{#2}}

\newcommand{\gvOutput}[2]{!{#1}.{#2}}
\newcommand{\gvInput}[2]{?{#1}.{#2}}
\newcommand{\gvEndOutput}{\key{end}_!}
\newcommand{\gvEndInput}{\key{end}_?}
\newcommand{\gvPlus}[2]{\oplus \row{#1}{#2}}
\newcommand{\gvChoice}[2]{\binampersand \row{#1}{#2}}
\newcommand{\gvServer}[1]{\${#1}}
\newcommand{\gvService}[1]{\#{#1}}
\newcommand{\gvDual}[1]{\overline{#1}}
\newcommand{\gvOutputType}[2]{![{#1}].{#2}}
\newcommand{\gvInputType}[2]{?[{#1}].{#2}}

\newcommand{\cpj}[2]{{#1} \vdash {#2}}
\newcommand{\gvj}[3]{{#1} \vdash {#2} : {#3}}

\newcommand{\la}{l}
\newcommand{\G}{\Gamma}
\newcommand{\D}{\Delta}

\newcommand{\gvLinFun}[2]{{#1} \multimap {#2}}
\newcommand{\gvUnFun}[2]{{#1} \to {#2}}
\newcommand{\gvTimes}[2]{{#1} \otimes {#2}}
\newcommand{\gvUnitType}{\key{Unit}}

\newcommand{\gvUnit}{\key{unit}}
\newcommand{\gvLink}[2]{\key{link}~{#1}~{#2}}
\newcommand{\gvLam}[2]{\lambda {#1}.{#2}}
\newcommand{\gvApp}[2]{{#1}~{#2}}
\newcommand{\gvPair}[2]{({#1},{#2})}
\newcommand{\gvLet}[3]{\key{let}~{#1}={#2}~\key{in}~{#3}}
\newcommand{\gvSend}[2]{\key{send}~{#1}~{#2}}
\newcommand{\gvReceive}[1]{\key{receive}~{#1}}
\newcommand{\gvSelect}[2]{\key{select}~{#1}~{#2}}
\newcommand{\gvCase}[2]{\key{case}~{#1}~\key{of}~{#2}}
\newcommand{\gvWith}[3]{\key{with}~{#1}~\key{connect}~{#2}~\key{to}~{#3}}
\newcommand{\gvTerminate}[1]{\key{terminate}~{#1}}

\newcommand{\gvSendType}[2]{\key{sendType}~{#1}~{#2}}
\newcommand{\gvReceiveType}[1]{\key{receiveType}~{#1}}


\newcommand{\gvServe}[3]{\key{serve}~{#1}({#2})={#3}}
\newcommand{\gvRequest}[1]{\key{request}~{#1}}

\newcommand{\cpLink}[2]{{#1} \leftrightarrow {#2}}
\newcommand{\cpCut}[3]{\nu {#1}.({#2} \mid {#3})}
\newcommand{\cpOutput}[4]{{#1}[{#2}].({#3} \mid {#4})}
\newcommand{\cpInput}[3]{{#1}({#2}).{#3}}
\newcommand{\cpInject}[3]{{#1}[{#2}].{#3}}
\newcommand{\cpCase}[2]{{#1}.\key{case}~{#2}}
\newcommand{\cpServe}[3]{!{#1}({#2}).{#3}}
\newcommand{\cpRequest}[3]{?{#1}[{#2}].{#3}}
\newcommand{\cpEmptyOut}[1]{{#1}[].0}
\newcommand{\cpEmptyIn}[2]{{#1}().{#2}}
\newcommand{\cpSendType}[3]{{#1}[{#2}].{#3}}
\newcommand{\cpReceiveType}[3]{{#1}({#2}).{#3}}


\newcommand{\cpTimes}[2]{{#1} \otimes {#2}}
\newcommand{\cpPar}[2]{{#1} \mathbin{\bindnasrepma} {#2}}
\newcommand{\cpPlus}[2]{\oplus \row{#1}{#2}}
\newcommand{\cpWith}[2]{\binampersand \row{#1}{#2}}
\newcommand{\cpOne}{1}
\newcommand{\cpBottom}{\bot}
\newcommand{\cpOfCourse}[1]{!{#1}}
\newcommand{\cpWhyNot}[1]{?{#1}}
\newcommand{\cpDual}[1]{{#1}^\bot}
\newcommand{\cpExists}[2]{\exists {#1}.{#2}}
\newcommand{\cpForall}[2]{\forall {#1}.{#2}}

\newcommand{\cpZero}{0}    % 0   == +{}
\newcommand{\cpTop}{\top}  % top == &{}


\newcommand{\FV}[1]{\mathit{FV}(#1)}

\newcommand{\gvtocps}[1]{\gvtocp{#1}}
\newcommand{\gvtocpd}[1]{\gvtocp{#1}}

\newcommand{\cpMix}[2]{({#1} \mid {#2})}
\newcommand{\cpCutOutput}[5]{{#2}[{#3}].\nu{#1}.\cpMix{#4}{#5}}

%\makeindex

%% Document
%%
\begin{document}

\title{Sessions as propositions}

% \titlerunning{} has to be set to either the main title or its shorter
% version for the running heads. When processed by
% EasyChair, this command is mandatory: a document without \titlerunning
% will be rejected by EasyChair

\titlerunning{Sessions as propositions}

% Authors are joined by \and. Their affiliations are given by \inst, which indexes
% into the list defined using \institute
%
\author{
  Sam Lindley
  \and
  J. Garrett Morris
}
%% \author{
%% Serguei A. Mokhov\inst{1}\thanks{Designed and implemented the class style}
%% \and
%%     Geoff Sutcliffe\inst{2}\thanks{Did numerous tests and provided a lot of suggestions}
%% \and
%%    Andrei Voronkov\inst{3}\thanks{Masterminded EasyChair and created versions
%%      3.0--3.1 of the class style}\\
%% \and
%%    Graham Gough\inst{3}\thanks{Changed author list format.}\\
%% }


% Institutes for affiliations are also joined by \and,
\institute{The University of Edinburgh \\
           \email{Sam.Lindley@ed.ac.uk, Garrett.Morris@ed.ac.uk}
}
%% \institute{
%%   Concordia University,
%%   Montreal, Quebec, Canada\\
%%   \email{mokhov@cse.concordia.ca}
%% \and
%%    University of Miami,
%%    Miami, Florida, U.S.A.\\
%%    \email{geoff@cs.miami.edu}\\
%% \and
%%    University of Manchester,
%%    Manchester, U.K.\\
%%    \email{andrei@voronkov.com, graham@cs.man.ac.uk}\\
%%  }
%  \authorrunning{} has to be set for the shorter version of the authors' names;
% otherwise a warning will be rendered in the running heads. When processed by
% EasyChair, this command is mandatory: a document without \authorrunning
% will be rejected by EasyChair

\authorrunning{Lindley and Morris}


\clearpage

\maketitle





%% Extend GV
%% Define CP --> GV (direct)
%% Compose GV --> CP --> GV-Pi (CPS)
%% Obtain simplified GV --> GV-Pi (direct)
%% Factor GV --> CP (CPS) as GV --> GV-Pi (direct) followed by GV-Pi -->
%% CP (CPS)






%% Background:

%%   Propositions (in classical linear logic) as sessions.
%%   Channel-passing translation of GV into CP.

%% Our contributions:

%%   Translation of CP to GV+.
  



\begin{abstract}
TODO
\end{abstract}


%\section{To mention}
%
%Processing in EasyChair - number of pages.
%
%Examples of how EasyChair processes papers. Caveats (replacement of EC
%class, errors).

% \pagestyle{empty}


\section{Introduction}
TODO

\section{From CP to GV}
~

Types
\begin{equations}
\cptogv{\cpTimes{A}{B}} &=& \gvOutput{\gvDual{\cptogv{A}}}{\cptogv{B}} \\
\cptogv{\cpPar{A}{B}} &=& \gvInput{\cptogv{A}}{\cptogv{B}} \\
\cptogv{\cpPlus{\la_i:A_i}{i}} &=& \gvPlus{\la_i:\cptogv{A_i}}{i} \\
\cptogv{\cpWith{\la_i:A_i}{i}} &=& \gvChoice{\la_i:\cptogv{A_i}}{i} \\
\cptogv{\cpOne} &=& \gvEndOutput \\
\cptogv{\cpBottom} &=& \gvEndInput \\[1ex]

\cptogv{X} &=& X \\
\cptogv{\cpExists{X}{A}} &=& \gvOutputType{X}{\cptogv{A}} \\
\cptogv{\cpForall{X}{A}} &=& \gvInputType{X}{\cptogv{A}} \\[1ex]

\cptogv{\cpOfCourse{A}} &=& \gvServer{\cptogv{A}} \\
\cptogv{\cpWhyNot{A}} &=& \gvService{\cptogv{A}} \\
\end{equations}

Terms
\begin{equations}
\cptogv{\cpCut{x}{P}{Q}} &=&
  \gvWith{x}{\cptogv{P}}{\cptogv{Q}} \\
\cptogv{\cpOutput{x}{y}{P}{Q}} &=&
  \gvWith{y}{\cptogv{P}}{\gvLet{x}{\gvSend{y}{x}}{\cptogv{Q}}} \\
\cptogv{\cpInput{x}{y}{P}} &=&
  \gvLet{\gvPair{y}{x}}{\gvReceive{x}}{\cptogv{P}} \\
\cptogv{\cpInject{x}{\la}{P}} &=&
  \gvLet{x}{\gvSelect{\la}{x}}{\cptogv{P}} \\  
\cptogv{\cpCase{x}{\row{\la_i.P_i}{i}}} &=&
  \gvCase{x}{\row{\la_i(x).\cptogv{P_i}}{i}} \\
\cptogv{\cpEmptyOut{x}} &=& x \\
\cptogv{\cpEmptyIn{x}{P}} &=&
  \gvLet{z}{\gvTerminate{x}}{\cptogv{P}} \\[1ex]

\cptogv{\cpSendType{x}{A}{P}} &=&
  \gvLet{x}{\gvSendType{\cptogv{A}}{x}}{\cptogv{P}} \\
\cptogv{\cpReceiveType{x}{X}{P}} &=&
  \gvLet{x}{\gvReceiveType{x}}{\cptogv{P}} \\[1ex]

\cptogv{\cpLink{x}{y}} &=& \gvLink{x}{y} \\
\cptogv{\cpServe{s}{x}{P}} &=&
  \gvServe{s}{x}{\cptogv{P}} \\
\cptogv{\cpRequest{s}{x}{P}} &=&
  \gvWith{x}{\gvLink{(\gvRequest{s})}{x}}{\cptogv{P}} \\
\end{equations}

Judgements
\begin{equations}
\cptogv{\cpj{P}{\G}} = \gvj{\cptogv{\G}}{\cptogv{P}}{\gvEndOutput}
\end{equations}

\subsection{GV extensions}

\begin{mathpar}
\inferrule
{\gvj{\Phi}{M}{\gvInputType{X}{S}}}
{\gvj{\Phi}{\gvSendType{S}{M}}{S'[S/X]}}

\inferrule
{\gvj{\Phi}{M}{\gvOutputType{X}{S}} \\ X \notin \FV{\Phi}}
{\gvj{\Phi}{\gvReceiveType M}{S'}}
\end{mathpar}

\begin{mathpar}
\inferrule
{\gvj{\Phi}{M}{S} \\ \gvj{\Phi}{N}{\gvDual{S}}}
{\gvj{\Phi}{\gvLink{M}{N}}{\gvEndOutput}}

\inferrule
{\gvj{\Phi, s : \gvServer{S}, x : S}{M}{\gvEndOutput}}
{\gvj{\Phi}{\gvServe{s}{x}{M}}{\gvEndOutput}}

\inferrule
{ }
{\gvj{\Phi, s : \gvService{S}}{\gvRequest{s}}{S}}
\end{mathpar}


\section{From GV to CP}
~

Session types
\begin{equations}
\gvtocp{\gvOutput{T}{S}}        &=& \cpPar{\cpDual{\gvtocp{T}}}{\gvtocp{S}} \\
\gvtocp{\gvInput{T}{S}}         &=& \cpTimes{\gvtocp{T}}{\gvtocp{S}} \\
\gvtocp{\gvPlus{\la_i:S_i}{i}}   &=& \cpWith{\la_i:\gvtocp{S_i}}{i} \\
\gvtocp{\gvChoice{\la_i:S_i}{i}} &=& \cpPlus{\la_i:\gvtocp{S_i}}{i} \\
\gvtocp{\gvEndOutput}              &=& \cpBottom \\
\gvtocp{\gvEndInput}               &=& \cpOne \\[1ex]

\gvtocp{X}                       &=& X \\
\gvtocp{\gvOutputType{X}{S}}     &=& \cpForall{X}{\gvtocp{S}} \\
\gvtocp{\gvInputType{X}{S}}      &=& \cpExists{X}{\gvtocp{S}} \\[1ex]

\gvtocp{\gvServer{S}}  &=& \cpWhyNot{\gvtocp{S}} \\
\gvtocp{\gvService{S}} &=& \cpOfCourse{\gvtocp{S}} \\[1ex]
\end{equations}

Non-session types
\begin{equations}
\gvtocp{\gvLinFun{T}{U}} &=& \cpPar{\cpDual{\gvtocp{T}}}{\gvtocp{U}} \\
\gvtocp{\gvUnFun{T}{U}} &=& \cpOfCourse{(\cpPar{\cpDual{\gvtocp{T}}}{\gvtocp{U}})} \\
\gvtocp{\gvTimes{T}{U}} &=& \cpTimes{\gvtocp{T}}{\gvtocp{U}} \\
\gvtocp{\gvUnitType} &=& \cpOfCourse{(\cpWith{}{})} \\
\end{equations}

Terms
\begin{equations}
\gvtocp{\gvSendType{S}{(M : \cpForall{X}{S'})}}z &=&
  \cpCut{(x:\cpExists{X}{\cpDual{\gvtocp{S'}}})}{\cpSendType{x}{\gvtocp{S}}{\cpLink{x}{z}}}{\gvtocp{M}x} \\
\gvtocp{\gvReceiveType{(M : \cpExists{X}{S'})}}z &=&
  \cpCut{(x:\cpForall{X}{\cpDual{\gvtocp{S'}}})}{\cpReceiveType{x}{X}{\cpLink{x}{z}}}{\gvtocp{M}x} \\
\\[1ex]
\gvtocp{\gvLink{M}{N}}z &=& \cpCut{x}{\gvtocp{M}x}{\cpCut{y}{\gvtocp{N}y}{\cpEmptyIn{z}{\cpLink{x}{y}}}} \\
\gvtocp{\gvServe{s}{x}{M}}z &=&
  \cpEmptyIn{z}
            {\cpServe{s}{x}
                     {\cpCut{y}{\cpEmptyOut{y}}{\gvtocp{M}y}}} \\
\gvtocp{\gvRequest{s}}z &=& \cpRequest{s}{x}{\cpLink{x}{z}} \\
\end{equations}

Judgements
\begin{equations}
\gvtocp{\gvj{\Phi}{M}{T}} &=& \cpj{\gvtocp{M}z}{\cpDual{\gvtocp{\Phi}}, z:\gvtocp{T}}
\end{equations}


Theorem:

  [[((A))]] = ~A
  [[((P |- G))]] = Q |- G, z : bot
    where nu z.(z[].0|Q) --> P

  (([[S]])) = ~S
  (([[Phi |- M : S]] z)) = Phi |- N : end!
    where
      nu w.(w[].0|[[N]]w) --> [[M]]z
  

\section{Alternative translations from GV to CP}

\subsection{Dualising the interpretation of judgements}

It is possible to avoid the dualisation of session types in the type
translation by dualising the interpretation of judgements.

Judgements
\begin{equations}
\gvtocps{\gvj{\Phi}{M}{T}} &=& \cpj{\gvtocp{M} z}{\gvtocps{\Phi}, z:\cpDual{(\gvtocps{T})}}
\end{equations}

Session types
\begin{equations}
\gvtocps{\gvOutput{T}{S}}        &=& \cpTimes{\cpDual{\gvtocps{T}}}{\gvtocps{S}} \\
\gvtocps{\gvInput{T}{S}}         &=& \cpPar{\gvtocps{T}}{\gvtocps{S}} \\
\gvtocps{\gvPlus{\la_i:S_i}{i}}   &=& \cpPlus{\la_i:\gvtocps{S_i}}{i} \\
\gvtocps{\gvChoice{\la_i:S_i}{i}} &=& \cpWith{\la_i:\gvtocps{S_i}}{i} \\
\gvtocps{\gvEndOutput}              &=& \cpOne \\
\gvtocps{\gvEndInput}               &=& \cpBottom \\[1ex]

\gvtocps{\gvServer{S}}  &=& \cpOfCourse{\gvtocps{S}} \\
\gvtocps{\gvService{S}} &=& \cpWhyNot{\gvtocps{S}} \\[1ex]
\end{equations}


The idea is that the term translation stays exactly the same. This
approach fits with the view of $z$ as a negative continuation
parameter. It yields a straightforward interpretation of session
types, but then the interpretation of non-session types (linear
functions, unrestricted functions, tensor, and unit), becomes dual to
what one would normally expect.

Non-session types
\begin{equations}
\gvtocps{\gvLinFun{T}{U}} &=& \cpTimes{\gvtocp{T}}{\cpDual{\gvtocp{U}}} \\
\gvtocps{\gvUnFun{T}{U}} &=& \cpWhyNot{(\cpTimes{\gvtocp{T}}{\cpDual{\gvtocp{U}}})} \\
\gvtocps{\gvTimes{T}{U}} &=& \cpPar{\cpDual{\gvtocp{T}}}{\cpDual{\gvtocp{U}}} \\
\gvtocps{\gvUnitType} &=& \cpWhyNot{(\cpPlus{}{})} \\
\end{equations}

\subsection{Adapting the translation on terms}

As an alternative to dualising the interpretation of non-session
types, we can attempt to keep the standard interpretation of
non-session types and instead adapt the translation on terms.

Judgements
\begin{equations}
\gvtocpd{\gvj{\Phi}{M}{T}} &=& \cpj{\gvtocpd{M} z}{\gvtocpd{\Phi}, z:{\gvtocpd{T}}}
\end{equations}

This looks like it might work if we add the Mix rule to CP along with
another rule which can be derived from BiCut, but which appears to
be weaker.

\begin{mathpar}
\inferrule
{\cpj{P}{\G, y:A, z:C} \\ \cpj{Q}{\D, x:B, z:\cpDual{C}}}
{\cpj{\cpCutOutput{z}{x}{y}{P}{Q}}{\G, \D, x : \cpTimes{A}{B}}}
\end{mathpar}

%%   [[
%%   Phi |- L : T -o U  un(Phi)
%%   --------------------------
%%   Phi |- L : T -> U
%%   ]] z
%% =
%%   [[L]]y |- [[Phi]], y:~[[T -o U]]
%%   --------------------------------------------
%%   ?z[y].[[L]]y |- [[Phi]], z:?(~[[T -o U]])

%%   [[
%%   Phi |- L : T -> U
%%   -----------------
%%   Phi |- L : T -o U
%%   ]] z
%% =
%%                                            x <-> z |- x:[[T -o U]], z:~([[T -o U]])
%%                                         ---------------------------------------------------
%%   [[L]]y |- [[Phi]], y:?(~[[T -o U]])   !y(x).x <-> z |- y:!([[T -o U]]), z:~([[T -o U]])
%%   ------------------------------------------------------------------------------------------
%%   nu y.([[L]]y | !y(x).x <-> z) |- [[Phi]], z:~[[T -o U]]
%%
%% Oops! z can't appear inside the server output!


%% z : [[T]] * ~[[U]]
%% [[\x.M]]z = nu y.z[x].([[M]]y | y <-> z)
%% [[\x.M]]z = nu y x.([[M]]y | z[w].(w <-> x | y <-> z))

%% z : ~[[U]]
%% [[L M]]z = nu y.([[L]]y | y(x).([[M]]x | y <-> z))

%% z : ~[[T]] || ~[[U]]
%% [[(M, N)]]z = z(x).([[M]]x | [[N]]z)

%% z : ~[[V]]
%% [[let (x,y)=M in N]]z = nu w.([[M]]w | nu y.w[x].([[N]]z | w <-> y))

%% Cutting an output with a private channel against an input with a
%% mix would appear to yield a term containing a plain bicut and a mix

%%    nu x.(x[y].nu z.(P | Q) | x(y).(R | S))
%%  -->
%%    nu y z.(P | nu x.(Q | (R | S)))


Non-session terms
\begin{equations}
\gvtocpd{\lambda x:T.M}z &=&
  \cpCutOutput{y:{\cpDual{\gvtocpd{U}}}}{z}{x:{\gvtocpd{T}}}
              {\gvtocpd{M}y}{\cpLink{y}{z}} \\
\gvtocpd{L~M}z &=&
  \cpCut{y:\cpTimes{\gvtocpd{T}}{\cpDual{\gvtocpd{U}}}}
        {\gvtocpd{L}y}
        {\cpInput{y}{x:\cpDual{\gvtocpd{U}}}{\cpMix{\gvtocpd{M}x}{\cpLink{y}{z}}}} \\
\gvtocpd{\gvPair{M}{N}}z &=&
  \cpInput{z}{x:\cpDual{\gvtocpd{T}}}{\cpMix{\gvtocpd{M}x}{\gvtocpd{N}z}} \\
\gvtocpd{\gvLet{\gvPair{x}{y}}{M}{N}}z &=&
  \cpCut{w:\cpPar{\cpDual{\gvtocpd{T}}}{\cpDual{\gvtocpd{U}}}}
    {\gvtocpd{M}w}
    {\cpCutOutput{y:\gvtocpd{U}}{w}{x:\gvtocpd{T}}{\gvtocpd{N}z}{\cpLink{w}{y}}} \\
\end{equations}

Where this approach seems to completely break down is in the
translation of the elimination rule for unrestricted functions. We
might reasonably hope to simulate linear lambdas using output rather
than input, but it seems unreasonable to expect to simulate
unrestricted lambda application using a linear server rather than an
unrestricted client.

\subsection{Compiling away non-session types}

Another option is to compile away non-session types in GV as a
pre-processing step, where the type translation is given by
$\cptogv{\gvtocp{-}}$ and the term translation by
$\cptogv{\gvtocp{-}z}$.

%% T -o U --> ~[[T]] || [[U]] --> ?~T*.U*
%% T -> U --> !(~[[T]] || [[U]]) --> $(?~T*.U*)
%% T * U --> [[T]] * [[U]] --> !~T*.U*
%% Unit --> !&{} --> $&{}

%% Hmmm... Looks like things are the wrong way round in the GV to CP
%% translation: input types should be negated and output types
%% should't.

We could simply compose the translations as described, but then it
would seem that we would have to perform a global CPS transformation
on all terms including the session typing constructs. This would be
rather disappointing, as then we would appear to have to effectively
perform a CPS transformation twice on such terms in order to generate
a CP term.

% channel passing translation
\newcommand{\gvtogv}[1]{({#1})^\star}

We can do better, though, by performing a local transformation. The
key observation is that we can locally abstract over the continuation
channel $z$ in a term $M$ using $\gvWith{z}{M}{z}$.

This is where the dualisation of types arises: the type of the whole
expression must be dual to the type of $z$ in $M$. For instance, we
implement a lambda of type $\gvLinFun{T}{U}$ with a channel $z$ of
type $\gvInput{\gvDual{\gvtogv{T}}}{\gvtogv{U}}$, but the interface to
the lambda is the other end of the channel $z$ which has type
$\gvOutput{\gvtogv{T}}{\gvDual{\gvtogv{U}}}$ (and application becomes
simply sending the argument along this channel).

\begin{equations}
\gvtogv{\gvLinFun{T}{U}} &=& \gvOutput{\gvtogv{T}}{\gvDual{\gvtogv{U}}} \\
\gvtogv{\gvUnFun{T}{U}} &=& \gvService{(\gvOutput{\gvtogv{T}}{\gvDual{\gvtogv{U}}})} \\
\gvtogv{\gvTimes{T}{U}} &=& \gvInput{\gvtogv{T}}{\gvDual{\gvtogv{U}}} \\
\gvtogv{\gvUnitType} &=& \gvService{(\gvPlus{}{})} \\
\end{equations}%

\begin{equations}
\gvtogv{\gvj{\Phi}{M}{T}} &=& \gvj{\gvtogv{\Phi}}{\gvtogv{M}}{\gvtogv{T}} \\
\end{equations}%

\begin{equations}
\gvtogv{\gvLam{x}{M}} &=& \gvWith{z}{\gvLet{\gvPair{x}{z}}{\gvReceive{z}}{\gvLink{\gvtogv{M}}{z}}}{z} \\
\gvtogv{\gvApp{L}{M}} &=& \gvSend{\gvtogv{M}}{\gvtogv{L}} \\
\gvtogv{\gvTimes{M}{N}} &=&
  \gvWith{z}
    {\gvLink{(\gvSend{\gvtogv{M}}{z})}{\gvtogv{N}}}
    {z} \\
\gvtogv{\gvLet{\gvPair{x}{y}}{M}{N}} &=&
    \gvLet{\gvPair{x}{y}}{\gvReceive{\gvtogv{M}}}{\gvtogv{N}} \\
\gvtogv{\gvReceive{M}} &=& M \\
\gvtogv{\gvUnit} &=&
    \gvWith{z}
    {\gvServe{z}{x}{\gvCase{x}{\row{}{}}}}
    {z} \\
%% Unnecessary as we don't have a linear unit!
%%
%% \gvtogv{\gvLet{\gvUnit}{M}{N}} &=&
%%   \gvLet{z}{\gvtogv{M}}{\gvtogv{N}} \\
\gvtogv{L : \gvUnFun{T}{U}} &=&
  \gvWith{z}{\gvServe{z}{y}{\gvLink{\gvtogv{L}}{y}}}{z} \\
\gvtogv{L : \gvLinFun{T}{U}} &=& \gvRequest{\gvtogv{L}} \\
\end{equations}

A problem we run into is that $\gvReceive{M}$ has tensor type, and yet
our translation is supposed to compile away non-session types,
including tensors. Similarly, $\gvTerminate{M}$ has unit type. The
problem illustrates an irregularity in GV. All of the typing rules for
the other session typing constructs mention only session types.

Dealing with $\key{terminate}$ is easy. We just amend our target
language such that $\gvTerminate{M}$ has type
$\gvService{(\gvPlus{}{})}$, the interpretation of the unit type.
%
Dealing with $\key{receive}$ is a little harder. We still need some
way of binding the two values returned by $\key{receive}$. The
solution is to fuse $\key{receive}$ with the pair elimination
construct. Notice that this is more or less what CP server input does
already. Because we interpret $\gvTimes{T}{U}$ as
$\gvInput{\gvtogv{T}}{\gvDual{\gvtogv{U}}}$, instances of
$\key{receive}$ from the source term are all erased. The only
instances of $\key{receive}$ in the target term arise from
interpreting lambdas and pair elimination. This may seem strange until
one considers that the only way to use the pair resulting from a
$\key{receive}$ in GV is to eliminate it. The transformation shunts
each receive up to the point at which the resulting pair is
eliminated.

\begin{mathpar}
\inferrule
  {\gvj{\Phi}{M}{\gvEndInput}}
  {\gvj{\Phi}{\gvTerminate{M}}{\gvService{(\gvPlus{}{})}}}

\inferrule
  {\gvj{\Phi}{M}{\gvInput{T}{S}} \\ \gvj{\Psi, x:T, y:S}{N}{U}}
  {\gvj{\Phi, \Psi}{\gvLet{\gvPair{x}{y}}{\gvReceive{M}}{N}}{U}}
\end{mathpar}

Another alternative is to get rid of terminate altogether and change
$\gvEndInput$ to be an unrestricted session type. Correspondingly, we
could also interpret the unit type as $\gvEndInput$ and $\gvUnit$ as
$\gvWith{x}{x}{x}$. Making $\gvEndInput$ unrestricted makes sense as
$\gvEndInput = \cptogv{\cpBottom}$, and weakening and contraction are
derivable for $\cpBottom$ in CP.

\newpage
\section{Conclusion}

TODO

\cite{wadler2014jfp}

\label{sect:bib}
\bibliographystyle{plain}
%\bibliographystyle{alpha}
%\bibliographystyle{unsrt}
%\bibliographystyle{abbrv}
\bibliography{cpgv}

%------------------------------------------------------------------------------
%% \appendix

%------------------------------------------------------------------------------
% Index
%\printindex

%------------------------------------------------------------------------------
\end{document}

Composing the translations

(([[T -o U]])) = ?~(([[T]])).(([[U]]))
(([[T * U]])) = !(([[T]])).(([[U]]))




\x.M --> ((z(x).[[M]]z))  --> let (x,z)=receive z in (([[M]]z))
[[L M]]z --> nu y.([[L]]y | y[x].([[M]]x | y <-> z)) -->
       with y connect
         (([[L]]y))
       to
         with x connect
           (([[M]]x))
         to
           let y=send x y in link y z
(M,N) --> z[y].([[M]]y | [[N]]z) --> with y connect (([[M]]y)) to let z = send y z in (([[N]]z))
let (x, y) = M in N
   --> nu y.([[M]]y | y(x).[[N]]z)
   --> with y connect
         (([[M]]y))
       to
         let (x, y) = receive y in (([[N]]z))

Phi |- L : T -o U  un(Phi)
--------------------------
Phi |- L : T -> U
  --> !z(y).[[L]]y
  --> serve z(y) = (([[L]]y))

Phi |- L : T -> U
-----------------
Phi |- L : T -o U
  --> nu y.([[L]]y | ?y[x].x <-> z)
  --> with y connect
        (([[L]]z))
      to
        with x connect link (request y) x to link x z
  ==
     with y connect
       (([[L]]z))
     to
       link (request y) z

A problem is that we appear to have to CPS transform everything
globally - including the session typing constructs. For instance:

send M N --> nu x.(x[y].([[M]]y | x <-> z) | [[N]]x)
         --> with x connect
               with y connect
                 (([[M]]y))
               to
                 let x = send y x in link x z
             to
               (([[N]]))x

send (\v.v) w -->
    with x connect
      with y connect
        let (v,y) = receive y in link v y
      to
        let x = send y x in link x z
    to
      link w x
  ==
    with y connect
      let (v,y) = receive y in link v y
    to
      let w = send y w in link w z

If we do this as a pre-processing step, then we effectively end up
doing a CPS transformation twice! Can we do some kind of local CPS
transformation:

send (\v.v) w -->
    with y connect
      let (v,y) = receive y in link v y
    to
      send y w
  ==
    send
      (with y connect
        let (v,y) = receive y in link v y
       to
         y)
    w


let syntactic sugar after translating away lambdas:

  let x = M in N
  ==
  send M (with z connect let (x,z)=receive z in link N z to z)

  

Attempting to undualise the GV to CP translation on types

[[T -o U]] = [[~T || U]]

z : [[T]] * ~[[U]]
[[\x.N]]z = nu y:[[U]].z[x].([[N]]y|y <-> z)



P |- x : A, y : B
----------------------------------------------------
y[x].(P | nu r s.(r <-> x | s <-> y))) |- y : A * B


P |- x : A, x : C     Q |- x : ~C, y : B
----------------------------------------
     nu x.y[z].(P | Q) |- y : A * B

z : ~[[U]]
[[L M]]z = nu y.([[L]]y | y(x).([[M]]x | y <-> z))



y(x).x().y <->z  |- y : bot || 1, z:bot

y(x).y <->z  |- y : 1 || 1, z:bot


[[L]]y |- [[Phi]],y:[[T]]*~[[U]]   ? |- [[Psi]],y:~[[T]] || [[U]],z:~[[U]]
--------------------------------------------------------------------------
? |- [[Phi]],[[Psi]],z:~[[U]]



P |- G,x:~A

? |- G,x:~A,y:B,z:~B
----------------------------------
y(x).? |- y:~A || B,z:~B

z : ~[[T]] || ~[[U]]
[[(M, N)]]z = z(x).([[M]]x || [[N]]z)


x(y).x(z).x().y <-> z |- x:1||(bot || bot)



nu y1 : !top * !top . (foo <-> y1 |  y1(x2).!z0(y3).y3.case(){}) |- foo : ~(!top * !top),z0:!top


  foo : ?#+{}.#+{}, z0 : $&{}
|-
  with y1 : !#+{}.$&{}
  connect
    link foo y1
  to
    let (x2, y1)=receive y1 in serve z0 (y3)=case y3 of {}
: end!


((!top*!top)) = !~((!top)).((!top)) = !#+{}.$&{}

foo : ?#+{}.#+{}, z0 : $&{} |- with y1 : !#+{}.$&{} connect link foo y1 to let (x2, y1)=receive y1 in serve z0 (y3)=case y3 of {} : end!

New version of terminate:

[[terminate M]](z : !top) = nu (x:1).([[M]]x|x().!z(y).y.case())

Let unit:

[[ let () = m in n ]]z = [[ (\().n)m ]] z
  = nu y.(y(x).[[n]]y | y[x].([[m]]x | y <-> z))
  = nu x.(nu y.([[n]]y | y <-> z) | [[m]]x)
  = nu x.([[m]]x | [[n]]z)

Rules for sendType and receiveType

G |- M : ??X.S'
---------------------------
G |- sendType S M : S'[S/X]

G |- M : !!X.S'   X notin FV(G)
-------------------------------
G |- receiveType M : S'

[[sendType S M]](z : S'[S/X]) = nu (x:exists X.[[S']]).(x[S].x <-> z | [[M]]x)
[[receiveType M]](z : S')     = nu.(x:forall X.[[S']]).(x(X).x <-> z | [[M]]x)
