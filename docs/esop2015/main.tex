 % -*- fill-column: 100 -*-

\documentclass[orivec,envcountsame]{llncs}

\usepackage{amsmath,amssymb,centernot,hyperref,mathwidth,stmaryrd,url,xspace}
\usepackage[table]{xcolor}
\usepackage{colortbl}
\addtolength{\jot}{-3px}

\usepackage{mathpartir}
\mprset{sep=1em}

\usepackage{float}
\floatstyle{boxed}
\restylefloat{figure}

\input{preamble.tex}

\title{Joke or Something}
\author{J. Garrett Morris \and Sam Lindley \and Philip Wadler}
\institute{The University of Edinburgh \\
           \email{\{Garrett.Morris,Sam.Lindley,Philip.Wadler\}@ed.ac.uk} \vspace{-5mm}}

\begin{document}

\maketitle

\begin{abstract}

\end{abstract}

\section{Introduction}\label{sec:intro}

\section{GV by Example}\label{sec:examples}

\subsection{Books and Stores Therefore}

\begin{itemize}
\item Explain encoding of select and choice into send and receive with sums.
\end{itemize}

\todo{This ended up being a bit long.  There are a couple of points that it makes tho:
  \begin{itemize}
  \item Transmission of channels (sending client channel to bank).
  \item Sending structured values along channels.
  \end{itemize}
  And it has a motivation.  However, I'm not sure that either of these is important enough to
  justify the length.  We could, for example, do the calculator with structured values and not take
  nearly as much space.}

\begin{code}
Client \defeq \lambda c.
  \bl
  \gvlet{c}{\gvsend{(\text{``A Tale of Two Cities"}, c)}}{} \\
  \gvlet{(price,c)}{\gvreceive{c}}{} \\
  \mkwd{if}\ price \leq 20\ \mkwd{then} \\
  \quad\bl
    \gvlet{c}{\gvselect{purchase}{c}}{}\\
    \gvlet{c}{\gvsend{((ccName, ccNumber), c)}}{} \\
    \mkwd{offer}\,c \\
    \quad \bl
      accept\,c \mapsto \gvconst{wait} \app c; \gvconst{print} \app \text{``:)"} \\
      decline\,c \mapsto \gvconst{wait} \app c; \gvconst{print} \app \text{``:("} \\
      challenge\,c \mapsto \\
      \quad \bl
        \gvlet{c}{\gvsend{(response, c)}}{} \\
        \mkwd{offer}\,c \\
        \quad \bl
          accept\,c \mapsto \gvconst{wait} \app c; \gvconst{print} \app \text{``:)"} \\
          decline\,c \mapsto \gvconst{wait} \app c; \gvconst{print} \app \text{``:("}
        \el
      \el
    \el
  \el \\
  \mkwd{else} \\
  \quad \bl
    \gvlet{c}{\gvselect{stop}{c}}{} \\
    \gvconst{wait} \app c
    \el
  \el
\end{code}

\begin{code}
Store \defeq \lambda b. \lambda c. \bl
  \gvlet{(product, c)}{\gvreceive{c}}{} \\
  \gvlet{c}{\gvsend{(price(product), c)}}{} \\
  \mkwd{offer}\,c\,\{ \\
  \quad \bl
    purchase\,c \mapsto \\
    \quad \bl
      \gvlet{((ccName, ccNumber), c)}{\gvreceive{c}}{} \\
      \gvlet{b}{\gvsend{((ccName, ccNumber, price(product), c), b)}}{} \\
      \mkwd{offer}\,b \\
      \quad \bl
        accept\,b \mapsto
          \gvlet{(c,b)}{\gvreceive{b}}{\gvconst{wait} \app b; \dots; c} \\
        reject\,b \mapsto
          \gvlet{(c,b)}{\gvreceive{b}}{\gvconst{wait} \app b; c}
      \el
    \el \\
    stop\,c \mapsto c \}
  \el
\el\end{code}

\begin{code}
Bank \defeq \lambda b. \bl
  \gvlet{((ccName, ccNumber, amount, c), b)}{\gvreceive{b}}{} \\
  \mkwd{if}\ suspicious(ccNumber, amount)\ \mkwd{then} \\
  \quad\bl
    \gvlet{c}{\gvselect{challenge}{c}}{} \\
    \gvlet{(response, c)}{\gvreceive{c}}{} \\
    \mkwd{if}\ passes(response)\ \mkwd{then} \\
    \quad \bl
      \gvlet{c}{\gvselect{accept}{c}}{} \\
      \gvlet{b}{\gvselect{accept}{b}}{} \\
      \gvlet{b}{\gvsend{(c,b)}}{} \\
      \dots; c \el \\
    \mkwd{else} \\
    \quad \bl
      \gvlet{c}{\gvselect{reject}{c}}{} \\
      \gvlet{b}{\gvselect{reject}{b}}{} \\
      \gvlet{b}{\gvsend{(c,b)}}{} \\
      c \el
  \el
\el
\end{code}

\begin{code}
System \defeq \bl
  \gvlet{bank}{\gvconst{fork} \app Bank}{} \\
  \gvlet{store}{\gvconst{fork} \app (Store \app bank)}{} \\
  Client \app store
\el
\end{code}

\section{I'm Pickin' Up Good Vibrations}

I'm intentionally ignoring replication for the time being.  I'm intentionally ignoring CP
polymorphism forever.

\subsection{Syntax}
\newcommand{\one}{\mathbf{1}}
\newcommand{\zero}{\mathbf{0}}
\begin{syntax}
  \text{Session types} & S & ::= & \gvout{T}{S} \mid \gvin{T}{S} \mid % \oplus \{ \overline{l:S} \} \mid \with \{ \overline{l:S} \} \mid
                                   \interm \mid \outterm \mid \channel{S} \\
  \text{Types} & T,U & ::= & S \mid T \times U \mid \one \mid T + U \mid \zero \mid T \lto U \\ % \mid {!T} \\
  \text{Terms} & M,N & ::= & x \mid K \mid \lambda x.M \mid M\,N \\
  & & \mid & (M,N) \mid \gvlet{(x,y)}{M}{N} \\
  & & \mid & \mkwd{inl}\,M \mid \mkwd{inr}\,M \mid \gvcase{M}{\mkwd{inl}\,x \mapsto N; \mkwd{inr}\,x \mapsto N} \\
  & & \mid & () \mid \gvletunit{M}{N} \mid \gvconst{absurd} \app M \\
  \text{Constants} & K & ::= & \gvconst{send} \mid \gvconst{receive} \mid \gvconst{fork} \mid \gvconst{wait} \mid \gvconst{link}\\
\end{syntax}

\begin{mathpar}
\gvdual{\gvout{T}{S}} = \gvin{T}{\gvdual S}

\gvdual{\gvin{T}{S}} = \gvout{T}{\gvdual S}

\gvdual{\interm} = \outterm

\gvdual{\outterm} = \interm
\end{mathpar}

\subsection{Typing}

\begin{mathpar}
\inferrule
  {T \not= \channel{S}}
  {\{x:T\} \vdash x:T}

\inferrule
  {\Gamma,x:T \vdash M:U}
  {\Gamma \vdash \lambda x.M : T \lto U}

\inferrule
  {\Gamma \vdash M: T \lto U \\
   \Delta \vdash N: T}
  {\Gamma,\Delta \vdash M\,N: U}

\inferrule
  {\Gamma \vdash M: T \\
   \Delta \vdash N: U}
  {\Gamma,\Delta \vdash (M,N): T \times U}

\inferrule
  {\Gamma \vdash M: T \times T' \\
   \Delta,x:T,y:T' \vdash N: U}
  {\Gamma,\Delta \vdash \gvlet{(x,y)}{M}{N} : U}

\inferrule
  {\Gamma \vdash M: T}
  {\Gamma \vdash \mkwd{inl}\,M: T+U}

\inferrule
  {\Gamma \vdash M: T+T' \\
   \Delta,x:T \vdash N: U \\
   \Delta,x:T' \vdash N': U}
  {\Gamma,\Delta \vdash \gvcase{M}{\mkwd{inl}\,x \mapsto N; \mkwd{inr}\,x \mapsto N'} : U}

\inferrule
  { }
  {\vdash (): \one}

\inferrule
  {\Gamma \vdash M: \one \\
   \Delta \vdash N: T}
  {\Gamma,\Delta \vdash \gvletunit{M}{N}: T}

\inferrule
  {\Gamma \vdash M: \zero}
  {\Gamma, \Gamma' \vdash \gvconst{absurd} \app M : T}

\gvconst{send} : T \times \gvout{T}{S} \lto S

\gvconst{receive} : \gvin{T}{S} \lto T \times S

\gvconst{fork} : (S \lto \outterm) \lto \gvdual{S}

\gvconst{wait} : \interm \lto \one

\gvconst{link} : S \times \gvdual{S} \lto \outterm
\end{mathpar}

\subsection{Evaluation}

\newcommand{\distinguish}[1]{\langle #1 \rangle}

\newcommand{\wcirc}{{\mathord{\circ}}}
\newcommand{\bcirc}{{\mathord{\bullet}}}

\begin{syntax}
  \text{Values} & V & ::= & x \mid K \mid \lambda x.M \\ % \mid K\,V \\
  & & \mid & () \mid (V,V') \mid \mkwd{inl}\,V \mid \mkwd{inr}\,V  \\
  \text{Evaluation contexts} & E & ::= &  [] \mid E\,M \mid V\,E \mid \gvletunit{E}{M} \\
  & & \mid & (E,M) \mid (V,E) \mid \gvlet{(x,y)}{E}{M} \\
  & & \mid & \mkwd{inl}\,E \mid \mkwd{inr}\,E \mid \gvcase{E}{\mkwd{inl}\,x \mapsto N; \mkwd{inr}\,x \mapsto N'} \\
  & F & ::= & E \mid \distinguish E \\
  \text{Configurations} & P & ::= & M \mid \distinguish M \mid P \parallel P' \mid (\nu x) P \\
  \text{Configuration contexts} & C & ::= & F \mid C \parallel P \mid (\nu x)C \\
  \text{Flags} & \phi & ::= & \wcirc \mid \bcirc
\end{syntax}
%
\todo{SL: I think that the basis for configuarations contexts should be $[~]$ rather than $F$.}
%
We define combination of flags $\phi + \phi'$ by
\begin{mathpar}
  \wcirc + \wcirc = \wcirc

  \wcirc + \bcirc = \bcirc

  \bcirc + \wcirc = \bcirc
\end{mathpar}
and leave $\bcirc + \bcirc$ undefined.  Configuration typing is given by
\begin{mathpar}
\inferrule
  {\Gamma \vdash M: T}
  {\Gamma \vdash^\bcirc \distinguish M}

\inferrule
  {\Gamma \vdash M: \outterm}
  {\Gamma \vdash^\wcirc M}

\inferrule
  {\Gamma, x:\channel{S} \vdash^\phi P}
  {\Gamma \vdash^\phi (\nu x) P}

\inferrule
  {\Gamma,x:S \vdash^{\phi} P \\
   \Gamma',x:\gvdual{S} \vdash^{\phi'} P'}
  {\Gamma,\Gamma',x:\channel{S} \vdash^{\phi + \phi'} P \parallel P'}
\end{mathpar}
We will write $\Gamma \vdash P$ for $\Gamma \vdash^\bcirc P$.  Note that while we can write the
classic deadlocked configuration
\[
  (\nu x)(\nu y)(\distinguish{\gvlet{(z,x)}{\gvconst{receive} \app x}{\gvconst{send} \app (z,y)}} \parallel
                 \gvlet{(z,y)}{\gvconst{receive} \app y}{\gvconst {send} \app (z,x)})
\]
it is not well typed: we can only split one of $x,y$ at the $\parallel$.  Term reductions:
\begin{align*}
  (\lambda x.M)\,V &\teval M\{V/x\} \\
  \gvletunit{()}{M} &\teval M \\
  \gvlet{(x,y)}{(V,V')}{M} &\teval M\{V/x,V'/y\} \\
  \gvcase{(\mkwd{inl}\,V)}{\mkwd{inl}\,x \mapsto N; \mkwd{inr}\,x \mapsto N'} &\teval N\{V/x\} \\
  E[M] &\teval E[M'] \qquad \text{if $M \teval M'$}
\end{align*}
Configuration (context) equivalence:
\begin{mathpar}
C[\mathsf{link}\,(x,y)] \equiv C[\mathsf{link}\,(y,x)]

C_0 \parallel C_1 \equiv C_1 \parallel C_0

C_0 \parallel (C_1 \parallel C_2) \equiv (C_0 \parallel C_1) \parallel C_2

C_0 \parallel (\nu x)C_1 \equiv (\nu x)(C_0 \parallel C_1) \text{ if $x \not\in \fv(C_0)$}
\end{mathpar}

\todo{SL: I think the structural equivalence should be defined on configurations rather than
  configuration contexts}

\begin{mathpar}
F[\mathsf{link}\,(x,y)] \equiv F[\mathsf{link}\,(y,x)]

P \parallel Q \equiv Q \parallel P

P \parallel (Q \parallel R) \equiv (P \parallel Q) \parallel R

P \parallel (\nu x)Q \equiv (\nu x)(P \parallel Q) \text{ if $x \not\in \fv(P)$}

M \parallel \distinguish{N} \equiv \distinguish{M} \parallel N

\inferrule
  {P \equiv Q}
  {C[P] \equiv C[Q]}
\end{mathpar}

\todo{If we take the transitive, reflexive, symmetric closure of the above rules then that gives us
  a congruence over configurations, but it doesn't correspond to the congruence closure of the
  structural equivalence of CP because it isn't a congruence over the term structure - e.g. link
  equivalence only holds at the top level. Is this OK?}

Awkwardly enough, the equivalence rules do not preserve typing.  For example, supposing that $x \in
\fv(P), y \in \fv(Q), \text{ and } x,y \in \fv(R)$, we have $\vdash (\nu x
y)(P \mid (Q \mid R))$ but not $\nvdash (\nu x y)((P \mid Q) \mid R)$.  We have a simple reduction
rule for configuration types, given by
\begin{mathpar}
\inferrule
%  [T-Output]
  { }
  {\channel{(\gvout T S)} \ceval \channel S}

\inferrule
%  [T-Input]
  { }
  {\channel{(\gvin T S)} \ceval \channel S}

\inferrule
%  [T-Context]
  {T \ceval T'}
  {\Gamma,x:T \ceval \Gamma,x:T'}
\end{mathpar}
We write $\Gamma \ceval^? \Gamma'$ to denote $\Gamma = \Gamma' \lor \Gamma \ceval \Gamma'$.
Configuration reduction is given by
\begin{mathpar}
\inferrule
  [Send]
  { }
  {F[\gvconst{send} \app (V,x)] \parallel F'[\gvconst{receive} \app x] \ceval F[x] \parallel F'[(V,x)]}

\inferrule
  [Fork]
  {\text{$x$ fresh}}
  {F[\gvconst{fork} \app V] \ceval (\nu x)(F[x] \parallel (V\,x))}

\inferrule
  [Wait]
  { }
  {(\nu x)(F[\gvconst{wait} \app x] \parallel x) \ceval F[()]}

\inferrule
   [Link]
   {x \in \fv(M)}
   {(\nu x) (F[\gvconst{link} \app (x, y)] \parallel F'[M]) \ceval (\nu x)(F[x] \parallel F'[\gvletunit{\gvconst{wait} \app x}{M\{y/x\}}])}

\inferrule
   [Lift]
   {P \ceval P'}
   {C[P] \ceval C[P']}

\inferrule
   [Lift2]
   {M \teval M'}
   {C[M] \ceval C[M']}
%%
%% \inferrule
%%    [DLink]
%%    {x \in \fv(M)}
%%    {(\nu x) (C[\mathsf{link}\,(x, y)] \parallel \distinguish M) \ceval (\nu x)(C[x] \parallel \distinguish{\gvletunit{\mathsf{wait}\,x}{M\{y/x\}}})}
%%
%%
%% \inferrule
%%   {C_0 \equiv C_0' \\
%%    C_0' \ceval C_1' \\
%%    C_1' \equiv C_1}
%%   {C_0 \ceval C_1}
\end{mathpar}
Some things that might be useful.
\begin{lemma}\label{thm:term-preservation}
  If $\Gamma \vdash M: T$ and $M \teval M'$, then $\Gamma \vdash M': T$
\end{lemma}

\noindent
The proof is standard.

\begin{theorem}\label{thm:preservation}
  If $\Gamma \vdash P$ and $P \ceval P'$ then there is some $\Gamma'$ such that $\Gamma \ceval^?
  \Gamma'$ and $\Gamma' \vdash P'$.
\end{theorem}

\begin{proof}
  By induction on the derivation of $P \ceval P'$.
  \begin{itemize}
  \item Case \textsc{Lift} is immediate by the induction hypothesis.
  \item Case \textsc{Lift2} follows from \lemref{term-preservation}, with $\Gamma = \Gamma'$.
  \item In case \textsc{Send}, from the assumption $\Gamma \vdash C[\mkwd{send}\,(V,x)] \parallel
    C'[\gvconst{receive} \app x]$, we can assume that $\Gamma$ partitions as
    $\Gamma_1,\Gamma_2,x:\channel{S}$ such that $S = \gvout{T}{S'}$, $V$ has type $T$, and
    $\Gamma_1,x:\gvout{T}{S'} \vdash C[\gvconst{send} \app (V,x)]$,
    $\Gamma_2,x:\gvin{T}{\gvdual{S'}} \vdash C'[\gvconst{receive} \app x]$.  As $\gvconst{send} : T
    \times \gvout{T}{S'} \lto S'$ and $\Gamma_1,x:\gvout{T}{S'} \vdash C[\gvconst{send} \app
    (V,x)]$, we can conclude that $\Gamma_1,x:S' \vdash C[x]$.  By a similar argument, we conclude
    that $\Gamma_2,x:\gvdual{S'} \vdash C'[(V,x)]$. Finally, as $\channel{(\gvout{T}{S})} \ceval
    \channel{S}$, $\Gamma_1,\Gamma_2,x:\channel{(\gvout T S)} \ceval
    \Gamma_1,\Gamma_2,x:\channel{S}$, and we can recompose the resulting processes concluding that
    $\Gamma_1,\Gamma_2,x:\channel{S} \vdash C[x] \parallel C'[(V,x)]$.
  \item In case \textsc{Fork}, from the assumption $\Gamma \vdash C[\gvconst{fork} \app V]$, we can
    conlude that $\Gamma$ splits into $\Gamma_1,\Gamma_2$ and there is some $S$ such that
    $\Gamma_1,x:S \vdash C[x]$ and $\Gamma_2,x:\gvdual{S} \vdash V \app x$.  Thus we have that
    $\Gamma,x:S \vdash C[x] \parallel V \app x$ and $\Gamma \vdash (\nu x)(C[x] \parallel
    V \app x)$.
  \item In case \textsc{Wait}, from the assumption $\Gamma \vdash (\nu x)(C[\gvconst{wait} \app
    x] \parallel x)$, we can conclude that $\Gamma,x:\interm \vdash C[\gvconst{wait} \app x]$ and
    thus, from the typing of \gvconst{wait}, that $\Gamma \vdash C[()]$.
  \item In case \textsc{Link}, from the assumptions $\Gamma \vdash (\nu x) (C[\gvconst{link} \app
    (x, y)] \parallel C'[M]), x \in \fv(M)$, we can conclude that $\Gamma$ partitions as
    $\Gamma_1,\Gamma_2,y:S$ such that $\Gamma_1,y:S,x:\gvdual{S} \vdash C[\gvconst{link} \app (x,
    y)]$ and $\Gamma_2,x:S \vdash C'[M]$.  (Note that the free variable assumption on the reduction
    rule for \gvconst{fork} allows us to assume that neither $C$ or $C'$ binds $x$ or $y$.)  From
    the type of \gvconst{link}, we have that $\Gamma,x:\outterm \vdash C[x]$; similarly, from $x \in
    \fv(M)$, we can conclude that $\Gamma_2,y:S \vdash C'[M\{y/x\}]$.  Finally, from the typing rule
    for \gvconst{wait}, we have that $\Gamma_2,x:\interm,y:S \vdash C'[\gvletunit{\gvconst{wait}
      \app x}{M\{y/x\}}]$, and that $\Gamma \vdash (\nu x)(C[x] \parallel
    C'[\gvletunit{\gvconst{wait} \app x}{M\{y/x\}}])$ \qed
  \end{itemize}
\end{proof}

\begin{theorem}\label{thm:preservation-equiv}
  If $\Gamma \vdash P$, $P \equiv P'$ and $P' \ceval Q'$, then there are some $\Gamma',Q$ such that
  either $\Gamma = \Gamma'$ or $\Gamma \ceval \Gamma'$, $Q' \equiv Q$, and $\Gamma' \vdash Q$.
\end{theorem}

\begin{proof}
  We begin by observing that if $P \ceval Q$, then there is some well-typed $P'$ such that $P =
  C[P']$, $P' \ceval Q'$, and $Q = C[Q']$.  The desired result is then obtained by structural
  induction on $P$, examining the possible equivalences in each case. \qed
\end{proof}

Define $\ceval^\star$ as the reflexive, transitive closure of $\equiv\ceval\equiv$.

\subsection{Deadlock and Its Absence}

Blocked terms:
\newcommand{\blockedp}{\mathsf{blocked}}
\newcommand{\depp}{\mathsf{depends}}
\[\begin{array}{rcl}
  \blockedp(x,M) &\defiff& \exists N. \; M = E[\gvconst{send} \app (x,N)] \\
  && \quad \lor \, M = E[\gvconst{receive} \app x] \\
  && \quad \lor \, M = E[\gvconst{wait} \app x] \\
  \depp(x,y,E[M]) &\defiff& \blockedp(x,M) \land y \in \fv(E) \\
  \depp(x,y,P) &\defiff& (P \equiv C[M] \land \depp(x,y,M)) \lor \, (P \equiv C[Q \parallel Q'] \\
  && \quad \land \, (\exists z. \depp(x,z,Q) \land \depp(z,y,Q')))
\end{array}\]
Finally, we have a natural definition of deadlock:
\newcommand{\deadlockp}{\ensuremath{\mathsf{deadlocked}}}
\[
\deadlockp(P) \defiff P \equiv C[Q \parallel Q'] \land \exists x,y. \depp(x,y,Q) \land \depp(y,x,Q').
\]
Because this definition depends on blocked processes (that is, those waiting to read or write) it
avoids the problems with return values (since a process returning a channel is not blocked on it, it
cannot be part of a deadlocked pair).  We say a process $P$ is deadlock-free if for all $Q$ such
that $P \ceval^\star Q$, $\lnot\deadlockp(Q)$.  Observe that if $P \equiv Q$, then $\deadlockp(P)
\iff \deadlockp(Q)$.

\begin{lemma}\label{thm:procs-share-one-channel}
  If $\Gamma \vdash P$, and $P = C[Q \parallel Q']$, then there is some variable $x$ such that
  $\fv(Q) \cap \fv(Q') = \{ x \}$.
\end{lemma}

\begin{proof}
  By structural induction on the derivation of $\Gamma \vdash P$; the only interesting case is for
  parallel composition, where the desired result is assured by the partitioning of the
  environment. \qed
\end{proof}

I think we can now show fairly directly that

\begin{lemma}\label{thm:typed-configs-df}
  If $\Gamma \vdash P$ then $\lnot \deadlockp(P)$.
\end{lemma}

\begin{proof}
  By contradiction: suppose $\deadlockp(P)$.  Then we know there must be some variables
  $x_1,\dots,x_n$ and processes $M_1,\dots,M_n$ in $P$ such that
  \[
    \blockedp(x_1,x_2,M_1) \land \blockedp(x_2,x_3,M_2) \land \cdots \land \blockedp(x_n,x_1,M_n).
  \]
  But now there is no possible $\Gamma$ such that any $\Gamma \vdash P'$ for any process $P'$
  containing the $M_i$---such a $P'$ would violate \lemref{procs-share-one-channel}.  \qed
\end{proof}

Finally, the following is trivial.

\begin{theorem}\label{thm:typed-terms-df}
  If $\Gamma \vdash M: T$, then $\distinguish M$ is deadlock-free.
\end{theorem}

\begin{proof}
  If $\Gamma \vdash M: T$, then $\Gamma \vdash \distinguish{M}$, and so
  $\lnot\deadlockp(\distinguish M)$ and, for any $Q$ such that $\distinguish M \ceval^\star Q$, we
  know that there is a well-typed $Q' \equiv Q$, and so $\lnot\deadlockp(Q)$. \qed
\end{proof}

\begin{definition}
A process $P$ is in canonical form if there is some sequence of variables $x_1,\dots,x_{n-1}$ and
terms $M_1,\dots,M_n$ such that
\[
  P = (\nu x_1)(M_1 \parallel (\nu x_2)(M_2 \parallel \dots \parallel (\nu x_{n-1})(M_{n-1} \parallel \distinguish{M_n})\dots)).
\]
\end{definition}

\begin{lemma}\label{thm:canonical}
  If $\Gamma \vdash P$, then there is some $P' \equiv P$ such that $\Gamma \vdash P'$ and $P'$ is in
  canonical form.
\end{lemma}

\begin{proof}
  Let $x_1,\dots,x_{n-1}$ be the $\nu$-bound variables in $P$ and $M_1,\dots,M_n$ be the terms in
  $P$; the proof is by induction on $n$.  If $n > 1$, then pick some $M_i$ such that there is
  exactly one $\nu$-bound variable $x_j$ where $x_j \in \fv(M_i)$.  (That there must be such an
  $M_i$ and $x_j$ can be established by a standard counting argument, together with
  \lemref{procs-share-one-channel}.)  Now, construct $Q$ from $P$ by the homomorphic extension of
  the mapping $(\nu x_j)P \mapsto P$ and $P \parallel M_i \mapsto P$.  From the assumption that
  $\Gamma \vdash P$, we can conclude that there is some $\Gamma' \subseteq \Gamma$ and type $S$ such
  that $\Gamma',x:S \vdash Q$.  By the induction hypothesis, there is some $Q' \equiv Q$ in
  canonical form.  Finally, let $P' = (\nu x_j)(M_i \parallel Q')$; we can see that
  straightforwardly that $P'$ is in canonical form; that $P \equiv P'$; and, that $\Gamma \vdash
  P'$. \qed
\end{proof}

\begin{theorem}\label{thm:progress-open}
  Let $\Gamma \vdash P$, $P \centernot\ceval$ and let $P' = (\nu x_1)(M_1 \parallel (\nu
  x_2)(M_2 \parallel \dots \parallel (\nu x_{n-1})(M_{n-1} \parallel \distinguish{M_n})\dots))$ be
  a canonical form of $P$.  Then:
  \begin{enumerate}
  \item For $1 \leq i \leq n - 1$ either $\blockedp(x_j,M_i)$ where $j \leq i$ or $\blockedp(y,M_i)$
    for some $y \in \dom(\Gamma)$; and,
  \item Either $M_n$ is a value or $\blockedp(y,M_n)$ for some $y \in \{ x_i \mid i \leq i \leq n -
    1 \} \cup \dom(\Gamma)$.
  \end{enumerate}
\end{theorem}

\begin{proof}
  By induction on the derivation of $\Gamma \vdash P'$, using the definition of $\ceval$. \qed
\end{proof}

\begin{corollary}\label{thm:progress}
  Let $\vdash P$, $P \centernot\ceval$ and let $P' = (\nu x_1)(M_1 \parallel (\nu
  x_2)(M_2 \parallel \dots \parallel (\nu x_{n-1})(M_{n-1} \parallel \distinguish{M_n})\dots))$ be
  a canonical form of $P$.  Then:
  \begin{enumerate}
  \item For $1 \leq i \leq n - 1$, $\blockedp(x_i,M_i)$; and,
  \item $M_n = \distinguish V$ for some value $V$.
  \end{enumerate}
\end{corollary}

\begin{proof}
  By induction on the derivation of $\vdash P'$, relying on \thmref{progress-open}.  \qed
\end{proof}

\section{Direct GV semantics}

\newcommand{\rpar}[1]{\mathbin{{[}\:\!\!\rangle}_{\!{#1}}\!}
\newcommand{\lrpar}[1]{\mathbin{\langle\hspace{-.3ex}\rangle}_{\!{#1}}\!}
\newcommand{\lpar}[1]{\mathbin{\langle\:\!\!{]}}_{{#1}}\!}

\newcommand{\con}[3]{{#1} \rpar{#2} {#3}}

\[
\gvconst{connect} : (S \lto \outterm, \gvdual{S} \lto T) \lto T
\]

Syntactic sugar:
\begin{align*}
\con{M}{x}{N} &\defiff \gvconst{connect}(\lambda x.M, \lambda x.N) \\
\con{L}{x}{\con{M}{y}{N}} &\defiff \con{L}{x}{(\con{M}{y}{N})} \\
\end{align*}

Equivalences ($\equiv$ is the transitive, reflexive, symmetric closure of the following rules):
\begin{align*}
\gvconst{link}\,(x,y) &\equiv \gvconst{link}\,(y,x) \\
\con{L}{x}{\con{M}{y}{N}} &\equiv \con{M}{y}{\con{L}{x}{N}} \\
\con{L}{x}{\con{M}{y}{N}} &\equiv \con{(\con{L}{x}{M})}{y}{N} \\
%\con{L}{x}{\con{M}{y}{N}} &\equiv \con{(\con{M}{x}{L})}{y}{N} \\
\end{align*}

Interesting reductions
\begin{align*}
\con{E[\gvconst{send}\,(V,x)]}{x}{E'[\gvconst{receive}\,x]}
  &\rto \con{E[x]}{x}{E'[(V,x)]} \\
\con{E[\gvconst{receive}\,x]}{x}{E'[\gvconst{send}\,(V,x)]}
  &\rto \con{E[(V,x)]}{x}{E'[x]} \\[1ex]
\con{x}{x}{E[\gvconst{wait}\,x]}
  &\rto E[()] \\
\con{E[\gvconst{wait}\,x]}{x}{x}
  &\rto E[()] \\[1ex]
\con{E[\gvconst{link}\,(x,y)]}{x}{M}
  &\rto \con{E[x]}{x}{(\gvconst{wait}\,x; M[y/x])} \\
\con{M}{x}{E[\gvconst{link}\,(x,y)]}
  &\rto \con{(\gvconst{wait}\,x; M[y/x])}{x}{E[x]} \\[1ex]
\gvconst{link}\,(x,\gvconst{link}\,(y,z))
  &\rto \gvconst{wait}\,x; \gvconst{link}\,(y,z) \\
E[\con{M}{x}{N}]
  &\rto \con{M}{x}{E[N]} \\
\end{align*}

An alternative is to remove the final commuting conversion rule and augment the notion of value to
include a suitable representation of a collection of blocked communicating processes.

Preservation
\begin{theorem}
If $\Gamma \vdash M : T$ and $M \rto N$ then $\Gamma \vdash N : T$.
\end{theorem}
%
\begin{proof}
By induction on the structure of the derivation of $\Gamma \vdash M : T$ using a standard
substitution lemma for the case of $\beta$-reduction at function types. \qed
\end{proof}

Progress
\begin{theorem}
\label{thm:free-progress}
If $\Gamma$ is a session environment (all variables in $\Gamma$ have session type) such that $\Gamma
\vdash M : T$ then one of the following holds:
\begin{enumerate}
\item $M$ is a value; or
\item there exists $N = \blockedp'(y_1, M_1) \rpar{x_1} \dots \rpar{x_{n}} \blockedp'(y_{n}, M_{n})$
  such that $M \equiv N$ and $\Gamma \vdash N : T$; or
\item there exists $N$ such that $M \rto N$.
\end{enumerate}
\end{theorem}
%
\begin{proof}
By induction on the structure of the derivation of $\Gamma \vdash M : T$. \qed
\end{proof}
% In the second case each $y_i$ must be equal to either $x_i$ or some $x$ in $\Gamma$.

\begin{theorem}
If $\vdash M : T$ then one of the following holds:
\begin{enumerate}
\item $M$ is a value; or
\item there exists $N = \blockedp(x_1, M_1) \rpar{x_1} \dots \rpar{x_{n-1}} \blockedp(x_{n-1},
  M_{n-1}) \rpar{x_n} V$ such that $M \equiv N$ and $\Gamma \vdash N : T$; or
\item there exists $N$ such that $M \rto N$.
\end{enumerate}
\end{theorem}
%
\begin{proof}
By induction on the structure of the derivation of $\vdash M : T$ using
\thmref{free-progress}. \qed
\end{proof}

$\blockedp(x, M)$ means $M$ is blocked on a send or receive involving $x$.

$\blockedp'(x, M)$ means either $M = x$ or $M$ is blocked on a send, receive, link, or wait
involving $x$.

\section{CP}

\todo{Shall we restrict ourselves to the multiplicative-additive fragment of CP?}

\todo{We're well short of the page limit for now, but I suspect we can probably cut much of this
  text.}

\todo{Should we write selection and choice the way other process calculi do? $x \triangleright
  l_i$ and $x \triangleleft \{ P;Q \}$.}

\begin{figure}[float]

\begin{mathpar}
\inferrule{ }{\cptyp{\link{x}{w}}{x:A,w:\cpdual{A}}}

\inferrule{\cptyp{P}{\Gamma,y:A} \\
           \cptyp{Q}{\Delta,y:\cpdual{A}}}
          {\cptyp{\cut{y}{A}{P}{Q}}{\Gamma,\Delta}}

\inferrule{ }{\cptyp{x[].0}{x:1}}

\inferrule{\cptyp{P}{\Gamma,y:A,x:B}}
          {\cptyp{x(y).P}{\Gamma,x:A \parr B}}

\inferrule{\cptyp{P}{\Gamma,y:A} \\
           \cptyp{Q}{\Delta,x:B}}
          {\cptyp{x[y].(P \mid Q)}{\Gamma,\Delta,x:A \otimes B}}

\inferrule{\cptyp{P}{\Gamma}}
          {\cptyp{x().P}{\Gamma,x:\bot}}

\inferrule{\cptyp{P}{\Gamma,x:A_i}}
          {\cptyp{\sel{x}{in_i}.P}{\Gamma,x:A_1 \oplus A_2}}

\inferrule{\cptyp{P}{\Gamma,x:A} \\
           \cptyp{Q}{\Gamma,x:B}}
          {\cptyp{\case{x}{P;Q}}{\Gamma,x:A \with B}}

\inferrule{ }{\cptyp{\case{x}{}}{\Gamma,x:\top}}
\end{mathpar}

\caption{Typing Rules for CP}\label{fig:cp-typing}
\end{figure}

The types of CP are the propositions of classical linear logic.
%
\[\begin{array}{@{}l@{~}r@{~}c@{~}l@{}}
  \text{Types} & A,B & ::= & A \otimes B \mid A \parr B \mid 1 \mid \bot \mid A \oplus B \mid A \with B \mid 0 \mid \top \\
\end{array}\]
CP adopts the standard notion of classical linear logic duality:
\[
\ba{@{}c@{\qquad}c@{\qquad}c@{\qquad}c@{}}
\begin{eqs}
  \cpdual{(A \otimes B)} &=& \cpdual{A} \parr \cpdual{B} \\
  \cpdual{(A \parr B)} &=& \cpdual{A} \otimes \cpdual{B} \\
\end{eqs}
&
\begin{eqs}
  \cpdual{1} &=& \bot \\
  \cpdual{\bot} &=& 1 \\
\end{eqs}
&
\begin{eqs}
  \cpdual{(A \oplus B)} &=& \cpdual{A} \with \cpdual{B} \\
  \cpdual{(A \with B)} &=& \cpdual{A} \oplus \cpdual{B} \\
\end{eqs}
&
\begin{eqs}
  \cpdual{\top} &=& 0 \\
  \cpdual{0} &=& \top \\
\end{eqs}
\ea
\]
where $X^{\perp\perp} = X$.
%
We let $\Gamma, \Delta$ range over type environments. The judgement $\cptyp{P}{\Gamma}$ states that
process $P$ uses channels $\Gamma$.
%
Typing rules for CP terms are given in Fig.~\ref{fig:cp-typing}. We write $fv(P)$ for the free
variables used in process $P$; in the typing rules, new bound variables are designated $y$.

\paragraph{Structural Rules.}

CP has two structural rules, axiom and cut. We interpret the axiom $\link{x}{w}$ as channel
forwarding: actions on channel $x$ are mirrored on $w$, and vice versa. Thus, $x$ and $w$ must have
dual type. Cut $\cut{y}{A}{P}{Q}$ is interpreted as communication between processes $P$ and $Q$ on
channel $y$; the duality of the typing of $y$ assures that its uses in $P$ and $Q$ are
compatible. We identify CP up to structural equivalence:
%
\begin{equations}
  \link{x}{w} &\equiv& \link{w}{x} \\
  \cut{y}{A}{P}{Q} &\equiv& \cut{y}{\cpdual{A}}{Q}{P} \\
  \cut{y}{A}{P}{\cut{z}{B}{Q}{R}} &\equiv& \cut{z}{B}{\cut{y}{A}{P}{Q}}{R}, \quad \text{if $y \not\in fv(R)$} \\
\end{equations}

\todo{We need to be careful here. Do we take the congruence closure of these rules, or do we do
  something more restrictive as in the GV semantics?}

\paragraph{Input and Output.}

The multiplicative connectives $\parr$ and $\otimes$ are interpreted as input and output. The
process $x(y).P$ inputs channel $y$ on channel $x$, and continues as $P$. The process $x[y].(P \mid
Q)$ is interpreted as bound output: it sends a fresh variable $y$ along $x$, spawns a process $P$ in
which $y$ is used, and continues as process $Q$ in which $x$ is used.  It amounts to the
$\pi$-calculus term $(\nu y) \overline{x}(y).(P \mid Q)$. We write $x[y].P$ as syntactic sugar for
$x[y'].(\link{y}{y'} \mid P)$. The units of $\parr$ and $\otimes$, $\bot$ and $1$, are interpreted
as nullary input and nullary output, respectively.

\paragraph{Selection and Choice.}

The additive connectives $\oplus$ and $\with$ are interpreted as selection and choice. The process
$\case{x}{P_1;P_2}$ offers a choice of processes $P_1$ and $P_2$; dually, the process
$\sel{x}{in_i}.P_i$ chooses the $i$-th alternative. The unit for choice is $0$, indicating
absurdity. Note that there is no term proving $0$. The dual of absurdity is $\top$, and provides
arbitrary behavior; as there is no term proving $0$, no term relying on $\top$ can reduce.

\subsection{Cut Elimination}


\begin{figure}[float]

\begin{equations}
\cut{x}{A}{\link{w}{x}}{P}
  &\Longrightarrow& P[w/x] \\
\cut{x}{A \otimes B}{x[y].(P \mid Q)}{x(y).R}
  &\Longrightarrow&
    \cut{y}{A}{Q}{\cut{x}{B}{P}{R}} \\
\cptyp{\cut{x}{1}{x[].0}{x().P}}{\Gamma}
  &\Longrightarrow&
    P \\
\cut{x}{A \oplus B}{\sel{x}{in_i}.P}{\case{x}{Q_1; Q_2}}
  &\Longrightarrow&
    \cut{x}{A}{P}{Q_i} \\
\end{equations}%
\caption{Principal Cut Elimination Rules}\label{fig:beta-reduction}

\end{figure}

Cut elimination corresponds to synchronous process reduction.  The principal cut reductions are
given in Fig.~\ref{fig:beta-reduction}. These are quite standard; for instance, cut reduction of
$\with$ against $\oplus$ corresponds to picking one of the offered alternatives.

\begin{figure}[float]

\begin{equations}
  \cut{z}{A}{x[y].(P \mid Q)}{R} &\Longrightarrow& x[y].(\cut{z}{A}{P}{R} \mid Q), \qquad \text{if $z \not\in fv(Q)$} \\
  \cut{z}{A}{x[y].(P \mid Q)}{R} &\Longrightarrow& x[y].(P \mid \cut{z}{A}{Q}{R}), \qquad \text{if $z \not\in fv(P)$} \\
  \cut{z}{A}{x(y).P}{Q} &\Longrightarrow& x(y).\cut{z}{A}{P}{Q} \\
  \cut{z}{A}{\sel{x}{in_i}.P}{Q} &\Longrightarrow& \sel{x}{in_i}.\cut{z}{A}{P}{Q} \\
  \cut{z}{A}{\case{x}{P;Q}}{R} &\Longrightarrow& \case{x}{\cut{z}{A}{P}{R}; \cut{z}{A}{Q}{R}} \\
\end{equations}
\caption{Commuting Conversions}\label{fig:commuting}
\end{figure}

The commuting conversions push communication under process prefixes, and are given in
Fig.~\ref{fig:commuting}.

\todo{Show that using a sane rule for send yields an entirely equivalent system --- and use that
  system!}

\todo{Think carefully about what to do with commuting conversions.}

\section{Translation from CP to GV}

\begin{figure}[float]
\begin{equations}
  \togv{\cut{x}{}{P}{Q}} &=&
    \gvlet{x}{\gvfork{x}{\togv{P}}}{\togv{Q}} \\
  \togv{\link{x}{y}} &=& \gvlet{z}{\gvlink{x}{y}}{z} \\
  \togv{x[y].(P \mid Q)} &=&
    \gvlet{y}{\gvfork{y}{\togv{P}}}{\gvlet{x}{\gvsend{(y, x)}}{\togv{Q}}} \\
  \togv{x(y).P} &=&
    \gvlet{(y,x)}{\gvreceive{x}}{\togv{P}} \\
  \togv{x[].0} &=& x \\
  \togv{x().P} &=& \gvlet{()}{\gvwait{x}}{\togv{P}} \\
  \togv{\sel{x}{\mathit{l}}.P} &=&
    \gvlet{x}{\gvselect{l}{x}}{\togv{P}} \\
  \togv{\case{x}{l_i.P_i}_i} &=&
    \gvcase{x}{l_i.\togv{P_i}}_i \\
\end{equations}

\begin{equations}
  \togvc{\cut{x}{}{P}{Q}} &=&
    (\nu x)(\togvc{P} \parallel \togvc{Q}) \\
  \togvc{x[y].(P \mid Q)} &=&
    (\nu y)(\togvc{P} \parallel \distinguish{\gvlet{x}{\gvsend{(y, x)}}{\togv{Q}}}) \\
  \togvc{P} &=& \distinguish{\togv{P}}, \quad \text{$P$ is not a cut or a send} \\
\end{equations}%

\caption{Translation of CP Terms into GV}\label{fig:fromcp}
\end{figure}

We now present the translation $\togv{-}$ from CP to GV. On types:
\[
\ba{@{}c@{\qquad}c@{\qquad}c@{}}
\begin{eqs}
\togv{A \otimes B} &=& \gvout{\gvdual{\togv{A}}}{\togv{B}} \\
\togv{A \parr B}   &=& \gvin{\togv{A}}{\togv{B}} \\
\end{eqs}
&
\begin{eqs}
\togv{1}           &=& \outterm \\
\togv{\bot}        &=& \interm \\
\end{eqs}
&
\begin{eqs}
\togv{+\{l_i:A_i\}_i}     &=& +\{l_i:\togv{A_i}\}_i  \\
\togv{\with\{l_i:A_i\}_i} &=& \with\{l_i:\togv{A_i}\}_i \\
\end{eqs}
\ea
\]

Figure~\ref{fig:fromcp} gives a translation from CP terms to GV terms ($\togvc{-}$) and a
translation from CP terms to GV configurations ($\togvc{-}$).

\begin{theorem}
If $P \equiv Q$, then $\togvc{P} \equiv \togvc{Q}$.
\end{theorem}

\todo{The above theorem isn't currently correct. We need to take more care in how we phrase
  structural equivalence for GV.}

\begin{theorem}
If $P \vdash \Gamma$ and $P \rto Q$, then $\togvc{P} \rto^+ \togvc{Q}$.
\end{theorem}


\section{Translation from GV to CP}

\todo{Various translations.}

\todo{Try to fit in with the configuration semantics.}

\todo{Ensure that the definition of $\equiv$ is appropriate for the theorems.}

\todo{Show that GV$\pi$ reduction simulates GV reduction.}

\todo{Show that the A-normalisation rules are sound (easy).}

\begin{theorem}
If $M, N$ are GV$\pi$-ANF terms and $M \equiv N$, then $\tocp{M}z \equiv \tocp{N}z$.
\end{theorem}

\begin{theorem}
If $M$ is a GV$\pi$-ANF term and $M \rto N$, then $\tocp{M}z \rto^+ \tocp{N}z$.
\end{theorem}

\section{Extending GV}

\subsection{Unifying $\gvend_x$}

We define a language GVX, which, depending on your perspective, either extends GV with mix or
combines the types of closed sessions.  The syntax is largely as in GV; the meaningful changes are
the elimination of $\interm$ and $\outterm$ in favor of $\gvend$, and the use of \gvconst{close} instead
of \gvconst{wait}.
\begin{syntax}
  \text{Session types} & S & ::= & \gvout{T}{S} \mid \gvin{T}{S} \mid \gvend \mid \channel{S} \\
  \text{Constants} & K & ::= & \gvconst{send} \mid \gvconst{receive} \mid \gvconst{fork} \mid \gvconst{close} \mid \gvconst{link}\\
\end{syntax}
The remaining parts of the grammar are unchanged from GV.  The definition of duality is updated to
reflect that $\gvend$ is self-dual:
\[
  \gvdual \gvend = \gvend
\]
We provide new typing rules for some of the constants
\begin{mathpar}
\gvconst{fork} : (S \lto \one) \lto \gvdual S

\gvconst{close} : \gvend \lto \one

\gvconst{link} : S \times \gvdual S \lto \one
\end{mathpar}
but otherwise the type system is unchanged from that of GV.  We require an extension of the type
system for configurations, however:
\begin{mathpar}
\inferrule
  {\Gamma \vdash M: T}
  {\Gamma \vdash^\bcirc \distinguish M}

\inferrule
  {\Gamma \vdash M: \one}
  {\Gamma \vdash^\wcirc M}

\inferrule
  {\Gamma, x: \channel S \vdash^\phi P}
  {\Gamma \vdash^\phi (\nu x)P}

\inferrule
  {\Gamma, x: S \vdash^\phi P \\
   \Gamma', x: \gvdual S \vdash^{\phi'} P'}
  {\Gamma,\Gamma',x:\channel S \vdash^{\phi + \phi'} P \parallel P'}

\inferrule
  {\Gamma \vdash^\phi P \\
   \Gamma' \vdash^{\phi'} P'}
  {\Gamma,\Gamma' \vdash^{\phi + \phi'} P \parallel P'}
\end{mathpar}
Perhaps the latter two rules can be combined by defining a suitable operation on environments;
however, it seems simpler now to just provide two typing rules.  Rules \textsc{Send, Fork, Lift} and
\textsc{Lift2} apply to GVX unchanged; the remaining reduction rules are
\begin{mathpar}
\inferrule
  { }
  {(\nu x)(C[\gvconst{close} \app x] \parallel C'[\gvconst{close} \app x)] \ceval C[()] \parallel C'[()]}

\inferrule
  {x \in \fv(P)}
  {C[\gvconst{link} \app (x,y)] \parallel P \ceval C[()] \parallel P \{y/x\}}
\end{mathpar}
The equivalences are similarly extended by
\begin{mathpar}
P \parallel () \equiv P
\end{mathpar}
We have a slightly different result about channels shared between processes, to account for the
multiple forms of composition:
\begin{lemma}
  If $\Gamma \vdash P$ and $P = C[Q \parallel Q']$, then $\fv(Q) \cap \fv(Q')$ is either empty or
  the singleton set $\{x\}$ for some variable $x$.
\end{lemma}
The proof is again by induction on the derivation of $\Gamma \vdash P$.  However, note that this has
no consequence for the proof of deadlock freedom (which depended on their being two channels shared
among processes).  Thus we can conclude that
\begin{theorem}
  If $\Gamma \vdash M: T$ then $\distinguish M$ is deadlock free.
\end{theorem}

\subsection{Adding Exponentials}

Basic approach: add a new type \gvforever{T} in the functional fragment, subject to contraction and
weakening, and with the usual introduction and elimination rules
\begin{syntax}
  \text{Types} & T & ::= & \gvforever T \mid \dots \\
  \text{Terms} & M,N & ::= & \gvlet{{!x}}{M}{N} \mid {!M} \mid \dots \\
  \text{Values} & V & ::= & {!V} \mid \dots \\
  \text{Evaluation contexts} & E & ::= & \gvlet{{!x}}{E}{M} \mid {!E} \mid \dots
\end{syntax}

\begin{mathpar}
\inferrule
  {\Gamma \vdash M: T \\
   \gvforever\Gamma}
  {\Gamma \vdash M: \gvforever T}

\inferrule
  {\Gamma \vdash M: \gvforever T \\
   \Gamma', x:T \vdash N: U}
  {\Gamma \vdash \gvlet{{!x}}{M}{N}: U}

\inferrule
  {\Gamma \vdash M: T}
  {\Gamma, x: \gvforever U \vdash M: T}

\inferrule
  {\Gamma,x:\gvforever T,x':\gvforever T \vdash M: U}
  {\Gamma,x:\gvforever T \vdash M \{ x/x' \}: T}
\end{mathpar}
with suitable expansion of evaluation contexts and the reduction rule
\begin{mathpar}
\gvlet{{!x}}{{!V}}{M} \teval M \{V/x\}
\end{mathpar}
with the observation that $x$ may appear multiple times in $M$.  The extension of the deadlock
freedom results to this calculus are immediate.

Our previous work on GV provided unlimited service channels, which could be used to obtain
arbitrarily many copies of some concurrent behavior.  We can encode such channels by introducing a
new type constructor $Service$ and two new constants \gvconst{replicate} and \gvconst{request}, with
the types
\begin{mathpar}
\gvconst{replicate} : (\gvforever(\gvdual S \lto \outterm)) \lto Service(S)

\gvconst{request} : Service(S) \lto S
\end{mathpar}
defined as follows
\begin{align*}
  Service(S) &\defeq \gvforever(\gvdual S \lto \outterm) \\
   \gvconst{replicate} &\defeq \lambda x.x \\
   \gvconst{request} &\defeq \lambda g. \gvlet{{!f}}{g}{\gvconst{fork} \app f}
\end{align*}

The translation from CP is unchanged from the previous version (albeit with changed names).  The
semantic correspondence should be straightforward, although GV's single evaluation rule for
$\gvlet{{!x}}{M}{N}$ may correspond to multiple cut\-against\-weakening or cut\-against\-contraction
reductions in CP.


\section{Related Work}\label{sec:related}

Something about connection to Carbone et al.  Their progress property requires that every
communication will eventually take place.  This is hopefully an easy consequence of ours.

\section{Conclusions and Future Work}\label{sec:conclusion}


\end{document}
