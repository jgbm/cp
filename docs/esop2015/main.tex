 % -*- fill-column: 100 -*-

\documentclass[orivec,envcountsame]{llncs}

\usepackage{amsmath,amssymb,centernot,hyperref,mathwidth,scalerel,stmaryrd,url,xspace,mathrsfs,enumitem}
\usepackage[table]{xcolor}
\usepackage{colortbl}
\addtolength{\jot}{-3px}

\usepackage{mathpartir}
\mprset{sep=1em}

\usepackage{float}
\floatstyle{boxed}
\restylefloat{figure}

\input{preamble.tex}

\title{Deadlock Freedom in a Functional Session-typed Language}
\author{J. Garrett Morris \and Sam Lindley \and Philip Wadler}
\institute{The University of Edinburgh \\
           \email{\{Garrett.Morris,Sam.Lindley,Philip.Wadler\}@ed.ac.uk} \vspace{-5mm}}

\begin{document}

\maketitle

\begin{abstract}
\end{abstract}

\section{Introduction}\label{sec:intro}

In this paper, we make the following contributions.
\begin{itemize}
\item We define a core linearly-typed functional language, by extending linear lambda calculus
  with session-typed communication primitives~\secref{gv-static}.
\item We present an (untyped) synchronous operational semantics for our core language, introducing
  explicit closures in the semantics of $\lambda$ terms and following the approach of Gay and
  Vasconcelos for the semantics of concurrent processes~\secref{gv-eval}.
\item We characterize deadlock and normal forms; we show that typed terms are deadlock-free, and
  that closed typed terms evaluate to normal forms~\secref{gv-deadlock}.
\item We connect our language to the interpretation of session types as linear logic propositions,
  by establishing a correspondence between the semantics of our language and that of Wadler's
  calculus CP~\secref{cp}.
\item We consider two extensions of our core language~\secref{extend}: one which harmonizes the
  treatment of closed channels with their treatment in other session-typed calculi~\secref{gv-end},
  and another which adds unlimited types and replicated behavior~\secref{gv-repl}.  We show that
  these extensions preserve the essential deadlock-freedom properties of the core language.
\end{itemize}
Finally, we discuss related work~\secref{related} and conclude~\secref{conclusion}.

\section{GV by Example}\label{sec:examples}

\subsection{Books and Stores Therefore}

\todo{This ended up being a bit long.  There are a couple of points that it makes tho:
  \begin{itemize}
  \item Transmission of channels (sending client channel to bank).
  \item Sending structured values along channels.
  \end{itemize}
  And it has a motivation.  However, I'm not sure that either of these is important enough to
  justify the length.  We could, for example, do the calculator with structured values and not take
  nearly as much space.}

\begin{code}
Client \defeq \lambda c.
  \bl
  \gvlet{c}{\gvsend{(\text{``A Tale of Two Cities"}, c)}}{} \\
  \gvlet{(price,c)}{\gvreceive{c}}{} \\
  \mkwd{if}\ price \leq 20\ \mkwd{then} \\
  \quad\bl
    \gvlet{c}{\gvselect{purchase}{c}}{}\\
    \gvlet{c}{\gvsend{((ccName, ccNumber), c)}}{} \\
    \mkwd{offer}\,c\,\{ \\
    \quad \bl
      accept\,c \mapsto \gvconst{wait} \app c; \gvconst{print} \app \text{``:)"} \\
      decline\,c \mapsto \gvconst{wait} \app c; \gvconst{print} \app \text{``:("} \\
      challenge\,c \mapsto \\
      \quad \bl
        \gvlet{c}{\gvsend{(response, c)}}{} \\
        \mkwd{offer}\,c\,\{ \\
        \quad \bl
          accept\,c \mapsto \gvconst{wait} \app c; \gvconst{print} \app \text{``:)"} \\
          decline\,c \mapsto \gvconst{wait} \app c; \gvconst{print} \app \text{``:("} \} \}
        \el
      \el
    \el
  \el \\
  \mkwd{else} \\
  \quad \bl
    \gvlet{c}{\gvselect{stop}{c}}{} \\
    \gvconst{wait} \app c
    \el
  \el
\end{code}

\begin{code}
Store \defeq \lambda b. \lambda c. \bl
  \gvlet{(product, c)}{\gvreceive{c}}{} \\
  \gvlet{c}{\gvsend{(price(product), c)}}{} \\
  \mkwd{offer}\,c\,\{ \\
  \quad \bl
    purchase\,c \mapsto \\
    \quad \bl
      \gvlet{((ccName, ccNumber), c)}{\gvreceive{c}}{} \\
      \gvlet{b}{\gvsend{((ccName, ccNumber, price(product), c), b)}}{} \\
      \mkwd{offer}\,b \, \{\\
      \quad \bl
        accept\,b \mapsto
          \gvlet{(c,b)}{\gvreceive{b}}{\gvconst{wait} \app b; \dots; c} \\
        reject\,b \mapsto
          \gvlet{(c,b)}{\gvreceive{b}}{\gvconst{wait} \app b; c} \}
      \el
    \el \\
    stop\,c \mapsto c \}
  \el
\el\end{code}

\begin{code}
Bank \defeq \lambda b. \bl
  \gvlet{((ccName, ccNumber, amount, c), b)}{\gvreceive{b}}{} \\
  \mkwd{if}\ suspicious(ccNumber, amount)\ \mkwd{then} \\
  \quad\bl
    \gvlet{c}{\gvselect{challenge}{c}}{} \\
    \gvlet{(response, c)}{\gvreceive{c}}{} \\
    \mkwd{if}\ passes(response)\ \mkwd{then} \\
    \quad \bl
      \gvlet{c}{\gvselect{accept}{c}}{} \\
      \gvlet{b}{\gvselect{accept}{b}}{} \\
      \gvlet{b}{\gvsend{(c,b)}}{} \\
      \dots; c \el \\
    \mkwd{else} \\
    \quad \bl
      \gvlet{c}{\gvselect{reject}{c}}{} \\
      \gvlet{b}{\gvselect{reject}{b}}{} \\
      \gvlet{b}{\gvsend{(c,b)}}{} \\
      c \el
  \el
\el
\end{code}

\begin{code}
System \defeq \bl
  \gvlet{bank}{\gvconst{fork} \app Bank}{} \\
  \gvlet{store}{\gvconst{fork} \app (Store \app bank)}{} \\
  Client \app store
\el
\end{code}

\subsection{Selection and Choice}

\small\begin{align*}
  \oplus \{ \ell_1 : S_1,\dots,\ell_n:S_n \} &\defeq \gvout{(\ell_1:S_1 + \cdots + \ell_n:S_n)}{\outterm} \\
  \with \{ \ell_1 : S_1,\dots,\ell_n:S_n \} &\defeq \gvin{(\ell_1:S_1 + \cdots + \ell_n:S_n)}{\interm} \\
  \gvconst{select} \app \ell_i \app M &\defeq \gvconst{fork} (\lambda x. \gvsend(\ell_i \app x, M)) \\
  \gvconst{offer} \app M \,\{ \ell_1 \app x \mapsto P; \dots; \ell_n \app x \mapsto Q \}
    &\defeq \bl \gvlet{(y,m)}{\gvreceive{M}}{\\\gvletunit{\gvconst{wait} \app m}{\\\gvcase{x}{\ell_1 \app x \mapsto P; \dots; \ell_n \app x \mapsto Q}}} \el
\end{align*}\normalsize

\section{I'm Pickin' Up Good Vibrations}\label{sec:gv}

I'm intentionally ignoring CP polymorphism forever.

\subsection{Syntax and Typing}\label{sec:gv-static}

\begin{figure}[t]
\begin{syntax}
  \text{Session types} & S & ::= & \gvout{T}{S} \mid \gvin{T}{S} \mid % \oplus \{ \overline{l:S} \} \mid \with \{ \overline{l:S} \} \mid
                                   \interm \mid \outterm \mid \channel{S} \\
  \text{Types} & T,U & ::= & S \mid T \times U \mid \one \mid T + U \mid \zero \mid T \lto U \\ % \mid {!T} \\
  \text{Terms} & M,N & ::= & x \mid K \mid \lambda x.M \mid M\,N \\
  & & \mid & (M,N) \mid \gvlet{(x,y)}{M}{N} \\
  & & \mid & \mkwd{inl}\,M \mid \mkwd{inr}\,M \mid \gvcase{M}{\mkwd{inl}\,x \mapsto N; \mkwd{inr}\,x \mapsto N} \\
  & & \mid & () \mid \gvletunit{M}{N} \mid \gvconst{absurd} \app M \\
  \text{Constants} & K & ::= & \gvconst{send} \mid \gvconst{receive} \mid \gvconst{fork} \mid \gvconst{wait} \mid \gvconst{link}\\
\end{syntax}
\caption{Syntax of GV terms and types}\label{fig:gv-syntax}
\end{figure}

\figref{gv-syntax} gives the syntax of GV types and terms.  The types include 0-ary and binary
(linear) sums and pairs, and the linear


                        The terms are the standard terms of a (linear) lambda calculus, augmented
with construction and deconstruction of 0-ary and binary pairs and sums.  The concurrent behavior is
provided by the constants $K$.  Communication is provided by \gvconst{send} and \gvconst{receive}.
For example, a computation that received two numbers along a channel $z$ and then sent their sum
along the same channel could be expressed by
\[\bl
  \gvlet{(x,z)}{\gvreceive{z}}{} \\
  \gvlet{(y,z)}{\gvreceive{z}}{} \\
  \gvsend{(x+y,z)} \el
\]
Channels are treated linearly in GV.  Thus, \gvconst{receive} returns not just the received value
($x$ or $y$), but also a new copy of the channel ($z$); similarly, \gvconst{send} returns a copy of
the channel (which we have not bound in the example).

\begin{mathpar}
\gvdual{\gvout{T}{S}} = \gvin{T}{\gvdual S}

\gvdual{\gvin{T}{S}} = \gvout{T}{\gvdual S}

\gvdual{\interm} = \outterm

\gvdual{\outterm} = \interm
\end{mathpar}

\begin{figure}
Typing rules:
\begin{mathpar}
\inferrule
  {T \not= \channel{S}}
  {\{x:T\} \vdash x:T}

\inferrule
  {\Gamma,x:T \vdash M:U}
  {\Gamma \vdash \lambda x.M : T \lto U}

\inferrule
  {\Gamma \vdash M: T \lto U \\
   \Delta \vdash N: T}
  {\Gamma,\Delta \vdash M\,N: U}

\inferrule
  {\Gamma \vdash M: T \\
   \Delta \vdash N: U}
  {\Gamma,\Delta \vdash (M,N): T \times U}

\inferrule
  {\Gamma \vdash M: T \times T' \\
   \Delta,x:T,y:T' \vdash N: U}
  {\Gamma,\Delta \vdash \gvlet{(x,y)}{M}{N} : U}

\inferrule
  {\Gamma \vdash M: T}
  {\Gamma \vdash \mkwd{inl}\,M: T+U}

\inferrule
  {\Gamma \vdash M: T+T' \\
   \Delta,x:T \vdash N: U \\
   \Delta,x:T' \vdash N': U}
  {\Gamma,\Delta \vdash \gvcase{M}{\mkwd{inl}\,x \mapsto N; \mkwd{inr}\,x \mapsto N'} : U}

\inferrule
  { }
  {\vdash (): \one}

\inferrule
  {\Gamma \vdash M: \one \\
   \Delta \vdash N: T}
  {\Gamma,\Delta \vdash \gvletunit{M}{N}: T}

\inferrule
  {\Gamma \vdash M: \zero}
  {\Gamma, \Gamma' \vdash \gvconst{absurd} \app M : T}
\end{mathpar}
Type schemas for constants:
\begin{mathpar}
\gvconst{send} : T \times \gvout{T}{S} \lto S

\gvconst{receive} : \gvin{T}{S} \lto T \times S

\gvconst{fork} : (S \lto \outterm) \lto \gvdual{S}

\gvconst{wait} : \interm \lto \one

\gvconst{link} : S \times \gvdual{S} \lto \outterm
\end{mathpar}
\caption{GV typing rules}\label{fig:gv-typing}
\end{figure}

\subsection{Evaluation}\label{sec:gv-eval}

\newcommand{\distinguish}[1]{\langle #1 \rangle}

\newcommand{\wcirc}{{\mathord{\circ}}}
\newcommand{\bcirc}{{\mathord{\bullet}}}

\begin{syntax}
  \text{Substitutions} & \sigma & ::= & \{ \bind {x_1} {V_1}, \dots, \bind {x_n} {V_n} \} \\
  & & & \qquad\text{ where the $x_i$ are pairwise distinct} \\
  \text{Values} & V & ::= & x \mid K \mid \lambda^\sigma x.M \\
  & & \mid & () \mid (V,V') \mid \mkwd{inl}\,V \mid \mkwd{inr}\,V  \\
  \text{Evaluation contexts} & \Ex & ::= &  [~] \mid \Ex\,M \mid V\,\Ex \mid \gvletunit{\Ex}{M} \\
  & & \mid & (\Ex,M) \mid (V,\Ex) \mid \gvlet{(x,y)}{\Ex}{M} \\
  & & \mid & \mkwd{inl}\,\Ex \mid \mkwd{inr}\,\Ex \mid \gvcase{\Ex}{\mkwd{inl}\,x \mapsto N; \mkwd{inr}\,x \mapsto N'} \\
  & \Fx & ::= & \Ex \mid \distinguish \Ex \\
  \text{Configurations} & C,D & ::= & M \mid \distinguish M \mid C \parallel C' \mid (\nu x) C \\
  \text{Configuration contexts} & \Cx & ::= & [~] \mid \Cx \parallel P \mid (\nu x)\Cx \\
  \text{Flags} & \phi & ::= & \wcirc \mid \bcirc
\end{syntax}
We will implicitly treat substitutions $\sigma$ as sets of bindings.  We define the application of
one substitution $\sigma$ to another $\sigma'$ by
\[
  \sigma'\sigma \defeq \{ \bind x {\sigma V} \mid \bind x v \in \sigma' \}.
\]
Note that this is not the standard notion of substitution composition.  Finally, we define the
application of a substitution to a term $M\sigma$ by the homomorphic extension of the following
\begin{align*}
  x\sigma  &\defeq V &&\text{if $(\bind x V) \in \sigma$} \\
  (\lambda^{\sigma'} x.M)\sigma  &\defeq \lambda^{\sigma' \sigma} x.M \\
  M\sigma  &\defeq M &&\text{if $x \not\in \fv(M)$}
\end{align*}
As values, we have closures, which combine an abstraction with a captured substitution.  We will
treat $\lambda x.M$ as syntactic sugar for $\lambda^\sigma x.M$ where $\sigma = \{ \bind x x \mid x
\in \fv(M) \setminus \{ x \}\}.$ We extend the typing rules for terms with a typing rule for
closures:
\[
\inferrule
  {\Gamma, x:T \vdash M\sigma : U \\
   \dom(\sigma) = (\fv(M) \setminus \{ x \})}
  {\Gamma \vdash \lambda^\sigma x.M : T \lto U}
\]
Note that the invariant on the domain of $\sigma$ is preserved under substitution.

We define combination of flags $\phi + \phi'$ by
\begin{mathpar}
  \wcirc + \wcirc = \wcirc

  \wcirc + \bcirc = \bcirc

  \bcirc + \wcirc = \bcirc
\end{mathpar}
and leave $\bcirc + \bcirc$ undefined.
Configuration typing is given by
\begin{mathpar}
\inferrule
  {\Gamma \vdash M: T}
  {\Gamma \vdash^\bcirc \distinguish M}

\inferrule
  {\Gamma \vdash M: \outterm}
  {\Gamma \vdash^\wcirc M}

\inferrule
  {\Gamma, x:\channel{S} \vdash^\phi C}
  {\Gamma \vdash^\phi (\nu x) C}

\inferrule
  {\Gamma,x:S \vdash^{\phi} C \\
   \Gamma',x:\gvdual{S} \vdash^{\phi'} C'}
  {\Gamma,\Gamma',x:\channel{S} \vdash^{\phi + \phi'} C \parallel C'}
\end{mathpar}
We will write $\Gamma \vdash P$ for $\Gamma \vdash^\phi P$.  Note that while we can write the
classic deadlocked configuration
\[
  (\nu x)(\nu y)(\distinguish{\gvlet{(z,x)}{\gvconst{receive} \app x}{\gvconst{send} \app (z,y)}} \parallel
                 \gvlet{(z,y)}{\gvconst{receive} \app y}{\gvconst {send} \app (z,x)})
\]
it is not well typed: we can only split one of $x,y$ at the $\parallel$.  Term reductions follow.
$\beta$ rules:
\begin{align*}
  (\lambda^\sigma x.M)\,V &\teval M(\{\bind x V\} \uplus \sigma) \\
  \gvletunit{()}{M} &\teval M \\
  \gvlet{(x,y)}{(V,V')}{M} &\teval M \{ \bind x V, \bind y {V'} \} \\
  \gvcase{(\mkwd{inl}\,V)}{\mkwd{inl}\,x \mapsto N; \mkwd{inr}\,x \mapsto N'} &\teval N \{ \bind x V \} \\
  E[M] &\teval E[M'] \qquad \text{if $M \teval M'$}
\end{align*}
Configuration equivalence:
\begin{mathpar}
\Fx[\mathsf{link}\,(x,y)] \equiv \Fx[\mathsf{link}\,(y,x)]

C \parallel D \equiv D \parallel C

C \parallel (D \parallel E) \equiv (C \parallel D) \parallel E

C \parallel (\nu x)D \equiv (\nu x)(C \parallel D) \text{ if $x \not\in \fv(C)$}

\Cx[C] \equiv \Cx[D] \text{ if $C \equiv D$}
\end{mathpar}

Awkwardly enough, the equivalence rules do not preserve typing.  For example, supposing that $x \in
\fv(C), y \in \fv(D), \text{ and } x,y \in \fv(E)$, we have $\vdash (\nu x y)(C \mid (D \mid E))$
but not $\nvdash (\nu x y)((C \mid D) \mid E)$.  We have a simple reduction rule for configuration
types, given by
\begin{mathpar}
\inferrule
%  [T-Output]
  { }
  {\channel{(\gvout T S)} \ceval \channel S}

\inferrule
%  [T-Input]
  { }
  {\channel{(\gvin T S)} \ceval \channel S}

\inferrule
%  [T-Context]
  {T \ceval T'}
  {\Gamma,x:T \ceval \Gamma,x:T'}
\end{mathpar}
We write $\Gamma \ceval^? \Gamma'$ to denote $\Gamma = \Gamma' \lor \Gamma \ceval \Gamma'$.
Configuration reduction is given by
\begin{mathpar}
\inferrule
  [Send]
  { }
  {\Fx[\gvconst{send} \app (V,x)] \parallel \Fx'[\gvconst{receive} \app x] \ceval \Fx[x] \parallel \Fx'[(V,x)]}

\inferrule
  [Fork]
  {\text{$x$ is a fresh channel name}}
  {\Fx[\gvconst{fork} \app (\clos{\sigma}{x}{M})] \ceval (\nu x)(\Fx[x] \parallel M\sigma)}
%%  {\Fx[\gvconst{fork} \app (\clos{\sigma}{x}{M})] \ceval (\nu x)(\Fx[x] \parallel M(\{\bind x x\} \uplus \sigma)}
  %% [Fork]
  %% {\text{$x$ fresh}}
  %% {\Fx[\gvconst{fork} \app V] \ceval (\nu x)(\Fx[x] \parallel (V\,x))}

\inferrule
  [Wait]
  { }
  {(\nu x)(\phi E[\gvconst{wait} \app x] \parallel \phi' x)
       \ceval (\phi + \phi')\Fx[()]}

\inferrule
   [Link]
   {x \in \fv(M)}
   {(\nu x) (\Fx[\gvconst{link} \app (x, y)] \parallel \Fx'[M]) \ceval (\nu x)(\Fx[x] \parallel \Fx'[\gvletunit{\gvconst{wait} \app x}{M\{y/x\}}])}

\inferrule
   [Lift]
   {C \ceval C'}
   {\Cx[C] \ceval \Cx[C']}

\inferrule
   [Lift2]
   {M \teval M'}
   {\Cx[M] \ceval \Cx[M']}

%% [Lift3] would allow us to slightly simplify [Send] and [Link]
%%
%% \inferrule
%%    [Lift3]
%%    {\Cx[M] \ceval \Cx[M']}
%%    {\Cx[\Fx[M]] \ceval \Cx[\Fx[M']]}
\end{mathpar}
Some things that might be useful.
\begin{lemma}\label{thm:term-preservation}
  If $\Gamma \vdash M: T$ and $M \teval M'$, then $\Gamma \vdash M': T$
\end{lemma}

\noindent
The proof is standard.

\begin{theorem}\label{thm:preservation}
  If $\Gamma \vdash C$ and $C \ceval C'$ then there is some $\Gamma'$ such that $\Gamma \ceval^?
  \Gamma'$ and $\Gamma' \vdash C'$.
\end{theorem}

\begin{proof}
  By induction on the derivation of $C \ceval C'$.
  \begin{itemize}
  \item Case \textsc{Lift} is immediate by the induction hypothesis.
  \item Case \textsc{Lift2} follows from \lemref{term-preservation}, with $\Gamma = \Gamma'$.
  \item In case \textsc{Send}, from the assumption $\Gamma \vdash \Cx[\mkwd{send}\,(V,x)] \parallel
    C'[\gvconst{receive} \app x]$, we can assume that $\Gamma$ partitions as
    $\Gamma_1,\Gamma_2,x:\channel{S}$ such that $S = \gvout{T}{S'}$, $V$ has type $T$, and
    $\Gamma_1,x:\gvout{T}{S'} \vdash \Cx[\gvconst{send} \app (V,x)]$,
    $\Gamma_2,x:\gvin{T}{\gvdual{S'}} \vdash C'[\gvconst{receive} \app x]$.  As $\gvconst{send} : T
    \times \gvout{T}{S'} \lto S'$ and $\Gamma_1,x:\gvout{T}{S'} \vdash \Cx[\gvconst{send} \app
    (V,x)]$, we can conclude that $\Gamma_1,x:S' \vdash \Cx[x]$.  By a similar argument, we conclude
    that $\Gamma_2,x:\gvdual{S'} \vdash C'[(V,x)]$. Finally, as $\channel{(\gvout{T}{S})} \ceval
    \channel{S}$, $\Gamma_1,\Gamma_2,x:\channel{(\gvout T S)} \ceval
    \Gamma_1,\Gamma_2,x:\channel{S}$, and we can recompose the resulting processes concluding that
    $\Gamma_1,\Gamma_2,x:\channel{S} \vdash \Cx[x] \parallel C'[(V,x)]$.
  \item In case \textsc{Fork}, from the assumption $\Gamma \vdash \Cx[\gvconst{fork} \app V]$, we can
    conlude that $\Gamma$ splits into $\Gamma_1,\Gamma_2$ and there is some $S$ such that
    $\Gamma_1,x:S \vdash \Cx[x]$ and $\Gamma_2,x:\gvdual{S} \vdash V \app x$.  Thus we have that
    $\Gamma,x:S \vdash \Cx[x] \parallel V \app x$ and $\Gamma \vdash (\nu x)(\Cx[x] \parallel
    V \app x)$.
  \item In case \textsc{Wait}, from the assumption $\Gamma \vdash (\nu x)(\Cx[\gvconst{wait} \app
    x] \parallel x)$, we can conclude that $\Gamma,x:\interm \vdash \Cx[\gvconst{wait} \app x]$ and
    thus, from the typing of \gvconst{wait}, that $\Gamma \vdash \Cx[()]$.
  \item In case \textsc{Link}, from the assumptions $\Gamma \vdash (\nu x) (\Cx[\gvconst{link} \app
    (x, y)] \parallel C'[M]), x \in \fv(M)$, we can conclude that $\Gamma$ partitions as
    $\Gamma_1,\Gamma_2,y:S$ such that $\Gamma_1,y:S,x:\gvdual{S} \vdash \Cx[\gvconst{link} \app (x,
    y)]$ and $\Gamma_2,x:S \vdash C'[M]$.  (Note that the free variable assumption on the reduction
    rule for \gvconst{fork} allows us to assume that neither $C$ or $C'$ binds $x$ or $y$.)  From
    the type of \gvconst{link}, we have that $\Gamma,x:\outterm \vdash \Cx[x]$; similarly, from $x \in
    \fv(M)$, we can conclude that $\Gamma_2,y:S \vdash C'[M\{y/x\}]$.  Finally, from the typing rule
    for \gvconst{wait}, we have that $\Gamma_2,x:\interm,y:S \vdash C'[\gvletunit{\gvconst{wait}
      \app x}{M\{y/x\}}]$, and that $\Gamma \vdash (\nu x)(\Cx[x] \parallel
    C'[\gvletunit{\gvconst{wait} \app x}{M\{y/x\}}])$ \qed
  \end{itemize}
\end{proof}

\begin{theorem}\label{thm:preservation-equiv}
  If $\Gamma \vdash C$, $C \equiv C'$ and $C' \ceval D'$, then there are some $\Gamma',D$ such that
  $\Gamma \ceval^? \Gamma'$ and $\Gamma' \vdash D$.
\end{theorem}

\begin{proof}
  We begin by observing that if $C \ceval D$, then there is some well-typed $C'$ such that $C =
  \Cx[C']$, $C' \ceval D'$, and $D = \Cx[D']$.  The desired result is then obtained by structural
  induction on $C$, examining the possible equivalences in each case. \qed
\end{proof}

Define $\ceval^\star$ as the reflexive, transitive closure of $\equiv\ceval\equiv$.  Note that,
while $\equiv$ does not necessarily preserve typing, we can use \thmref{preservation-equiv} to
conclude that if $\Gamma \vdash C$ and $C \ceval^\star D$, there are some $\Gamma',D'$ such that
$\Gamma \ceval^\star \Gamma'$, $D \equiv D'$, and $\Gamma' \vdash D'$.

\subsection{Deadlock and Its Absence}\label{sec:gv-deadlock}

Blocked terms:
\newcommand{\blockedp}{\mathsf{blocked}}
\newcommand{\depp}{\mathsf{depends}}
\[\begin{array}{rcl}
  \blockedp(x,M) &\defiff& \exists N. \; M = \Ex[\gvconst{send} \app (x,N)] \\
  && \quad \lor \, M = \Ex[\gvconst{receive} \app x] \\
  && \quad \lor \, M = \Ex[\gvconst{wait} \app x] \\
  \depp(x,y,\Ex[M]) &\defiff& \blockedp(x,M) \land y \in \fv(\Ex) \\
  \depp(x,y,C) &\defiff& (C \equiv \Cx[M] \land \depp(x,y,M)) \lor \, (C \equiv \Cx[D \parallel D'] \\
  && \quad \land \, (\exists z. \depp(x,z,D) \land \depp(z,y,D')))
\end{array}\]
Finally, we have a natural definition of deadlock:
\newcommand{\deadlockp}{\ensuremath{\mathsf{deadlocked}}}
\[
\deadlockp(C) \defiff C \equiv \Cx[D \parallel D'] \land \exists x,y. \depp(x,y,D) \land \depp(y,x,D').
\]
Because this definition depends on blocked processes (that is, those waiting to read or write) it
avoids the problems with return values (since a process returning a channel is not blocked on it, it
cannot be part of a deadlocked pair).  We say a process $C$ is deadlock-free if for all $D$ such
that $C \ceval^\star D$, $\lnot\deadlockp(D)$.  Observe that if $C \equiv D$, then $\deadlockp(C)
\iff \deadlockp(D)$.

\begin{lemma}\label{thm:procs-share-one-channel}
  If $\Gamma \vdash C$, and $C = \Cx[D \parallel D']$, then there is some variable $x$ such that
  $\fv(D) \cap \fv(D') = \{ x \}$.
\end{lemma}

\begin{proof}
  By structural induction on the derivation of $\Gamma \vdash C$; the only interesting case is for
  parallel composition, where the desired result is assured by the partitioning of the
  environment. \qed
\end{proof}

I think we can now show fairly directly that

\begin{lemma}\label{thm:typed-configs-df}
  If $\Gamma \vdash C$ then $\lnot \deadlockp(C)$.
\end{lemma}

\begin{proof}
  By contradiction: suppose $\deadlockp(C)$.  Then we know there must be some variables
  $x_1,\dots,x_n$ and processes $M_1,\dots,M_n$ in $C$ such that
  \[
    \blockedp(x_1,x_2,M_1) \land \blockedp(x_2,x_3,M_2) \land \cdots \land \blockedp(x_n,x_1,M_n).
  \]
  But now there is no possible $\Gamma$ such that any $\Gamma \vdash C'$ for any process $C'$
  containing the $M_i$---such a $C'$ would violate \lemref{procs-share-one-channel}.  \qed
\end{proof}

Finally, the following is trivial.

\begin{theorem}\label{thm:typed-terms-df}
  If $\Gamma \vdash M: T$, then $\distinguish M$ is deadlock-free.
\end{theorem}

\begin{proof}
  If $\Gamma \vdash M: T$, then $\Gamma \vdash \distinguish{M}$, and so
  $\lnot\deadlockp(\distinguish M)$ and, for any $D$ such that $\distinguish M \ceval^\star D$, we
  know that there is a well-typed $D' \equiv D$, and so $\lnot\deadlockp(D)$. \qed
\end{proof}

\begin{definition}
A process $C$ is in canonical form if there is some sequence of variables $x_1,\dots,x_{n-1}$ and
terms $M_1,\dots,M_n$ such that
\[
  C = (\nu x_1)(M_1 \parallel (\nu x_2)(M_2 \parallel \dots \parallel (\nu x_{n-1})(M_{n-1} \parallel C_n)\dots)),
\]
where either $C_n = M_n$ or $C_n = \distinguish M_n$.
\end{definition}

\begin{lemma}\label{thm:canonical}
  If $\Gamma \vdash C$, then there is some $C' \equiv C$ such that $\Gamma \vdash C'$ and $C'$ is in
  canonical form.
\end{lemma}

\begin{proof}
  Let $x_1,\dots,x_{n-1}$ be the $\nu$-bound variables in $C$ and $M_1,\dots,M_n$ be the terms in
  $P$; the proof is by induction on $n$.  If $n > 1$, then pick some $M_i$ such that there is
  exactly one $\nu$-bound variable $x_j$ where $x_j \in \fv(M_i)$.  (That there must be such an
  $M_i$ and $x_j$ can be established by a standard counting argument, together with
  \lemref{procs-share-one-channel}.)  Now, construct $D$ from $C$ by the homomorphic extension of
  the mapping $(\nu x_j)E \mapsto E$ and $E \parallel M_i \mapsto E$.  From the assumption that
  $\Gamma \vdash C$, we can conclude that there is some $\Gamma' \subseteq \Gamma$ and type $S$ such
  that $\Gamma',x:S \vdash D$.  By the induction hypothesis, there is some $D' \equiv D$ in
  canonical form.  Finally, let $C' = (\nu x_j)(M_i \parallel D')$; we can see that
  straightforwardly that $C'$ is in canonical form; that $C \equiv C'$; and, that $\Gamma \vdash
  C'$. \qed
\end{proof}

\begin{theorem}\label{thm:progress-open}
  Let $\Gamma \vdash C$, $C \centernot\ceval$ and let $C' = (\nu x_1)(M_1 \parallel (\nu
  x_2)(M_2 \parallel \dots \parallel (\nu x_{n-1})(M_{n-1} \parallel D)\dots))$ be
  a canonical form of $C$.  Then:
  \begin{enumerate}
  \item For $1 \leq i \leq n - 1$ either $\blockedp(x_j,M_i)$ where $j \leq i$ or $\blockedp(y,M_i)$
    for some $y \in \dom(\Gamma)$; and,
  \item There is a term $M_n$ such either $D = M_n$ or $D = \distinguish{M_n}$ and either $M_n$ is a
    value or $\blockedp(y,M_n)$ for some $y \in \{ x_i \mid i \leq i \leq n - 1 \} \cup
    \dom(\Gamma)$.
  \end{enumerate}
\end{theorem}

\begin{proof}
  By induction on the derivation of $\Gamma \vdash C'$, using the definition of $\ceval$. \qed
\end{proof}

\begin{corollary}\label{thm:progress}
  Let $\vdash C$, $C \centernot\ceval$ and let $C' = (\nu x_1)(M_1 \parallel (\nu
  x_2)(M_2 \parallel \dots \parallel (\nu x_{n-1})(M_{n-1} \parallel \distinguish{M_n})\dots))$ be
  a canonical form of $C$.  Then:
  \begin{enumerate}
  \item For $1 \leq i \leq n - 1$, $\blockedp(x_i,M_i)$; and,
  \item There is a value $V$ such that either $M_n = \distinguish V$ or $M_n = V$.
  \end{enumerate}
\end{corollary}

\begin{proof}
  By induction on the derivation of $\vdash P'$, relying on \thmref{progress-open}.  \qed
\end{proof}

%% \subsection{Direct GV semantics}
%%
%% \newcommand{\rpar}[1]{\mathbin{{[}\:\!\!\rangle}_{\!{#1}}\!}
%% \newcommand{\lrpar}[1]{\mathbin{\langle\hspace{-.3ex}\rangle}_{\!{#1}}\!}
%% \newcommand{\lpar}[1]{\mathbin{\langle\:\!\!{]}}_{{#1}}\!}
%%
%% \newcommand{\con}[3]{{#1} \rpar{#2} {#3}}
%%
%% \[
%% \gvconst{connect} : (S \lto \outterm, \gvdual{S} \lto T) \lto T
%% \]
%%
%% Syntactic sugar:
%% \begin{align*}
%% \con{M}{x}{N} &\defiff \gvconst{connect}(\lambda x.M, \lambda x.N) \\
%% \con{L}{x}{\con{M}{y}{N}} &\defiff \con{L}{x}{(\con{M}{y}{N})} \\
%% \end{align*}
%%
%% Equivalences ($\equiv$ is the transitive, reflexive, symmetric closure of the following rules):
%% \begin{align*}
%% \gvconst{link}\,(x,y) &\equiv \gvconst{link}\,(y,x) \\
%% \con{L}{x}{\con{M}{y}{N}} &\equiv \con{M}{y}{\con{L}{x}{N}} \\
%% \con{L}{x}{\con{M}{y}{N}} &\equiv \con{(\con{L}{x}{M})}{y}{N} \\
%% %\con{L}{x}{\con{M}{y}{N}} &\equiv \con{(\con{M}{x}{L})}{y}{N} \\
%% \end{align*}
%%
%% Interesting reductions
%% \begin{align*}
%% \con{E[\gvconst{send}\,(V,x)]}{x}{E'[\gvconst{receive}\,x]}
%%   &\rto \con{E[x]}{x}{E'[(V,x)]} \\
%% \con{E[\gvconst{receive}\,x]}{x}{E'[\gvconst{send}\,(V,x)]}
%%   &\rto \con{E[(V,x)]}{x}{E'[x]} \\[1ex]
%% \con{x}{x}{E[\gvconst{wait}\,x]}
%%   &\rto E[()] \\
%% \con{E[\gvconst{wait}\,x]}{x}{x}
%%   &\rto E[()] \\[1ex]
%% \con{E[\gvconst{link}\,(x,y)]}{x}{M}
%%   &\rto \con{E[x]}{x}{(\gvconst{wait}\,x; M[y/x])} \\
%% \con{M}{x}{E[\gvconst{link}\,(x,y)]}
%%   &\rto \con{(\gvconst{wait}\,x; M[y/x])}{x}{E[x]} \\[1ex]
%% \gvconst{link}\,(x,\gvconst{link}\,(y,z))
%%   &\rto \gvconst{wait}\,x; \gvconst{link}\,(y,z) \\
%% E[\con{M}{x}{N}]
%%   &\rto \con{M}{x}{E[N]} \\
%% \end{align*}
%%
%% An alternative is to remove the final commuting conversion rule and augment the notion of value to
%% include a suitable representation of a collection of blocked communicating processes.
%%
%% Preservation
%% \begin{theorem}
%% If $\Gamma \vdash M : T$ and $M \rto N$ then $\Gamma \vdash N : T$.
%% \end{theorem}
%% %
%% \begin{proof}
%% By induction on the structure of the derivation of $\Gamma \vdash M : T$ using a standard
%% substitution lemma for the case of $\beta$-reduction at function types. \qed
%% \end{proof}
%%
%% Progress
%% \begin{theorem}
%% \label{thm:free-progress}
%% If $\Gamma$ is a session environment (all variables in $\Gamma$ have session type) such that $\Gamma
%% \vdash M : T$ then one of the following holds:
%% \begin{enumerate}
%% \item $M$ is a value; or
%% \item there exists $N = \blockedp'(y_1, M_1) \rpar{x_1} \dots \rpar{x_{n}} \blockedp'(y_{n}, M_{n})$
%%   such that $M \equiv N$ and $\Gamma \vdash N : T$; or
%% \item there exists $N$ such that $M \rto N$.
%% \end{enumerate}
%% \end{theorem}
%% %
%% \begin{proof}
%% By induction on the structure of the derivation of $\Gamma \vdash M : T$. \qed
%% \end{proof}
%% % In the second case each $y_i$ must be equal to either $x_i$ or some $x$ in $\Gamma$.
%%
%% \begin{theorem}
%% If $\vdash M : T$ then one of the following holds:
%% \begin{enumerate}
%% \item $M$ is a value; or
%% \item there exists $N = \blockedp(x_1, M_1) \rpar{x_1} \dots \rpar{x_{n-1}} \blockedp(x_{n-1},
%%   M_{n-1}) \rpar{x_n} V$ such that $M \equiv N$ and $\Gamma \vdash N : T$; or
%% \item there exists $N$ such that $M \rto N$.
%% \end{enumerate}
%% \end{theorem}
%% %
%% \begin{proof}
%% By induction on the structure of the derivation of $\vdash M : T$ using
%% \thmref{free-progress}. \qed
%% \end{proof}
%%
%% $\blockedp(x, M)$ means $M$ is blocked on a send or receive involving $x$.
%%
%% $\blockedp'(x, M)$ means either $M = x$ or $M$ is blocked on a send, receive, link, or wait
%% involving $x$.

\section{Linear Logic}\label{sec:cp}

\subsection{CP}

\todo{This section (particularly the text) needs quite a bit of tidying}

\begin{figure}[float]

\begin{mathpar}
\inferrule{ }{\cptyp{\link{x}{w}}{x:A,w:\cpdual{A}}}

\inferrule{\cptyp{P}{\Gamma,y:A} \\
           \cptyp{Q}{\Delta,y:\cpdual{A}}}
          {\cptyp{\cut{y}{A}{P}{Q}}{\Gamma,\Delta}}

\inferrule{ }{\cptyp{x[].0}{x:1}}

\inferrule{\cptyp{P}{\Gamma,y:A,x:B}}
          {\cptyp{x(y).P}{\Gamma,x:A \parr B}}

\inferrule{\cptyp{P}{\Gamma,y:A} \\
           \cptyp{Q}{\Delta,x:B}}
          {\cptyp{x[y].(P \mid Q)}{\Gamma,\Delta,x:A \otimes B}}

\inferrule{\cptyp{P}{\Gamma}}
          {\cptyp{x().P}{\Gamma,x:\bot}}

\inferrule{\cptyp{P}{\Gamma,x:A_i}}
          {\cptyp{\sel{x}{in_i}.P}{\Gamma,x:A_1 \oplus A_2}}

\inferrule{\cptyp{P}{\Gamma,x:A} \\
           \cptyp{Q}{\Gamma,x:B}}
          {\cptyp{\case{x}{P;Q}}{\Gamma,x:A \with B}}

\inferrule{ }{\cptyp{\case{x}{}}{\Gamma,x:\top}}
\end{mathpar}

\caption{Typing Rules for CP}\label{fig:cp-typing}
\end{figure}

The types of CP are the propositions of classical linear logic.
%
\[\begin{array}{@{}l@{~}r@{~}c@{~}l@{}}
  \text{Types} & A,B & ::= & A \otimes B \mid A \parr B \mid 1 \mid \bot \mid A \oplus B \mid A \with B \mid 0 \mid \top \\
\end{array}\]
CP adopts the standard notion of classical linear logic duality:
\[
\ba{@{}c@{\qquad}c@{\qquad}c@{\qquad}c@{}}
\begin{eqs}
  \cpdual{(A \otimes B)} &=& \cpdual{A} \parr \cpdual{B} \\
  \cpdual{(A \parr B)} &=& \cpdual{A} \otimes \cpdual{B} \\
\end{eqs}
&
\begin{eqs}
  \cpdual{1} &=& \bot \\
  \cpdual{\bot} &=& 1 \\
\end{eqs}
&
\begin{eqs}
  \cpdual{(A \oplus B)} &=& \cpdual{A} \with \cpdual{B} \\
  \cpdual{(A \with B)} &=& \cpdual{A} \oplus \cpdual{B} \\
\end{eqs}
&
\begin{eqs}
  \cpdual{\top} &=& 0 \\
  \cpdual{0} &=& \top \\
\end{eqs}
\ea
\]
where $X^{\perp\perp} = X$.
%
We let $\Gamma, \Delta$ range over type environments. The judgement $\cptyp{P}{\Gamma}$ states that
process $P$ uses channels $\Gamma$.
%
Typing rules for CP terms are given in Fig.~\ref{fig:cp-typing}. We write $fv(P)$ for the free
variables used in process $P$; in the typing rules, new bound variables are designated $y$.

\paragraph{Structural Rules.}

CP has two structural rules, axiom and cut. We interpret the axiom $\link{x}{w}$ as channel
forwarding: actions on channel $x$ are mirrored on $w$, and vice versa. Thus, $x$ and $w$ must have
dual type. Cut $\cut{y}{A}{P}{Q}$ is interpreted as communication between processes $P$ and $Q$ on
channel $y$; the duality of the typing of $y$ assures that its uses in $P$ and $Q$ are
compatible. We identify CP terms up to structural equivalence:
%
\begin{equations}
  \link{x}{w} &\equiv& \link{w}{x} \\
  \cut{y}{A}{P}{Q} &\equiv& \cut{y}{\cpdual{A}}{Q}{P} \\
  \cut{y}{A}{P}{\cut{z}{B}{Q}{R}} &\equiv& \cut{z}{B}{\cut{y}{A}{P}{Q}}{R}, \quad \text{if $y \not\in fv(R)$} \\
\end{equations}%
%
\begin{mathpar}
\inferrule
  {P_1 \equiv P_2}
  {\cut{x}{}{P_1}{Q} \equiv \cut{x}{}{P_2}{Q}}
\end{mathpar}

We take $\equiv$ to be the least equivalence relation that is closed under these rules.

\paragraph{Input and Output.}

The multiplicative connectives $\parr$ and $\otimes$ are interpreted as input and output. The
process $x(y).P$ inputs channel $y$ on channel $x$, and continues as $P$. The process $x[y].(P \mid
Q)$ is interpreted as bound output: it sends a fresh variable $y$ along $x$, spawns a process $P$ in
which $y$ is used, and continues as process $Q$ in which $x$ is used.  It amounts to the
$\pi$-calculus term $(\nu y) \overline{x}(y).(P \mid Q)$. We write $x[y].P$ as syntactic sugar for
$x[y'].(\link{y}{y'} \mid P)$. The units of $\parr$ and $\otimes$, $\bot$ and $1$, are interpreted
as nullary input and nullary output, respectively.

\paragraph{Selection and Choice.}

The additive connectives $\oplus$ and $\with$ are interpreted as selection and choice. The process
$\case{x}{P_1;P_2}$ offers a choice of processes $P_1$ and $P_2$; dually, the process
$\sel{x}{in_i}.P_i$ chooses the $i$-th alternative. The unit for choice is $0$, indicating
absurdity. Note that there is no term proving $0$. The dual of absurdity is $\top$, and provides
arbitrary behavior; as there is no term proving $0$, no term relying on $\top$ can reduce.

\subsection{Cut Elimination}


\begin{figure}[float]

\begin{equations}
\cut{x}{A}{\link{w}{x}}{P}
  &\rto& P[w/x] \\
\cut{x}{A \otimes B}{x[y].(P \mid Q)}{x(y).R}
  &\rto&
    \cut{y}{A}{Q}{\cut{x}{B}{P}{R}} \\
\cptyp{\cut{x}{1}{x[].0}{x().P}}{\Gamma}
  &\rto&
    P \\
\cut{x}{A \oplus B}{\sel{x}{in_i}.P}{\case{x}{Q_1; Q_2}}
  &\rto&
    \cut{x}{A}{P}{Q_i} \\
\end{equations}%
\caption{Principal Cut Elimination Rules}\label{fig:beta-reduction}

\end{figure}

Cut elimination corresponds to synchronous process reduction.  The principal cut reductions are
given in Fig.~\ref{fig:beta-reduction}. These are quite standard; for instance, cut reduction of
$\with$ against $\oplus$ corresponds to picking one of the offered alternatives.

\begin{mathpar}
\inferrule
  {P_1 \longrightarrow P_2}
  {\cut{x}{}{P_1}{Q} \longrightarrow \cut{x}{}{P_1}{Q}}
\end{mathpar}

\begin{figure}[float]

\begin{equations}
  \cut{z}{A}{x[y].(P \mid Q)}{R} &\rto& x[y].(\cut{z}{A}{P}{R} \mid Q), \qquad \text{if $z \not\in fv(Q)$} \\
  \cut{z}{A}{x[y].(P \mid Q)}{R} &\rto& x[y].(P \mid \cut{z}{A}{Q}{R}), \qquad \text{if $z \not\in fv(P)$} \\
  \cut{z}{A}{x(y).P}{Q} &\rto& x(y).\cut{z}{A}{P}{Q} \\
  \cut{z}{A}{\sel{x}{in_i}.P}{Q} &\rto& \sel{x}{in_i}.\cut{z}{A}{P}{Q} \\
  \cut{z}{A}{\case{x}{P;Q}}{R} &\rto& \case{x}{\cut{z}{A}{P}{R}; \cut{z}{A}{Q}{R}} \\
\end{equations}
\caption{Commuting Conversions}\label{fig:commuting}
\end{figure}

The commuting conversions push communication under process prefixes, and are given in
Fig.~\ref{fig:commuting}.

\todo{Think carefully about what to do with commuting conversions.}

\subsection{A Simpler Send}

\todo{Make this description clearer}

The CP send rule is appealing because if one erases the terms it is exactly the classical linear
logic rule for tensor. However, this correspondence comes at a price. Operationally, the process
$x[y].(P \mid Q)$ does three things: it introduces a fresh variable $y$, it sends $y$ to a freshly
spawned process $P$, and in parallel it continues as process $Q$.
%
This is painful on many levels, but in particular it complicates our attempts to relate the
semantics of CP with that of GV (whose send operator only does one thing: performing a send).

Fortunately, we can give an alternative rule for send, corresponding with the send operator of GV,
and which gives rise to a system which is entirely equivalent to CP, apart from having a slightly
different syntax.
%
\begin{mathpar}
\inferrule
  {\cptyp{P}{\Gamma,x:B,y:A}}
  {\cptyp{x[y].P}{\Gamma,x:A \otimes B,y:\cpdual{A}}}
\end{mathpar}
The cut rule for a send against a receive is straightforward:
\begin{equations}
\cut{x}{A \otimes B}{x[y].P}{x(y).Q} &\rto& \cut{x}{B}{P}{Q} \\
\end{equations}
%
For clarity let us refer to the original form as cut-send, and the one we have just defined as send.

It we take send as primitive, then we can express cut-send as a macro:
\[
x[y].P \defeq x[z].(\link{y}{z} \mid P)
\]
Conversely, if we take cut-send as primitive, then we can express send as a macro:
\[
x[y].(P \mid Q) \defeq \cut{y}{}{P}{x[y].Q}
\]

With cut-send as primitive we can simulate a cut of a send against a receive in two steps.
\begin{equations}
  \cut{x}{}{x[y].P}{x(y).Q}
    &\defeq& \cut{x}{}{x[z].(\link{y}{z} \mid P)}{x(y).Q} \\
    &\rto& \cut{z}{}{\link{y}{z}}{\cut{x}{}{P}{Q}} \\
    &\rto& \cut{x}{}{P}{Q} \\
\end{equations}

With send as primitive we can simulate a cut of a cut-send against a receive in one step.
\begin{equations}
  \cut{x}{}{x[y].(P \mid Q)}{x(y).R}
    &\defeq& \cut{x}{}{\cut{y}{}{P}{x[y].Q}}{x(y).R} \\
    &\equiv& \cut{y}{}{P}{\cut{x}{}{x[y].Q}{x(y).R}} \\
    &\rto& \cut{y}{}{P}{\cut{x}{}{Q}{R}} \\
\end{equations}

Using these two observations it is straightforward to show that CP with send is equivalent to CP
with cut-send. In order to simplify our formal development, we will work with CP with send from now
on.

\todo{I'm not sure whether or not we want to include the next bit.}

However, there is a slightly subtlety.
%
Let us consider the possible reductions on the representation of cut-send in terms of send. Let $P_1
= x[y].(P \mid Q)$ and $P_2 = \cut{y}{}{P}{x[y].Q}$. Notice that $P_1$ is blocked, but $P_2$ may not
be as it allows reductions to take place inside $P$.
%
Now let us consider the possible reductions on the representation of send in terms of cut-send. Let
$Q_1 = x[y].P$ and $Q_2 = x[z].(\link{y}{z} \mid P)$. Clearly both $Q_1$ and $Q_2$ are blocked.
%
This discrepancy, suggests that perhaps we should have added the following congruence rule to CP in
the first place:
\begin{mathpar}
\inferrule
  {P_1 \longrightarrow P_2}
  {x[y].(P_1 \mid Q) \longrightarrow x[y].(P_2 \mid Q)}
\end{mathpar}
%

\todo{Do we want to state anything more formal relating CP-cut-send with CP-send?}

\subsection{Translation from CP to GV}

We now present the translation $\togv{-}$ from CP to GV. On types:
\[
\ba{@{}c@{\qquad}c@{\qquad}c@{}}
\begin{eqs}
\togv{A \otimes B} &=& \gvout{\gvdual{\togv{A}}}{\togv{B}} \\
\togv{A \parr B}   &=& \gvin{\togv{A}}{\togv{B}} \\
\end{eqs}
&
\begin{eqs}
\togv{1}           &=& \outterm \\
\togv{\bot}        &=& \interm \\
\end{eqs}
&
\begin{eqs}
\togv{+\{l_i:A_i\}_i}     &=& +\{l_i:\togv{A_i}\}_i  \\
\togv{\with\{l_i:A_i\}_i} &=& \with\{l_i:\togv{A_i}\}_i \\
\end{eqs}
\ea
\]
%
The translation on type environments is defined pointwise. Figure~\ref{fig:fromcp} gives a
translation from CP terms to GV terms ($\togv{-}$) and a translation from CP terms to GV
configurations ($\togvc{-}$).

\begin{figure}[float]
\begin{equations}
  \togv{\cut{x}{}{P}{Q}} &=&
    \gvlet{x}{\gvfork{x}{\togv{P}}}{\togv{Q}} \\
  \togv{\link{x}{y}} &=& \gvlet{z}{\gvlink{x}{y}}{z} \\
  %% \togv{x[y].(P \mid Q)} &=&
  %%   \gvlet{y}{\gvfork{y}{\togv{P}}}{\gvlet{x}{\gvsend{(y, x)}}{\togv{Q}}} \\
  \togv{x[y].P} &=&
    \gvlet{x}{\gvsend{(y, x)}}{\togv{P}} \\
  \togv{x(y).P} &=&
    \gvlet{(y,x)}{\gvreceive{x}}{\togv{P}} \\
  \togv{x[].0} &=& x \\
  \togv{x().P} &=& \gvlet{()}{\gvwait{x}}{\togv{P}} \\
  \togv{\sel{x}{\mathit{l}}.P} &=&
    \gvlet{x}{\gvselect{l}{x}}{\togv{P}} \\
  \togv{\case{x}{l_i.P_i}_i} &=&
    \gvcase{x}{l_i.\togv{P_i}}_i
\medskip
\\
  \togvc{\cut{x}{}{P}{Q}} &=&
    (\nu x)(\togvc{P} \parallel \togvc{Q}) \\
  \togvc{P} &=& \togv{P}, \quad \text{$P$ is not a cut} \\
  %% \togvc{x[y].(P \mid Q)} &=&
  %%   (\nu y)(\togvc{P} \parallel \distinguish{\gvlet{x}{\gvsend{(y, x)}}{\togv{Q}}}) \\
  %% \togvc{P} &=& \distinguish{\togv{P}}, \quad \text{$P$ is not a cut or a send} \\
\end{equations}%

\caption{Translation of CP Terms into GV}\label{fig:fromcp}
\end{figure}

As CP processes have no return value, a CP judgement is translated to a non-returning configuration.

\begin{theorem}
If $P \vdash \Gamma$ then $\togv{\Gamma} \vdash^\wcirc \togvc{P}$.
\end{theorem}

Structural equivalence is preserved by the translation.

\begin{theorem}
If $P \equiv Q$, then $\togvc{P} \equiv \togvc{Q}$.
\end{theorem}

Every CP reduction can be simulated by one or more GV reductions.

\begin{theorem}
If $P \vdash \Gamma$ and $P \rto Q$, then $\togvc{P} \rto^+ \togvc{Q}$.
\end{theorem}


%% \subsection{Functions as Processes}
%%
%% \todo{Probably scrap this, as it turns out to be wrong.}
%%
%% Following our previous work, we show that functions in GV can be translated into processes, and in
%% particular that the translation respects the semantics.

%% \[
%% \topi{T \lto U} = \gvout{\topi{T}}{\topi{U}}
%% \]
%%
%% \begin{equations}
%% \topi{\lambda x.M} &=& \gvfork{z}{\gvlet{(x, z)}{\gvreceive{z}}{\gvlink{\topi{M}}{z}}} \\
%% \topi{L\,M}        &=& \gvsend{(\topi{M},\topi{L})} \\
%% \topi{\gvfork{x}{M}} &=& \gvfork{x}{\gvsend{(x,\topi{M})}} \\
%% \end{equations}
%%
%%
\subsection{Direct Translation from GV to CP}

\newcommand{\tocpflip}[1]{\llceil{#1}\rrceil}

\[
\ba{@{}c@{\qquad}c@{\qquad}c}
\begin{eqs}
\tocp{\zero} &=& \top \\
\tocp{\one} &=& \bot
\end{eqs}
&
\begin{eqs}
\tocp{\gvout{T}{S}}        &=& \cpdual{\tocp{T}} \otimes \tocp{S} \\
\tocp{\gvin{T}{S}}         &=& \tocp{T} \parr \tocp{S} \\
\end{eqs}
&
\begin{eqs}
\tocp{\outterm}            &=& 1 \\
\tocp{\interm}             &=& \bot \\
\end{eqs}
\ea
\]

\begin{equations}
\tocp{T} &=& \cpdual{\tocpflip{T}}, \quad \text{if $T$ is not a session type} \\
\tocpflip{T + U} &=& \tocpflip{T} \oplus \tocpflip{U} \\
\tocpflip{T \times U} &=& \tocpflip{T} \otimes \tocpflip{U} \\
\tocpflip{T \lto U} &=& \cpdual{\tocpflip{T}} \parr \tocpflip U \\
\tocpflip{S} &=& \tocp{S} \\
\end{equations}

\begin{equations}
\tocp{x}z &=& \link{x}{z} \\
\tocp{\gvconst{fork}\:(\clos{\sigma}{x}{M})}z &=&
  \tocp{\sigma}(\cut{x}{}{\cut{y}{}{\tocp{M}{y}}{y[]}}{\link x z}) \\
\tocp{\gvlink{M}{N}}z &=& \cut{x}{}{\tocp{M}x}{\cut{y}{}{\tocp{N}y}{z().\link{x}{y}}} \\
\tocp{\gvsend{(M,N)}}z &=&
  \cut{x}{}{\tocp{N}x}{\cut{y}{}{\tocp{M}y}{x\sd{y}.\link{x}{z}}} \\
%% SL: we need these eta-expanded definitions for receive and wait
%% in order for the simulation theorem to hold
\tocp{\gvreceive{M}}z &=& 
  \cut{y}{}{\tocp{M}y}{y(x).\cut{w}{}{\link{y}{w}}{z\sd{x}.\link{w}{z}}} \\
\tocp{\gvwait{M}}z    &=& 
  \cut{y}{}{\tocp{M}y}{y().z[]} \\
%% \tocp{\gvreceive{M}}z &=& \tocp{M}z \\
%% \tocp{\gvwait{M}}z    &=& \tocp{M}z \\
\tocp{\lambda^\sigma x.M}z &=& \tocp{\sigma}(z(x).\tocp{M}z) \\
\tocp{L \app M}z &=&
  \cut{x}{}{\tocp{M}x}{\cut{y}{}{\tocp{L}y}{y\sd{x}.\link{y}{z}}} \\
\tocp{()}z    &=& z[] \\
\tocp{(M,N)}z &=& \cut{x}{}{\tocp{M}x}{\cut{y}{}{\tocp{N}y}{z\sd{x}.\link{y}{z}}} \\
\tocp{\gvlet{(x,y)}{M}{N}}z &=& \cut{y}{}{\tocp{M}y}{y(x).\tocp{N}z} \\
\tocp{\gvlet{()}{M}{N}}z &=& \cut y {} {\tocp{M}y} {y().\tocp{N}z} \\
\tocp{\mkwd {inl} \app M}z &=& \cut{x}{}{\tocp{M}x}{z[\mkwd{inl}].\link{x}{z}} \\
\tocp{\mkwd {inr} \app M}z &=& \cut{x}{}{\tocp{M}x}{z[\mkwd{inr}].\link{x}{z}} \\
\tocp{\gvcase{L}{\mkwd {inl} \app x \mapsto M;
                 \mkwd {inr} \app x \mapsto N}}z &=&
   \cut x {} {\tocp{L}x} {\case{x}{\mkwd{inl} \mapsto \tocp{M}z;
                                   \mkwd{inr} \mapsto \tocp{N}z}} \\
\tocp{\mkwd{absurd} \app L}z &=& \cut x {} {\tocp{L}x} {\mkwd{case}\app x \app \{ \}}
\medskip
\\
\tocp{[x_i \mapsto V_i]_i}P &=& \hat{\nu}(x_i \mapsto \tocp{V_i}x_i)[P] \\
\\
\hat{\nu}(x_i \mapsto P_i)_i[P] &\defeq& \cut{x_1}{}{P_1}{\dots \cut{x_n}{}{P_n}{P}\dots}
\end{equations}

\todo{Sort out how we deal with constants. Currently our translation of fork doesn't make sense - it
  should be a translation of fork M. The translations of link (M, N) and send (M, N) are OK if we
  insist constants are always fully applied. But perhaps we can reasonably change them to
  translations of link M and send M.}

\todo{Actually, this translation is looser than we need. It captures call-by-value, but doesn't
  enforce left-to-right evaluation of applications and pairs. Is this what we want?}

\todo{In fact we can get away with the simpler definition for wait - perhaps we should?}

\begin{equations}
\tocp{M}z                &=& \cut{y}{}{\tocp{M}y}{y[]} \\
\tocp{\distinguish M}z   &=& \tocp{M}z \\
\tocp{(\nu x)C}z         &=& \tocp{C}z \\
\tocp{C \parallel_x C'}z &=& \cut{x}{}{\tocp{C}z}{\tocp{C'}z} \\
%% \tocpbig{
%%   \inferrule
%%     {\Gamma,x:S \vdash^{\phi} C \\
%%      \Gamma',x:\gvdual{S} \vdash^{\phi'} C'}
%%     {\Gamma,\Gamma',x:\channel{S} \vdash^{\phi + \phi'} C \parallel C'}}z &=&
%%     \bl
%%     \cut{x}{}{\tocp{C_1}z}{\cut{y}{}{\tocp{C_2}y}{y[]}} \\
%%     \quad \text{where }C_1,C_2 =
%%     \left\{
%%       \ba{l}
%%        C,C' \quad \text{if }\phi = \bcirc \\
%%        C',C \quad \text{otherwise} \\
%%       \ea \right. \\
%%     \el \\
  %% \left\{
  %%   \ba{l}
  %%   \cut{x}{}{\cut{y}{}{\tocp{C}y}{y[]}}{\tocp{C'}z} \\
  %%   \qquad\text{if $\phi' = \bcirc$;} \\
  %%   \cut{x}{}{\tocp{C}z}{\cut{y}{}{\tocp{C'}y}{y[]}} \\
  %%   \qquad\text{otherwise.}
  %%   \ea \right.
\end{equations}

\paragraph{Type soundness}

\begin{theorem}
  If $\Gamma \vdash M : T$, then $\tocp{M}z \vdash \tocp{\Gamma}, z:\cpdual{\tocp{T}}$.
\end{theorem}
\begin{proof}
By induction on the derivation of $\Gamma \vdash M : T$.\qed
\end{proof}

\begin{theorem}
  If $\Gamma \vdash C$, then $\tocp{C}z \vdash \tocp{\Gamma}, z:\cpdual{\tocp{T}}$.
\end{theorem}
\begin{proof}
By induction on the derivation of $\Gamma \vdash C$.\qed
\end{proof}

\paragraph{Semantic soundness}

\begin{theorem}
If $\Gamma \vdash C \equiv D$, then $\tocp{C}z \equiv \tocp{D}z$.
\end{theorem}
%
\begin{proof}
By induction on the derivation of $\Gamma \vdash C$.\qed
\end{proof}

As the translation on terms and configurations are compositional, we can mechanically lift them to
translations on evaluation contexts and configuration contexts, such that the following lemma holds
by construction.
%
%% In order to ease reasoning by induction, we lift the translation on terms to contexts.
%% \begin{equations}
%% \tocp{\Ex}[\Ex{M}]z &=& \tocp{\Ex[M]}z \\
%% \tocp{\Fx}[\Fx{M}]z &=& \tocp{\Fx[M]}z \\
%% \tocp{\Gx}[\Gx{M}]z &=& \tocp{\Gx[M]}z \\
%% \end{equations}
%% That these equations are well-defined follows from compositionality of the translation on terms.
%% The following lemmas can be made to hold, by construction.
%
\begin{lemma}
~
\begin{enumerate}
\item $\tocp{\Ex[M]}z = \tocp{\Ex}[\tocp{M}]z$
\item $\tocp{\Fx[M]}z = \tocp{\Fx}[\tocp{M}]z$
\item $\tocp{\Cx[C]}z = \tocp{\Cx}[\tocp{C}]z$
\end{enumerate}
\end{lemma}
Each translation of a context takes two arguments: a function that describes the CP term to plug
into the hole, and an output channel.

\todo{Perhaps include the full definitions in an appendix?}

In order to prove that reduction is preserved by the translation we need a substitution lemma.
\begin{lemma}
\label{lem:tocp-subst}
If $\Gamma \vdash M : T$, $\Gamma \vdash \sigma : \Delta$, and $z \notin \dom(\sigma)$, then
$\tocp{\sigma}(\tocp{M}z) \rto^* \tocp{\sigma(M)}z$.
\end{lemma}
\begin{proof}
By induction on the structure of $M$. Here we show the cases for variables and closures.
\begin{itemize}
\item Case $x$. By linearity there exists $V$ such that $\sigma = [x \mapsto V]$.
\[
\tocp{\sigma}(\tocp{x}z) =
\cut{x}{}{\tocp{V}x}{\link{x}{z}} \rto \tocp{V}z = \tocp{\sigma(x)}z
\]
\item Case $\clos{\sigma'}{x}{M}$.
\[
\bl
\quad \tocp{\sigma}(\tocp{\clos{\sigma'}{x}{M}}) \\
= \quad (\sigma' = [x_i \mapsto V_i]) \\
\quad \tocp{\sigma}(\hat{\nu} (x_i \mapsto (\tocp{V_i}x_i))_i[z(x).\tocp{M}z]) \\
= \quad (\sigma = \sigma_1 \uplus \dots \uplus \sigma_n \text{ where } \dom(\sigma_i) = \fv(V_i)) \\
\quad \tocp{\sigma_1}(\dots\tocp{\sigma_n} (\hat{\nu} (x_i \mapsto \tocp{V_i}x_i)_i[z(x).\tocp{M}z])) \\
= \quad (\text{structural equivalence}) \\
\quad \hat{\nu} (x_i \mapsto \tocp{\sigma_i}(\tocp{V_i}x_i))_i[z(x).\tocp{M}z] \\
\rto^* (\text{IH}) \\
\quad \hat{\nu} (x_i \mapsto \tocp{\sigma_i(V_i)}x_i)_i[z(x).\tocp{M}z] \\
= \quad (\sigma_i(V_i) = \sigma(V)) \\
\quad \hat{\nu} (x_i \mapsto \tocp{\sigma(V_i)}x_i)_i[z(x).\tocp{M}z] \\
= \quad (\text{definition of }\tocp{-}) \\
\quad \tocp{\clos{\sigma(\sigma')}{x}{M}} \\
= \quad (\text{definition of substitution}) \\
\quad \tocp{\sigma(\clos{\sigma'}{x}{M})} \\
\el
\]
\end{itemize}
Each of the remaining non-binding form cases follows straightforwardly using the induction
hypothesis. Each of the remaining binding form cases requires a commuting conversion in order to
push the appropriate substitution through a prefix.\qed
\end{proof}

%% [INLINED]
%%
%% \begin{lemma}
%% If $\tocp{M}z \rto \tocp{N}z$ then $\tocp{E}[\tocp{M}]z \rto \tocp{E}[\tocp{N}]z$.
%% \end{lemma}
%% \begin{proof}
%% This follows straightforwardly by observing that the translation of an evaluation context never
%% places its argument inside a prefix.
%% \end{proof}

\begin{theorem}
If $\Gamma \vdash M$, $\Gamma \vdash N$, and $M \teval N$, then $\tocp{M}z
\rto^* \tocp{N}v$.
\end{theorem}
%
\begin{proof}
By induction on the derivation of $M \teval N$. Here we show the case of $\beta$-reduction.
\begin{itemize}
\item Case $(\lambda^\sigma x.M)\,V \teval M(\{\bind x V\} \cup \sigma)$.
\[
\bl
\quad \tocp{(\lambda^\sigma x.M)\,V}z \\
= \quad (\text{definition of }\tocp{-}) \\
\quad \cut{w}{}{\tocp{V}w}{\cut{y}{}{\tocp{\sigma}(y(x).\tocp{M}y)}{y[x](\link{w}{x} \mid \link{y}{z})}} \\
\rto (\text{cut send against receive}) \\
\quad \cut{w}{}{\tocp{V}w}{\cut{y}{}{\link{y}{z}}{\cut{x}{}{\link{w}{x}}{\tocp{\sigma}(\tocp{M}y)}}} \\
\rto^* (\text{cut links and $\alpha$ rename}) \\
\cut{x}{}{\tocp{V}x}{\tocp{\sigma}(\tocp{M}z)} \\
= \quad (\text{by Lemma~\ref{lem:tocp-subst}}) \\
\tocp{M(\{\bind x V\} \cup \sigma)}
\el
\]
\end{itemize}
The remaining base cases are similarly direct. The inductive case for reduction inside an evaluation
context follows straightforwardly by observing that the translation of an evaluation context never
places its argument inside a prefix.\qed
\end{proof}

\begin{theorem}
If $\Gamma \vdash C$, $\Gamma' \vdash D$, $\Gamma \rto \Gamma'$, and $C \ceval D$, then $\tocp{C}z
\Longrightarrow \tocp{D}z$ where $\Longrightarrow ~\defeq~ (\equiv\rto^*\equiv)$.
\end{theorem}
\begin{proof}
By induction on the derivation of $C \ceval D$. Here we show the case of send/receive reduction.
\begin{itemize}
\item Case $\Fx[\gvconst{send} \app (V,x)] \parallel \Fx'[\gvconst{receive} \app x] \ceval \Fx[x]
  \parallel \Fx'[(V,x)]$.
%
By Lemma~\ref{bla} we need only consider the case where $\Fx = [~]$ and $\Fx' = \distinguish{[~]}$.
\[
\bl
\quad \tocp{\gvconst{send} \app (V,x) \parallel \distinguish{\gvconst{receive} \app x}}z \\
= \\
\quad \cut{x}{}
        {\cut{y}{}{\tocp{\gvconst{send} \app (V,x)}y}{y[]}}
        {\tocp{\gvconst{receive} \app x}z} \\
= \\
\quad
  \nu x(
    {\cut{y}{}{
     \cut{v}{}{\tocp{V}v}
      {\cut{w}{}{\link{x}{w}}{w\sd{v}.\link{w}{y}}}}{y[]}} \\
\qquad \mid
    {\cut{y}{}
       {\link{x}{y}}
       {y(v).\cut{w}{}{\link{y}{w}}{z\sd{v}.\link{w}{z}}}} \\
\Longrightarrow (\text{cut links}) \\
\quad
  \cut{x}{}
    {\cut{y}{}
       {\cut{v}{}{\tocp{V}v}
         {x\sd{v}.\link{x}{y}}}
       {y[]}}
    {x(v).\cut{w}{}{\link{x}{w}}{z\sd{v}.\link{w}{z}}} \\
\Longrightarrow (\text{cut send against receive}) \\
\quad
  \cut{x}{}
    {\cut{y}{}
       {\cut{v}{}{\tocp{V}v}
         {\link{x}{y}}}
       {y[]}}
    {\cut{w}{}{\link{x}{w}}{z\sd{v}.\link{w}{z}}} \\
\equiv \\
\quad 
  \cut{x}{}
    {\cut{y}{}{\link x y}{y[]}}
    {\cut{v}{}{\tocp{V}v}
      {\cut{w}{}{\link{x}{w}}
         {z\sd{v}.\link{w}{z}}}} \\
= \\
\quad
  \cut{x}{}
    {\cut{y}{}{\link x y}{y[]}}
    {\tocp{(V,x)}z} \\
= \\
\quad \cut{x}{}{\cut{y}{}{\tocp{x}y}{y[]}}{\tocp{(V,x)}z} \\
= \\
\quad \tocp{x \parallel \distinguish{(V,x)}} \\
\el
\]

%% This is what goes wrong if we don't use the convoluted translation of receive.
%% \[
%% \bl
%% \quad \tocp{\gvconst{send} \app (V,x) \parallel \distinguish{\gvconst{receive} \app x}}z \\
%% = \\
%% \quad \cut{x}{}
%%         {\cut{y}{}{\tocp{\gvconst{send} \app (V,x)}y}{y[]}}
%%         {\tocp{\gvconst{receive} \app x}z} \\
%% = \\
%% \quad 
%%   \cut{x}{}
%%     {\cut{y}{}{
%%      \cut{v}{}{\tocp{V}v}
%%       {\cut{w}{}{\link{x}{w}}{w[v].\link{w}{y}}}}{y[]}}
%%     {\link x z} \\
%% = \\
%% \quad 
%%   \cut{v}{}{\tocp{V}v}
%%     {\cut{x}{}
%%       {\cut{y}{}
%%         {\cut{w}{}{\link{x}{w}}{w[v].\link{w}{y}}}{y[]}}
%%       {\link x z}} \\
%% = \\
%% \quad 
%%   \cut{v}{}{\tocp{V}v}
%%     {\cut{y}{}
%%       {\cut{x}{}
%%         {\cut{w}{}{\link{x}{w}}{w[v].\link{w}{y}}}{\link x z}}
%%       {y[]}} \\
%% = \\
%% \quad 
%%   \cut{v}{}{\tocp{V}v}
%%     {\cut{y}{}
%%       {\cut{w}{}
%%         {\cut{x}{}
%%           {\link{x}{w}}
%%           {\link x z}}
%%         {w[v].\link{w}{y}}}
%%       {y[]}} \\

%% %% \rto^* \\
%% %% \quad 
%% %%     \cut{y}{}{
%% %%      \cut{v}{}{\tocp{V}v}
%% %%       {z[v].\link{z}{y}}}{y[]} \\
%% %% = \\
%% %% \dots \\
%% %% = \\
%% %% \quad 
%% %%   \cut{x}{}
%% %%     {x[]}
%% %%     {\cut{v}{}{\tocp{V}v}
%% %%       {z[v].\link{x}{z}}} \\
%% %% {}^*\!\longleftarrow \\
%% = ...\\
%% \quad
%%   \cut{v}{}
%%     {\tocp{V}v} 
%%     {\cut{y}{}
%%       {\cut{w}{}
%%         {\cut{x}{}
%%           {\link{x}{w}}
%%           {\link x y}}
%%         {z[v].\link{w}{z}}}
%%       {y[]}} \\
%% = \\
%% \quad
%%   \cut{v}{}
%%     {\tocp{V}v} 
%%     {\cut{y}{}
%%       {\cut{x}{}
%%         {\link x y}
%%         {\cut{w}{}{\link{x}{w}}
%%           {z[v].\link{w}{z}}}}
%%       {y[]}} \\
%% = \\
%% \quad
%%   \cut{v}{}
%%     {\tocp{V}v} 
%%     {\cut{x}{}
%%       {\cut{y}{}{\link x y}{y[]}}
%%       {\cut{w}{}{\link{x}{w}}
%%          {z[v].\link{w}{z}}}} \\
%% = \\
%% \quad 
%%   \cut{x}{}
%%     {\cut{y}{}{\link x y}{y[]}}
%%     {\cut{v}{}{\tocp{V}v}
%%       {\cut{w}{}{\link{x}{w}}
%%          {z[v].\link{w}{z}}}} \\
%% = \\
%% \quad
%%   \cut{x}{}
%%     {\cut{y}{}{\link x y}{y[]}}
%%     {\tocp{(V,x)}z} \\
%% = \\
%% \quad \cut{x}{}{\cut{y}{}{\tocp{x}y}{y[]}}{\tocp{(V,x)}z} \\
%% = \\
%% \quad \tocp{x \parallel \distinguish{(V,x)}} \\
%% \el
%% \]

\item Case $(\nu x)(\phi \Ex[\gvconst{wait} \app x] \parallel \phi' x) \ceval ()$.
\[
\bl
\quad \tocp{(\nu x)(\phi E[\gvconst{wait} \app x] \parallel \phi' E[x])}z \\
= \\
\quad \cut{x}{}{\tocp{\phi E}[y \mapsto \tocp{\gvconst{wait} \app x}y]z}
               {\tocp{\phi'}[y \mapsto \tocp{x}{y}]z} \\
= \\
\quad \cut{x}{}{\tocp{\phi E}[y \mapsto \cut{w}{}{\link x w}{w().y[]}]z}
               {\tocp{\phi'}[y \mapsto \link x y]z} \\
\Longrightarrow (\text{cut links and cut end channels}) \\
\quad \tocp{(\phi + \phi') E}[y \mapsto y[]]z \\
= \\
\quad \tocp{(\phi + \phi') E[()]}z
\el
\]
\item Case $\Fx[\gvconst{fork} \app (\clos{\sigma}{x}{M})]
                      \ceval (\nu x)(\Fx[x] \parallel M\sigma)$.
\[
\bl
\quad \tocp{\Fx[\gvconst{fork} \app (\clos{\sigma}{x}{M})]}z \\
= \\
\quad \tocp{\Fx}[\tocp{\gvconst{fork} \app (\clos{\sigma}{x}{M})}]z \\
= \\
\quad \tocp{\Fx}[z \mapsto
         \tocp{\sigma}
            (\cut{x}{}
               {\cut{y}{}
                 {\tocp{M}{y}}{y[]}}
                 {\tocp{x}z})]z \\
\equiv \\
\quad \cut{x}{}
        {\tocp{\Fx}[\tocp{x}]z}
        {\tocp{\sigma}(\tocp{\cut{y}{}{\tocp{M}y}{y[]}})} \\
%% = \\
%% \quad \cut{x}{}
%%         {\tocp{\Fx}[\tocp{x}]z}
%%         {\tocp{\sigma}(\tocp{\wcirc}[\tocp{M}]z)} \\
= \\
\quad \tocp{(\nu x)(\Fx[x] \parallel M\sigma)}z \\
\el
\]

Case $(\nu x) (\Fx[\gvconst{link} \app (x, y)] \parallel \Fx'[M]) \ceval
        (\nu x)(\Fx[x] \parallel \Fx'[\gvletunit{\gvconst{wait} \app x}{M\{y/x\}}])$.
\dots
%% \[
%% \bl
%% \quad \tocp{(\nu x) (\Fx[\gvconst{link} \app (x, y)] \parallel \Fx'[M])}z \\
%% = \\
%% \quad \cut{x}{}
%%          {\tocp{\Fx}[\tocp{\gvconst{link} \app (x, y)}]z}
%%          {\tocp{\Fx'}[\tocp{M}]z} \\
%% = \\
%% \quad \tocp{(\nu x)(\Fx[x] \parallel \Fx'[\gvletunit{\gvconst{wait} \app x}{M\{y/x\}}])}z
%% \el
%% \]

\end{itemize}
\end{proof}




\paragraph{Why we need closures}

One might hope that reduction in GV without closures would be preserved by the translation to
CP. However, it turns out that this is not the case. Consider the following straightforward
$\beta$-reduction:
\[
  \tocp{(\lambda x.\lambda y.\gvwait{y}; x) \app ()}z \teval \lambda y.\gvwait{y}; ()
\]
Translating the left-hand side yields:
\[
\bl
\quad \tocp{(\lambda x.\lambda y.\gvwait{y}; x) \app ()}z \\
= \\
\quad \cut{w}{}{w(x).\tocp{\lambda y.\gvwait{y; x}w}}{\cut{x}{}{\tocp{()}x}{y[x].\link{y}{z}}} \\
\equiv \\
\quad \cut{w}{}{w(x).w(y).y().\link{x}{w}}{\cut{x}{}{x[]}{w[x].\link{w}{z}}} \\
\equiv \\
\quad \cut{x}{}{x[]}{\cut{w}{}{w(x).w(y).y().\link{x}{w}}{w[x].\link{w}{z}}} \\
\rto \\
\quad \cut{x}{}{x[]}{\cut{w}{}{w(y).y().\link{x}{w}}{\link{w}{z}}} \\
\rto \\
\quad \cut{x}{}{x[]}{z(y).y().\link{x}{z}} \\
\rto^* (\text{commuting conversions}) \\
\quad z(y).y().\cut{x}{}{x[]}{\link{x}{z}} = P \\
\el
\]
Translating the right-hand side yields:
\[
\bl
\quad \tocp{\lambda y.\gvwait{y}; ()} \\
= \\
\quad z(y).y().z[] = Q
\el
\]

Alas, $P$ does not reduce to $Q$.
%
Notice that we could reduce $P$ to $Q$ if we were allowed to reduce under a prefix.

As we have shown previously, we can translate a term $P$ from CP to GV and back, perform some
reductions, and arrive back at $P$.
\begin{theorem}
$\cut{z}{}{\togv{\tocp{P}}z}{z[]} \rto^* P$
\end{theorem}

%% \paragraph{Some results that hold, but may be of no use}

%% \begin{theorem}
%% If $\Gamma \vdash C \equiv D$, then $\tocp{C}z \equiv \tocp{D}v$.
%% \end{theorem}
%% %
%% The following lemmas can be made to hold, by construction.
%% %
%% \begin{lemma}
%% $\tocp{\Ex[M]}z = \tocp{\Ex}[\tocp{M}]z$
%% \end{lemma}

%% \begin{lemma}
%% $\tocp{\Fx[M]}z = \tocp{\Fx}[\tocp{M}]z$
%% \end{lemma}

%% \begin{lemma}
%% $\tocp{\Cx[C]}z = \tocp{\Cx}[\tocp{C}]z$
%% \end{lemma}

%% \paragraph{A whole load of results that do not hold}

%% \begin{lemma}
%% $\cut{x}{}{\tocp{M}z}{\tocp{V}x} \rto^* \tocp{M[V/x]}z$
%% \end{lemma}

%% \begin{theorem}
%% If $\Gamma \vdash M$, $\Gamma \vdash N$, and $M \teval N$, then $\tocp{M}z
%% \rto^* \tocp{N}v$.
%% \end{theorem}

%% \begin{theorem}
%% If $\Gamma \vdash C$, $\Gamma' \vdash D$, $\Gamma \rto \Gamma'$, and $C \ceval D$, then $\tocp{C}z
%% \rto^* \tocp{D}v$.
%% \end{theorem}



%% OK. Bugger this. The substitution lemma is false.

%%     nu x.([[\y.wait y; x]]z | [[()]]x)
%%   =
%%     nu x.(z(y).y().x <-> z | x[])

%% But

%%   [[\y.wait; ()]]z = z(y).y().z[]

%% Similarly, the main theorem is false.

%%     [[(\x.\y.wait y; x)()]]z
%%   -->*
%%     nu x(z(y).y().x <-> z | x[])

%% But

%%   [[\y.wait y; ()]]z = z(y).y.z[]

%% \subsection{Indirect Translation from GV to CP}
%%
%%
%% \todo{ANF translation.}
%%
%% \todo{Ensure that the definition of $\equiv$ is appropriate for the theorems.}
%%
%% \todo{Show that the A-normalisation rules are sound (easy).}
%%
%% Attempt at the ANF syntax.  Should we pick a new letter for ANF terms? [SL: No.]
%%
%% [SL: I fixed some bugs in the ANF syntax]
%%
%% \begin{syntax}
%%   \text{Terms} & M,N & ::= & V \mid \gvlet{x}{V \app W}{N} \\
%%   & & \mid & \gvlet{(x,y)}{V \app W}{N} \mid \gvletunit{V \app W}{N} \\
%%   & & \mid & \gvcase{V}{\mkwd{inl}\,x \mapsto N; \mkwd{inr}\,x \mapsto N} \\
%%   & & \mid & \gvconst{absurd} \app V \\
%% \end{syntax}
%%
%% \small\[
%% \ba{@{}c@{\qquad}c@{\qquad}c@{\qquad}c}
%% \begin{eqs}
%% \tocp{T + U} &=& \tocp{T} \with \tocp{U} \\
%% \tocp{T \times U} &=& \tocp{T} \parr \tocp{U} \\
%% \tocp{T \lto U} &=& \cpdual{\tocp{T}} \otimes \tocp U
%% \end{eqs}
%% &
%% \begin{eqs}
%% \tocp{\zero} &=& \top \\
%% \tocp{\one} &=& \bot
%% \end{eqs}
%% &
%% \begin{eqs}
%% \tocp{\gvout{T}{S}}        &=& \cpdual{\tocp{T}} \otimes \tocp{S} \\
%% \tocp{\gvin{T}{S}}         &=& \tocp{T} \parr \tocp{S} \\
%% \end{eqs}
%% &
%% \begin{eqs}
%% \tocp{\outterm}            &=& 1 \\
%% \tocp{\interm}             &=& \bot \\
%% \end{eqs}
%% %&
%% %\begin{eqs}
%% %\tocp{\oplus \{l_i:S_i \}_i} &=& \oplus \{l_i:\tocp{S_i}\}_i \\
%% %\tocp{\with \{l_i:S_i \}_i}  &=& \with \{l_i:\tocp{S_i}\}_i \\
%% %\tocp{\gvservice{S}}       &=& \cpquery{\tocp{S}} \\
%% %\tocp{\gvserver{S}}        &=& \cpbang{\tocp{S}} \\
%% %\end{eqs}
%% \ea
%% \]\normalsize
%%
%% \small\begin{equations}
%% \tocp{x}z &=& \link{x}{z} \\
%% \tocp{\lambda x.N}z &=& z(x).\tocp{N}z \\
%% \tocp{\gvlet{y}{V \app W}{N}}z &=&
%%   \bl
%%     \cut y {} {\cut x {} {\tocp{V}x} {x[z].(\tocp{W}z \mid \link x y)}} {\tocp{N}z} \\
%%     \text{if $V$ is not a constant $K$}
%%   \el \\
%% \tocp{(V,W)}z &=& z[y].(\tocp{V}y \mid \tocp{W}z) \\
%% \tocp{\gvlet{(x,y)}{V}{N}}z &=& \cut y {} {\tocp{V}y} {y(x).\tocp{N}z} \\
%% \tocp{\mkwd {inl} \app V}z &=& z[\mkwd{inl}].\tocp{V}z\\
%% \tocp{\gvcase V {\mkwd {inl} \app x \mapsto M; \mkwd {inr} \app x \mapsto N}}z &=&
%%    \cut x {} {\tocp{V}x} {\mkwd{case} \app x \app \{ \mkwd{inl} \mapsto \tocp{M}z; \mkwd{inr} \mapsto \tocp{N}z \}} \\
%% \tocp{\mkwd{absurd} \app V}z &=& \cut x {} {\tocp{V}x} {\mkwd{case}\app x \app \{ \}} \\
%% \tocp{\gvlet{x}{\gvsend{(V,W)}}{N}}z &=& \cut{x}{}{\tocp{W}x}{\cut y {} {\tocp{V}y} {x[y].\tocp{N}z}} \\
%% \tocp{\gvlet{(x,y)}{\gvreceive{V}}{N}}z &=& \cut{y}{}{\tocp{V}y}{y(x).\tocp{N}z} \\
%% \tocp{\gvlet{()}{\gvconst{wait} \app V}{N}}z &=& \cut y {} {\tocp{V}y} {y().\tocp{N}z} \\
%% \tocp{\gvlet{x}{\gvfork{x}{M}}{N}}z &=& \cut{x}{}{\cut{y}{}{\tocp{M}y}{y[].0}}{\tocp{N}z} \\
%% \tocp{\gvlet{x}{\gvlink{V}{W}}{N}}z &=& \cut x {} {x().\cut y {} {\tocp{V}y} {\tocp{W}y}} {\tocp{N}z} \\
%% \end{equations}\normalsize
%%
%% \begin{theorem}
%%   If $\Gamma \vdash M: T$, then $\tocp{M}z \vdash \tocp{\Gamma}, z:\tocp{T}^\perp$.
%% \end{theorem}
%%
%% \begin{proof}
%%   By structural induction on the derivation of $\Gamma \vdash M: T$.  Representative cases follow.
%%   \begin{itemize}
%%   \item In case $M = x$, we must have $\Gamma = \{x:T\}$; we can directly conclude that $\link x z
%%     \vdash x:T,z:\cpdual T$.
%%   \item In case $M = \lambda x.N$, where $T = U \lto U'$, the induction hypothesis provides that
%%     $\tocp{N}z \vdash \tocp{\Gamma},x:\tocp{U},z:\cpdual{\tocp{U'}}$.  Therefore, from the rule for
%%     $\parr$ and the observation that $\cpdual{\tocp{U \lto U'}} = \tocp U \parr \cpdual{\tocp {U'}}$, we can
%%     conclude that $z(x).\tocp{N}z \vdash \tocp{\Gamma}, z:\cpdual{\tocp{U \lto U'}}$.
%%   \item In case $M = \mkwd{inl} \app V$, where $T = U + U'$, the induction hypothesis provides that
%%     $\tocp{V}z \vdash \tocp{\Gamma}, z:\cpdual{\tocp{U}}$.  Therefore, from the rule for $\oplus$
%%     and the observation that $\cpdual{\tocp{U + U'}} = \cpdual{\tocp{U}} \oplus \cpdual{\tocp{U'}}$,
%%     we have that $z[\mkwd{inl}].\tocp{M}z \vdash \tocp{\Gamma}, z:\cpdual{\tocp{U + U'}}$.
%%   \end{itemize}
%% \end{proof}
%%
%% \small\begin{equations}
%% \tocp{M}z &=& \tocp{M}z \\
%% \tocp{\distinguish M}z &=& \tocp{M}z \\
%% \tocp{(\nu x)C}z &=& \tocp{C}z \\
%% \tocpbig{
%%   \inferrule
%%     {\Gamma,x:S \vdash^{\phi} C \\
%%      \Gamma',x:\gvdual{S} \vdash^{\phi'} C'}
%%     {\Gamma,\Gamma',x:\channel{S} \vdash^{\phi + \phi'} C \parallel C'}}z &=&
%%   \left\{
%%     \ba{l}
%%     \cut x {} {\tocp{C}x} {\cut y {} {\tocp{C'}y} {x().\link y z}} \\
%%     \qquad\text{if $\phi' = \bcirc$;} \\
%%     \cut x {} {\tocp{C}x} {\cut y {} {\tocp{C'}y} {y().\link x z}} \\
%%     \qquad\text{otherwise.}
%%     \ea \right.
%% \end{equations}\normalsize
%%
%% \begin{theorem}
%%   If $\Gamma \vdash P$, then there is some $T$ such that $\tocp{P}z \vdash \tocp{\Gamma}, z:\cpdual{\tocp{T}}$.
%% \end{theorem}
%%
%% \begin{theorem}
%%   If $M, N$ are GV-ANF terms and $M \equiv N$, then $\tocp{M}z \equiv \tocp{N}z$.
%% \end{theorem}
%%
%% \begin{theorem}
%%   If $M$ is a GV-ANF term and $M \rto N$, then $\tocp{M}z \rto^+ \tocp{N}z$.
%% \end{theorem}
%%
\section{Extending GV}\label{sec:extend}

\subsection{Unifying $\gvend_x$}\label{sec:gv-end}

We define a language GVX, which, depending on your perspective, either extends GV with mix or
combines the types of closed sessions.  The syntax is largely as in GV; the meaningful changes are
the elimination of $\interm$ and $\outterm$ in favor of $\gvend$, and the use of \gvconst{close} instead
of \gvconst{wait}.
\begin{syntax}
  \text{Session types} & S & ::= & \gvout{T}{S} \mid \gvin{T}{S} \mid \gvend \mid \channel{S} \\
  \text{Constants} & K & ::= & \gvconst{send} \mid \gvconst{receive} \mid \gvconst{fork} \mid \gvconst{close} \mid \gvconst{link}\\
\end{syntax}
The remaining parts of the grammar are unchanged from GV.  The definition of duality is updated to
reflect that $\gvend$ is self-dual:
\[
  \gvdual \gvend = \gvend
\]
We provide new typing rules for some of the constants
\begin{mathpar}
\gvconst{fork} : (S \lto \one) \lto \gvdual S

\gvconst{close} : \gvend \lto \one

\gvconst{link} : S \times \gvdual S \lto \one
\end{mathpar}
but otherwise the type system is unchanged from that of GV.  We require an extension of the type
system for configurations, however:
\begin{mathpar}
\inferrule
  {\Gamma \vdash M: T}
  {\Gamma \vdash^\bcirc \distinguish M}

\inferrule
  {\Gamma \vdash M: \one}
  {\Gamma \vdash^\wcirc M}

\inferrule
  {\Gamma, x: \channel S \vdash^\phi C}
  {\Gamma \vdash^\phi (\nu x)C}

\inferrule
  {\Gamma, x: S \vdash^\phi C \\
   \Gamma', x: \gvdual S \vdash^{\phi'} C'}
  {\Gamma,\Gamma',x:\channel S \vdash^{\phi + \phi'} C \parallel C'}

\inferrule
  {\Gamma \vdash^\phi C \\
   \Gamma' \vdash^{\phi'} C'}
  {\Gamma,\Gamma' \vdash^{\phi + \phi'} C \parallel C'}
\end{mathpar}
Perhaps the latter two rules can be combined by defining a suitable operation on environments;
however, it seems simpler now to just provide two typing rules.  Rules \textsc{Send, Fork, Lift} and
\textsc{Lift2} apply to GVX unchanged; the remaining reduction rules are
\begin{mathpar}
\inferrule
  { }
  {(\nu x)(F[\gvconst{close} \app x] \parallel F'[\gvconst{close} \app x)] \ceval F[()] \parallel F'[()]}

\inferrule
  {x \in \fv(P)}
  {F[\gvconst{link} \app (x,y)] \parallel P \ceval F[()] \parallel P \{y/x\}}
\end{mathpar}
The equivalences are similarly extended by
\begin{mathpar}
C \parallel () \equiv C
\end{mathpar}
We have a slightly different result about channels shared between processes, to account for the
multiple forms of composition:
\begin{lemma}
  If $\Gamma \vdash C$ and $C = \Cx[D \parallel D']$, then $\fv(D) \cap \fv(D')$ is either empty or
  the singleton set $\{x\}$ for some variable $x$.
\end{lemma}
The proof is again by induction on the derivation of $\Gamma \vdash C$.  However, note that this has
no consequence for the proof of deadlock freedom (which depended on their being two channels shared
among processes).  Thus we can conclude that
\begin{theorem}
  If $\Gamma \vdash M: T$ then $\distinguish M$ is deadlock free.
\end{theorem}

\subsection{Adding Exponentials}\label{sec:gv-repl}

Basic approach: add a new type \gvforever{T} in the functional fragment, subject to contraction and
weakening, and with the usual introduction and elimination rules
\begin{syntax}
  \text{Types} & T & ::= & \gvforever T \mid \dots \\
  \text{Terms} & M,N & ::= & \gvlet{{!x}}{M}{N} \mid {!M} \mid \dots \\
  \text{Values} & V & ::= & {!V} \mid \dots \\
  \text{Evaluation contexts} & E & ::= & \gvlet{{!x}}{E}{M} \mid {!E} \mid \dots
\end{syntax}

\begin{mathpar}
\inferrule
  {\Gamma \vdash M: T \\
   \gvforever\Gamma}
  {\Gamma \vdash M: \gvforever T}

\inferrule
  {\Gamma \vdash M: \gvforever T \\
   \Gamma', x:T \vdash N: U}
  {\Gamma \vdash \gvlet{{!x}}{M}{N}: U}

\inferrule
  {\Gamma \vdash M: T}
  {\Gamma, x: \gvforever U \vdash M: T}

\inferrule
  {\Gamma,x:\gvforever T,x':\gvforever T \vdash M: U}
  {\Gamma,x:\gvforever T \vdash M \{ x/x' \}: T}
\end{mathpar}
with suitable expansion of evaluation contexts and the reduction rule
\begin{mathpar}
\gvlet{{!x}}{{!V}}{M} \teval M \{ \bind x V \}
\end{mathpar}
with the observation that $x$ may appear multiple times in $M$.  The extension of the deadlock
freedom results to this calculus are immediate.

Our previous work on GV provided unlimited service channels, which could be used to obtain
arbitrarily many copies of some concurrent behavior.  We can encode such channels by introducing new
dual session type constructors $Service(S)$ and $Server(S)$ and new constants \gvconst{replicate}
and \gvconst{request}, with the types
\begin{mathpar}
\gvconst{replicate} : (\gvforever(\gvdual S \lto \outterm)) \lto Server(S)

\gvconst{request} : Service(S) \lto S
\end{mathpar}
defined as follows
\begin{align*}
  Server(S) &\defeq \gvout{(\gvforever(\gvdual S \lto \outterm))}{\outterm} \\
  \gvconst{replicate} \app f &\defeq \gvconst{fork} \app (\lambda x. \gvsend{(f,x)}) \\
  \gvconst{request} \app s &\defeq
    \bl \gvlet{(f,s)}{\gvreceive{s}}{\\\gvletunit{\gvconst{wait}\app s}{\\\gvlet{{!g}}{f}{g}}} \el
\end{align*}

Note the parallel between the encoding of session-level sums using value-level sums and the encoding
of session-level replication using value-level replication---in each case, the key is ``trivial''
channels $\gvout{T}{\outterm}$ for suitable $T$.

\begin{equations}
  \tocp{{!M}}z &\defeq& \replicate z y.\tocp{M}y \\
  \tocp{\gvlet{{!x}}{V}{M}}z &\defeq& \cut y {} {\tocp{V}y} {\derelict{y}{x}.\tocp{M}z} \\
  \togv{\replicate{s}{x}.P} &\defeq& \gvconst{replicate} \app (\lambda x. \togv{P}) \\
  \togv{\derelict{s}{x}.P} &\defeq& \gvlet{x}{\gvconst{request} \app s}{\togv{P}} \\
  \togvbig{
    \inferrule
      {P \vdash \Gamma}
      {P \vdash \Gamma, x:\cpquery{A}}} &\defeq&
    \ba[c]{l} \gvlet{(y,s)}{\gvreceive{s}}{\\\gvletunit{\gvconst{wait}\app s}{\togv{P}}} \ea \\
  \togvbig{
    \inferrule
      {P \vdash \Gamma,x:\cpquery{A},y:\cpquery{A}}
      {P[x/y] \vdash \Gamma,x:\cpquery{A}}} &\defeq&
    \ba{l} \gvlet{f}{\gvconst{request}\app x}{\\\gvlet{x}{\gvconst{replicate}\app f}{\\\gvlet{y}{\gvconst{replicate}\app f}{\togv{P}}}} \ea
\end{equations}

The correspondence between the semantics is direct; the translation from CP terms into GV terms
emphasizes that, while weakening and contraction are implicit in CP syntax, they play a central role
in the CP semantics of exponentials.

\section{Related Work}\label{sec:related}

Something about connection to Carbone et al.  Their progress property requires that every
communication will eventually take place.  This is hopefully an easy consequence of ours.

\section{Conclusions and Future Work}\label{sec:conclusion}

Asynchrony and recursion.

\end{document}
