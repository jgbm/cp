 % -*- fill-column: 100 -*-

\documentclass[orivec,envcountsame]{llncs}

\usepackage{amsmath,amssymb,centernot,hyperref,mathwidth,scalerel,stmaryrd,url,xspace,mathrsfs}
\usepackage[table]{xcolor}
\usepackage{colortbl}
\addtolength{\jot}{-3px}

\usepackage{mathpartir}
\mprset{sep=1em}

\usepackage{float}
\floatstyle{boxed}
\restylefloat{figure}

\input{preamble.tex}

\title{Deadlock Freedom in a Functional Session-typed Language}
\author{J. Garrett Morris \and Sam Lindley \and Philip Wadler}
\institute{The University of Edinburgh \\
           \email{\{Garrett.Morris,Sam.Lindley,Philip.Wadler\}@ed.ac.uk} \vspace{-5mm}}

\begin{document}

\maketitle

\begin{abstract}
\end{abstract}

\section{Introduction}\label{sec:intro}

Contributions:

\begin{itemize}
\item We define a core linearly-typed functional language, by extending linear lambda calculus
  with session-typed communication primitives.
\item We present an (untyped) operational semantics for our core language,
\item We give characterizations of deadlock and normal forms, and show that well-typed terms are
  deadlock-free.
\item We connect our language to the interpretation of session types as linear logic propositions,
  by establishing a correspondence between the semantics of our language and that of Wadler's
  calculus CP.
\item We give several extensions of our core language, and show that these extensions preserve
  deadlock freedom.
\end{itemize}

\section{GV by Example}\label{sec:examples}

\subsection{Books and Stores Therefore}

\begin{itemize}
\item Explain encoding of select and choice into send and receive with sums.
\end{itemize}

\todo{This ended up being a bit long.  There are a couple of points that it makes tho:
  \begin{itemize}
  \item Transmission of channels (sending client channel to bank).
  \item Sending structured values along channels.
  \end{itemize}
  And it has a motivation.  However, I'm not sure that either of these is important enough to
  justify the length.  We could, for example, do the calculator with structured values and not take
  nearly as much space.}

\begin{code}
Client \defeq \lambda c.
  \bl
  \gvlet{c}{\gvsend{(\text{``A Tale of Two Cities"}, c)}}{} \\
  \gvlet{(price,c)}{\gvreceive{c}}{} \\
  \mkwd{if}\ price \leq 20\ \mkwd{then} \\
  \quad\bl
    \gvlet{c}{\gvselect{purchase}{c}}{}\\
    \gvlet{c}{\gvsend{((ccName, ccNumber), c)}}{} \\
    \mkwd{offer}\,c\,\{ \\
    \quad \bl
      accept\,c \mapsto \gvconst{wait} \app c; \gvconst{print} \app \text{``:)"} \\
      decline\,c \mapsto \gvconst{wait} \app c; \gvconst{print} \app \text{``:("} \\
      challenge\,c \mapsto \\
      \quad \bl
        \gvlet{c}{\gvsend{(response, c)}}{} \\
        \mkwd{offer}\,c\,\{ \\
        \quad \bl
          accept\,c \mapsto \gvconst{wait} \app c; \gvconst{print} \app \text{``:)"} \\
          decline\,c \mapsto \gvconst{wait} \app c; \gvconst{print} \app \text{``:("} \} \}
        \el
      \el
    \el
  \el \\
  \mkwd{else} \\
  \quad \bl
    \gvlet{c}{\gvselect{stop}{c}}{} \\
    \gvconst{wait} \app c
    \el
  \el
\end{code}

\begin{code}
Store \defeq \lambda b. \lambda c. \bl
  \gvlet{(product, c)}{\gvreceive{c}}{} \\
  \gvlet{c}{\gvsend{(price(product), c)}}{} \\
  \mkwd{offer}\,c\,\{ \\
  \quad \bl
    purchase\,c \mapsto \\
    \quad \bl
      \gvlet{((ccName, ccNumber), c)}{\gvreceive{c}}{} \\
      \gvlet{b}{\gvsend{((ccName, ccNumber, price(product), c), b)}}{} \\
      \mkwd{offer}\,b \, \{\\
      \quad \bl
        accept\,b \mapsto
          \gvlet{(c,b)}{\gvreceive{b}}{\gvconst{wait} \app b; \dots; c} \\
        reject\,b \mapsto
          \gvlet{(c,b)}{\gvreceive{b}}{\gvconst{wait} \app b; c} \}
      \el
    \el \\
    stop\,c \mapsto c \}
  \el
\el\end{code}

\begin{code}
Bank \defeq \lambda b. \bl
  \gvlet{((ccName, ccNumber, amount, c), b)}{\gvreceive{b}}{} \\
  \mkwd{if}\ suspicious(ccNumber, amount)\ \mkwd{then} \\
  \quad\bl
    \gvlet{c}{\gvselect{challenge}{c}}{} \\
    \gvlet{(response, c)}{\gvreceive{c}}{} \\
    \mkwd{if}\ passes(response)\ \mkwd{then} \\
    \quad \bl
      \gvlet{c}{\gvselect{accept}{c}}{} \\
      \gvlet{b}{\gvselect{accept}{b}}{} \\
      \gvlet{b}{\gvsend{(c,b)}}{} \\
      \dots; c \el \\
    \mkwd{else} \\
    \quad \bl
      \gvlet{c}{\gvselect{reject}{c}}{} \\
      \gvlet{b}{\gvselect{reject}{b}}{} \\
      \gvlet{b}{\gvsend{(c,b)}}{} \\
      c \el
  \el
\el
\end{code}

\begin{code}
System \defeq \bl
  \gvlet{bank}{\gvconst{fork} \app Bank}{} \\
  \gvlet{store}{\gvconst{fork} \app (Store \app bank)}{} \\
  Client \app store
\el
\end{code}

\subsection{Selection and Choice}

\small\begin{align*}
  \gvconst{select} \app \ell_i \app M &\defeq \gvconst{fork} (\lambda x. \gvsend(\ell_i \app x, M)) \\
  \gvconst{offer} \app M \,\{ \ell_1 \app x \mapsto P; \dots; \ell_n \app x \mapsto Q \}
    &\defeq \bl \gvlet{(y,m)}{\gvreceive{M}}{\\\gvletunit{\gvconst{wait} \app m}{\\\gvcase{x}{\ell_1 \app x \mapsto P; \dots; \ell_n \app x \mapsto Q}}} \el
\end{align*}\normalsize

\section{I'm Pickin' Up Good Vibrations}

I'm intentionally ignoring CP polymorphism forever.

\subsection{Syntax}
\newcommand{\one}{\mathbf{1}}
\newcommand{\zero}{\mathbf{0}}
\begin{syntax}
  \text{Session types} & S & ::= & \gvout{T}{S} \mid \gvin{T}{S} \mid % \oplus \{ \overline{l:S} \} \mid \with \{ \overline{l:S} \} \mid
                                   \interm \mid \outterm \mid \channel{S} \\
  \text{Types} & T,U & ::= & S \mid T \times U \mid \one \mid T + U \mid \zero \mid T \lto U \\ % \mid {!T} \\
  \text{Terms} & M,N & ::= & x \mid K \mid \lambda x.M \mid M\,N \\
  & & \mid & (M,N) \mid \gvlet{(x,y)}{M}{N} \\
  & & \mid & \mkwd{inl}\,M \mid \mkwd{inr}\,M \mid \gvcase{M}{\mkwd{inl}\,x \mapsto N; \mkwd{inr}\,x \mapsto N} \\
  & & \mid & () \mid \gvletunit{M}{N} \mid \gvconst{absurd} \app M \\
  \text{Constants} & K & ::= & \gvconst{send} \mid \gvconst{receive} \mid \gvconst{fork} \mid \gvconst{wait} \mid \gvconst{link}\\
\end{syntax}

\begin{mathpar}
\gvdual{\gvout{T}{S}} = \gvin{T}{\gvdual S}

\gvdual{\gvin{T}{S}} = \gvout{T}{\gvdual S}

\gvdual{\interm} = \outterm

\gvdual{\outterm} = \interm
\end{mathpar}

\subsection{Typing}

\begin{mathpar}
\inferrule
  {T \not= \channel{S}}
  {\{x:T\} \vdash x:T}

\inferrule
  {\Gamma,x:T \vdash M:U}
  {\Gamma \vdash \lambda x.M : T \lto U}

\inferrule
  {\Gamma \vdash M: T \lto U \\
   \Delta \vdash N: T}
  {\Gamma,\Delta \vdash M\,N: U}

\inferrule
  {\Gamma \vdash M: T \\
   \Delta \vdash N: U}
  {\Gamma,\Delta \vdash (M,N): T \times U}

\inferrule
  {\Gamma \vdash M: T \times T' \\
   \Delta,x:T,y:T' \vdash N: U}
  {\Gamma,\Delta \vdash \gvlet{(x,y)}{M}{N} : U}

\inferrule
  {\Gamma \vdash M: T}
  {\Gamma \vdash \mkwd{inl}\,M: T+U}

\inferrule
  {\Gamma \vdash M: T+T' \\
   \Delta,x:T \vdash N: U \\
   \Delta,x:T' \vdash N': U}
  {\Gamma,\Delta \vdash \gvcase{M}{\mkwd{inl}\,x \mapsto N; \mkwd{inr}\,x \mapsto N'} : U}

\inferrule
  { }
  {\vdash (): \one}

\inferrule
  {\Gamma \vdash M: \one \\
   \Delta \vdash N: T}
  {\Gamma,\Delta \vdash \gvletunit{M}{N}: T}

\inferrule
  {\Gamma \vdash M: \zero}
  {\Gamma, \Gamma' \vdash \gvconst{absurd} \app M : T}

\gvconst{send} : T \times \gvout{T}{S} \lto S

\gvconst{receive} : \gvin{T}{S} \lto T \times S

\gvconst{fork} : (S \lto \outterm) \lto \gvdual{S}

\gvconst{wait} : \interm \lto \one

\gvconst{link} : S \times \gvdual{S} \lto \outterm
\end{mathpar}

\subsection{Evaluation}

\newcommand{\distinguish}[1]{\langle #1 \rangle}

\newcommand{\wcirc}{{\mathord{\circ}}}
\newcommand{\bcirc}{{\mathord{\bullet}}}

\begin{syntax}
  \text{Values} & V & ::= & x \mid K \mid \lambda x.M \\ % \mid K\,V \\
  & & \mid & () \mid (V,V') \mid \mkwd{inl}\,V \mid \mkwd{inr}\,V  \\
  \text{Evaluation contexts} & \Ex & ::= &  [~] \mid \Ex\,M \mid V\,E \mid \gvletunit{\Ex}{M} \\
  & & \mid & (\Ex,M) \mid (V,\Ex) \mid \gvlet{(x,y)}{\Ex}{M} \\
  & & \mid & \mkwd{inl}\,\Ex \mid \mkwd{inr}\,\Ex \mid \gvcase{\Ex}{\mkwd{inl}\,x \mapsto N; \mkwd{inr}\,x \mapsto N'} \\
  & \Fx & ::= & \Ex \mid \distinguish \Ex \\
  \text{Configurations} & C,D,E & ::= & M \mid \distinguish M \mid C \parallel C' \mid (\nu x) C \\
  \text{Configuration contexts} & \Cx & ::= & [~] \mid \Cx \parallel P \mid (\nu x)\Cx \\
  \text{Flags} & \phi & ::= & \wcirc \mid \bcirc
\end{syntax}
We define combination of flags $\phi + \phi'$ by
\begin{mathpar}
  \wcirc + \wcirc = \wcirc

  \wcirc + \bcirc = \bcirc

  \bcirc + \wcirc = \bcirc
\end{mathpar}
and leave $\bcirc + \bcirc$ undefined.  Configuration typing is given by
\begin{mathpar}
\inferrule
  {\Gamma \vdash M: T}
  {\Gamma \vdash^\bcirc \distinguish M}

\inferrule
  {\Gamma \vdash M: \outterm}
  {\Gamma \vdash^\wcirc M}

\inferrule
  {\Gamma, x:\channel{S} \vdash^\phi C}
  {\Gamma \vdash^\phi (\nu x) C}

\inferrule
  {\Gamma,x:S \vdash^{\phi} C \\
   \Gamma',x:\gvdual{S} \vdash^{\phi'} C'}
  {\Gamma,\Gamma',x:\channel{S} \vdash^{\phi + \phi'} C \parallel C'}
\end{mathpar}
We will write $\Gamma \vdash P$ for $\Gamma \vdash^\phi P$.  Note that while we can write the
classic deadlocked configuration
\[
  (\nu x)(\nu y)(\distinguish{\gvlet{(z,x)}{\gvconst{receive} \app x}{\gvconst{send} \app (z,y)}} \parallel
                 \gvlet{(z,y)}{\gvconst{receive} \app y}{\gvconst {send} \app (z,x)})
\]
it is not well typed: we can only split one of $x,y$ at the $\parallel$.  Term reductions:
\begin{align*}
  (\lambda x.M)\,V &\teval M\{V/x\} \\
  \gvletunit{()}{M} &\teval M \\
  \gvlet{(x,y)}{(V,V')}{M} &\teval M\{V/x,V'/y\} \\
  \gvcase{(\mkwd{inl}\,V)}{\mkwd{inl}\,x \mapsto N; \mkwd{inr}\,x \mapsto N'} &\teval N\{V/x\} \\
  E[M] &\teval E[M'] \qquad \text{if $M \teval M'$}
\end{align*}
Configuration equivalence:
\begin{mathpar}
\Fx[\mathsf{link}\,(x,y)] \equiv \Fx[\mathsf{link}\,(y,x)]

C \parallel D \equiv D \parallel C

C \parallel (D \parallel E) \equiv (C \parallel D) \parallel E

C \parallel (\nu x)D \equiv (\nu x)(C \parallel D) \text{ if $x \not\in \fv(C)$}

\Cx[C] \equiv \Cx[D] \text{ if $C \equiv D$}
\end{mathpar}

Awkwardly enough, the equivalence rules do not preserve typing.  For example, supposing that $x \in
\fv(C), y \in \fv(D), \text{ and } x,y \in \fv(E)$, we have $\vdash (\nu x y)(C \mid (D \mid E))$
but not $\nvdash (\nu x y)((C \mid D) \mid E)$.  We have a simple reduction rule for configuration
types, given by
\begin{mathpar}
\inferrule
%  [T-Output]
  { }
  {\channel{(\gvout T S)} \ceval \channel S}

\inferrule
%  [T-Input]
  { }
  {\channel{(\gvin T S)} \ceval \channel S}

\inferrule
%  [T-Context]
  {T \ceval T'}
  {\Gamma,x:T \ceval \Gamma,x:T'}
\end{mathpar}
We write $\Gamma \ceval^? \Gamma'$ to denote $\Gamma = \Gamma' \lor \Gamma \ceval \Gamma'$.
Configuration reduction is given by
\begin{mathpar}
\inferrule
  [Send]
  { }
  {\Fx[\gvconst{send} \app (V,x)] \parallel \Fx'[\gvconst{receive} \app x] \ceval \Fx[x] \parallel \Fx'[(V,x)]}

\inferrule
  [Fork]
  {\text{$x$ fresh}}
  {\Fx[\gvconst{fork} \app V] \ceval (\nu x)(\Fx[x] \parallel (V\,x))}

\inferrule
  [Wait]
  { }
  {(\nu x)(\Fx[\gvconst{wait} \app x] \parallel x) \ceval \Fx[()]}

\inferrule
   [Link]
   {x \in \fv(M)}
   {(\nu x) (\Fx[\gvconst{link} \app (x, y)] \parallel \Fx'[M]) \ceval (\nu x)(\Fx[x] \parallel \Fx'[\gvletunit{\gvconst{wait} \app x}{M\{y/x\}}])}

\inferrule
   [Lift]
   {C \ceval C'}
   {\Cx[C] \ceval \Cx[C']}

\inferrule
   [Lift2]
   {M \teval M'}
   {\Cx[M] \ceval \Cx[M']}
\end{mathpar}
Some things that might be useful.
\begin{lemma}\label{thm:term-preservation}
  If $\Gamma \vdash M: T$ and $M \teval M'$, then $\Gamma \vdash M': T$
\end{lemma}

\noindent
The proof is standard.

\begin{theorem}\label{thm:preservation}
  If $\Gamma \vdash C$ and $C \ceval C'$ then there is some $\Gamma'$ such that $\Gamma \ceval^?
  \Gamma'$ and $\Gamma' \vdash C'$.
\end{theorem}

\begin{proof}
  By induction on the derivation of $C \ceval C'$.
  \begin{itemize}
  \item Case \textsc{Lift} is immediate by the induction hypothesis.
  \item Case \textsc{Lift2} follows from \lemref{term-preservation}, with $\Gamma = \Gamma'$.
  \item In case \textsc{Send}, from the assumption $\Gamma \vdash \Cx[\mkwd{send}\,(V,x)] \parallel
    C'[\gvconst{receive} \app x]$, we can assume that $\Gamma$ partitions as
    $\Gamma_1,\Gamma_2,x:\channel{S}$ such that $S = \gvout{T}{S'}$, $V$ has type $T$, and
    $\Gamma_1,x:\gvout{T}{S'} \vdash \Cx[\gvconst{send} \app (V,x)]$,
    $\Gamma_2,x:\gvin{T}{\gvdual{S'}} \vdash C'[\gvconst{receive} \app x]$.  As $\gvconst{send} : T
    \times \gvout{T}{S'} \lto S'$ and $\Gamma_1,x:\gvout{T}{S'} \vdash \Cx[\gvconst{send} \app
    (V,x)]$, we can conclude that $\Gamma_1,x:S' \vdash \Cx[x]$.  By a similar argument, we conclude
    that $\Gamma_2,x:\gvdual{S'} \vdash C'[(V,x)]$. Finally, as $\channel{(\gvout{T}{S})} \ceval
    \channel{S}$, $\Gamma_1,\Gamma_2,x:\channel{(\gvout T S)} \ceval
    \Gamma_1,\Gamma_2,x:\channel{S}$, and we can recompose the resulting processes concluding that
    $\Gamma_1,\Gamma_2,x:\channel{S} \vdash \Cx[x] \parallel C'[(V,x)]$.
  \item In case \textsc{Fork}, from the assumption $\Gamma \vdash \Cx[\gvconst{fork} \app V]$, we can
    conlude that $\Gamma$ splits into $\Gamma_1,\Gamma_2$ and there is some $S$ such that
    $\Gamma_1,x:S \vdash \Cx[x]$ and $\Gamma_2,x:\gvdual{S} \vdash V \app x$.  Thus we have that
    $\Gamma,x:S \vdash \Cx[x] \parallel V \app x$ and $\Gamma \vdash (\nu x)(\Cx[x] \parallel
    V \app x)$.
  \item In case \textsc{Wait}, from the assumption $\Gamma \vdash (\nu x)(\Cx[\gvconst{wait} \app
    x] \parallel x)$, we can conclude that $\Gamma,x:\interm \vdash \Cx[\gvconst{wait} \app x]$ and
    thus, from the typing of \gvconst{wait}, that $\Gamma \vdash \Cx[()]$.
  \item In case \textsc{Link}, from the assumptions $\Gamma \vdash (\nu x) (\Cx[\gvconst{link} \app
    (x, y)] \parallel C'[M]), x \in \fv(M)$, we can conclude that $\Gamma$ partitions as
    $\Gamma_1,\Gamma_2,y:S$ such that $\Gamma_1,y:S,x:\gvdual{S} \vdash \Cx[\gvconst{link} \app (x,
    y)]$ and $\Gamma_2,x:S \vdash C'[M]$.  (Note that the free variable assumption on the reduction
    rule for \gvconst{fork} allows us to assume that neither $C$ or $C'$ binds $x$ or $y$.)  From
    the type of \gvconst{link}, we have that $\Gamma,x:\outterm \vdash \Cx[x]$; similarly, from $x \in
    \fv(M)$, we can conclude that $\Gamma_2,y:S \vdash C'[M\{y/x\}]$.  Finally, from the typing rule
    for \gvconst{wait}, we have that $\Gamma_2,x:\interm,y:S \vdash C'[\gvletunit{\gvconst{wait}
      \app x}{M\{y/x\}}]$, and that $\Gamma \vdash (\nu x)(\Cx[x] \parallel
    C'[\gvletunit{\gvconst{wait} \app x}{M\{y/x\}}])$ \qed
  \end{itemize}
\end{proof}

\begin{theorem}\label{thm:preservation-equiv}
  If $\Gamma \vdash C$, $C \equiv C'$ and $C' \ceval D'$, then there are some $\Gamma',D$ such that
  $\Gamma \vdash^? \Gamma'$ and $\Gamma' \vdash D$.
\end{theorem}

\begin{proof}
  We begin by observing that if $C \ceval D$, then there is some well-typed $C'$ such that $C =
  \Cx[C']$, $C' \ceval D'$, and $D = \Cx[D']$.  The desired result is then obtained by structural
  induction on $C$, examining the possible equivalences in each case. \qed
\end{proof}

Define $\ceval^\star$ as the reflexive, transitive closure of $\equiv\ceval\equiv$.  Note that,
while $\equiv$ does not necessarily preserve typing, we can use \thmref{preservation-equiv} to
conclude that if $\Gamma \vdash C$ and $C \ceval^\star D$, there are some $\Gamma',D'$ such that
$\Gamma \ceval^\star \Gamma'$, $D \equiv D'$, and $\Gamma' \vdash D'$.

\subsection{Deadlock and Its Absence}

Blocked terms:
\newcommand{\blockedp}{\mathsf{blocked}}
\newcommand{\depp}{\mathsf{depends}}
\[\begin{array}{rcl}
  \blockedp(x,M) &\defiff& \exists N. \; M = \Ex[\gvconst{send} \app (x,N)] \\
  && \quad \lor \, M = \Ex[\gvconst{receive} \app x] \\
  && \quad \lor \, M = \Ex[\gvconst{wait} \app x] \\
  \depp(x,y,\Ex[M]) &\defiff& \blockedp(x,M) \land y \in \fv(\Ex) \\
  \depp(x,y,C) &\defiff& (C \equiv \Cx[M] \land \depp(x,y,M)) \lor \, (C \equiv \Cx[D \parallel D'] \\
  && \quad \land \, (\exists z. \depp(x,z,D) \land \depp(z,y,D')))
\end{array}\]
Finally, we have a natural definition of deadlock:
\newcommand{\deadlockp}{\ensuremath{\mathsf{deadlocked}}}
\[
\deadlockp(C) \defiff C \equiv \Cx[D \parallel D'] \land \exists x,y. \depp(x,y,D) \land \depp(y,x,D').
\]
Because this definition depends on blocked processes (that is, those waiting to read or write) it
avoids the problems with return values (since a process returning a channel is not blocked on it, it
cannot be part of a deadlocked pair).  We say a process $C$ is deadlock-free if for all $D$ such
that $C \ceval^\star D$, $\lnot\deadlockp(D)$.  Observe that if $C \equiv D$, then $\deadlockp(C)
\iff \deadlockp(D)$.

\begin{lemma}\label{thm:procs-share-one-channel}
  If $\Gamma \vdash C$, and $C = \Cx[D \parallel D']$, then there is some variable $x$ such that
  $\fv(D) \cap \fv(D') = \{ x \}$.
\end{lemma}

\begin{proof}
  By structural induction on the derivation of $\Gamma \vdash C$; the only interesting case is for
  parallel composition, where the desired result is assured by the partitioning of the
  environment. \qed
\end{proof}

I think we can now show fairly directly that

\begin{lemma}\label{thm:typed-configs-df}
  If $\Gamma \vdash C$ then $\lnot \deadlockp(C)$.
\end{lemma}

\begin{proof}
  By contradiction: suppose $\deadlockp(C)$.  Then we know there must be some variables
  $x_1,\dots,x_n$ and processes $M_1,\dots,M_n$ in $C$ such that
  \[
    \blockedp(x_1,x_2,M_1) \land \blockedp(x_2,x_3,M_2) \land \cdots \land \blockedp(x_n,x_1,M_n).
  \]
  But now there is no possible $\Gamma$ such that any $\Gamma \vdash C'$ for any process $C'$
  containing the $M_i$---such a $C'$ would violate \lemref{procs-share-one-channel}.  \qed
\end{proof}

Finally, the following is trivial.

\begin{theorem}\label{thm:typed-terms-df}
  If $\Gamma \vdash M: T$, then $\distinguish M$ is deadlock-free.
\end{theorem}

\begin{proof}
  If $\Gamma \vdash M: T$, then $\Gamma \vdash \distinguish{M}$, and so
  $\lnot\deadlockp(\distinguish M)$ and, for any $D$ such that $\distinguish M \ceval^\star D$, we
  know that there is a well-typed $D' \equiv D$, and so $\lnot\deadlockp(D)$. \qed
\end{proof}

\begin{definition}
A process $C$ is in canonical form if there is some sequence of variables $x_1,\dots,x_{n-1}$ and
terms $M_1,\dots,M_n$ such that
\[
  C = (\nu x_1)(M_1 \parallel (\nu x_2)(M_2 \parallel \dots \parallel (\nu x_{n-1})(M_{n-1} \parallel D)\dots)),
\]
where either $D = M_n$ or $D = \distinguish M_n$.
\end{definition}

\begin{lemma}\label{thm:canonical}
  If $\Gamma \vdash C$, then there is some $C' \equiv C$ such that $\Gamma \vdash C'$ and $C'$ is in
  canonical form.
\end{lemma}

\begin{proof}
  Let $x_1,\dots,x_{n-1}$ be the $\nu$-bound variables in $C$ and $M_1,\dots,M_n$ be the terms in
  $P$; the proof is by induction on $n$.  If $n > 1$, then pick some $M_i$ such that there is
  exactly one $\nu$-bound variable $x_j$ where $x_j \in \fv(M_i)$.  (That there must be such an
  $M_i$ and $x_j$ can be established by a standard counting argument, together with
  \lemref{procs-share-one-channel}.)  Now, construct $D$ from $C$ by the homomorphic extension of
  the mapping $(\nu x_j)E \mapsto E$ and $E \parallel M_i \mapsto E$.  From the assumption that
  $\Gamma \vdash C$, we can conclude that there is some $\Gamma' \subseteq \Gamma$ and type $S$ such
  that $\Gamma',x:S \vdash D$.  By the induction hypothesis, there is some $D' \equiv D$ in
  canonical form.  Finally, let $C' = (\nu x_j)(M_i \parallel D')$; we can see that
  straightforwardly that $C'$ is in canonical form; that $C \equiv C'$; and, that $\Gamma \vdash
  C'$. \qed
\end{proof}

\begin{theorem}\label{thm:progress-open}
  Let $\Gamma \vdash C$, $C \centernot\ceval$ and let $C' = (\nu x_1)(M_1 \parallel (\nu
  x_2)(M_2 \parallel \dots \parallel (\nu x_{n-1})(M_{n-1} \parallel \distinguish{M_n})\dots))$ be
  a canonical form of $C$.  Then:
  \begin{enumerate}
  \item For $1 \leq i \leq n - 1$ either $\blockedp(x_j,M_i)$ where $j \leq i$ or $\blockedp(y,M_i)$
    for some $y \in \dom(\Gamma)$; and,
  \item Either $M_n$ is a value or $\blockedp(y,M_n)$ for some $y \in \{ x_i \mid i \leq i \leq n -
    1 \} \cup \dom(\Gamma)$.
  \end{enumerate}
\end{theorem}

\begin{proof}
  By induction on the derivation of $\Gamma \vdash C'$, using the definition of $\ceval$. \qed
\end{proof}

\begin{corollary}\label{thm:progress}
  Let $\vdash^\bcirc C$, $C \centernot\ceval$ and let $C' = (\nu x_1)(M_1 \parallel (\nu
  x_2)(M_2 \parallel \dots \parallel (\nu x_{n-1})(M_{n-1} \parallel \distinguish{M_n})\dots))$ be
  a canonical form of $C$.  Then:
  \begin{enumerate}
  \item For $1 \leq i \leq n - 1$, $\blockedp(x_i,M_i)$; and,
  \item $M_n = \distinguish V$ for some value $V$.
  \end{enumerate}
\end{corollary}

\begin{proof}
  By induction on the derivation of $\vdash P'$, relying on \thmref{progress-open}.  \qed
\end{proof}

\subsection{Direct GV semantics}

\newcommand{\rpar}[1]{\mathbin{{[}\:\!\!\rangle}_{\!{#1}}\!}
\newcommand{\lrpar}[1]{\mathbin{\langle\hspace{-.3ex}\rangle}_{\!{#1}}\!}
\newcommand{\lpar}[1]{\mathbin{\langle\:\!\!{]}}_{{#1}}\!}

\newcommand{\con}[3]{{#1} \rpar{#2} {#3}}

\[
\gvconst{connect} : (S \lto \outterm, \gvdual{S} \lto T) \lto T
\]

Syntactic sugar:
\begin{align*}
\con{M}{x}{N} &\defiff \gvconst{connect}(\lambda x.M, \lambda x.N) \\
\con{L}{x}{\con{M}{y}{N}} &\defiff \con{L}{x}{(\con{M}{y}{N})} \\
\end{align*}

Equivalences ($\equiv$ is the transitive, reflexive, symmetric closure of the following rules):
\begin{align*}
\gvconst{link}\,(x,y) &\equiv \gvconst{link}\,(y,x) \\
\con{L}{x}{\con{M}{y}{N}} &\equiv \con{M}{y}{\con{L}{x}{N}} \\
\con{L}{x}{\con{M}{y}{N}} &\equiv \con{(\con{L}{x}{M})}{y}{N} \\
%\con{L}{x}{\con{M}{y}{N}} &\equiv \con{(\con{M}{x}{L})}{y}{N} \\
\end{align*}

Interesting reductions
\begin{align*}
\con{E[\gvconst{send}\,(V,x)]}{x}{E'[\gvconst{receive}\,x]}
  &\rto \con{E[x]}{x}{E'[(V,x)]} \\
\con{E[\gvconst{receive}\,x]}{x}{E'[\gvconst{send}\,(V,x)]}
  &\rto \con{E[(V,x)]}{x}{E'[x]} \\[1ex]
\con{x}{x}{E[\gvconst{wait}\,x]}
  &\rto E[()] \\
\con{E[\gvconst{wait}\,x]}{x}{x}
  &\rto E[()] \\[1ex]
\con{E[\gvconst{link}\,(x,y)]}{x}{M}
  &\rto \con{E[x]}{x}{(\gvconst{wait}\,x; M[y/x])} \\
\con{M}{x}{E[\gvconst{link}\,(x,y)]}
  &\rto \con{(\gvconst{wait}\,x; M[y/x])}{x}{E[x]} \\[1ex]
\gvconst{link}\,(x,\gvconst{link}\,(y,z))
  &\rto \gvconst{wait}\,x; \gvconst{link}\,(y,z) \\
E[\con{M}{x}{N}]
  &\rto \con{M}{x}{E[N]} \\
\end{align*}

An alternative is to remove the final commuting conversion rule and augment the notion of value to
include a suitable representation of a collection of blocked communicating processes.

Preservation
\begin{theorem}
If $\Gamma \vdash M : T$ and $M \rto N$ then $\Gamma \vdash N : T$.
\end{theorem}
%
\begin{proof}
By induction on the structure of the derivation of $\Gamma \vdash M : T$ using a standard
substitution lemma for the case of $\beta$-reduction at function types. \qed
\end{proof}

Progress
\begin{theorem}
\label{thm:free-progress}
If $\Gamma$ is a session environment (all variables in $\Gamma$ have session type) such that $\Gamma
\vdash M : T$ then one of the following holds:
\begin{enumerate}
\item $M$ is a value; or
\item there exists $N = \blockedp'(y_1, M_1) \rpar{x_1} \dots \rpar{x_{n}} \blockedp'(y_{n}, M_{n})$
  such that $M \equiv N$ and $\Gamma \vdash N : T$; or
\item there exists $N$ such that $M \rto N$.
\end{enumerate}
\end{theorem}
%
\begin{proof}
By induction on the structure of the derivation of $\Gamma \vdash M : T$. \qed
\end{proof}
% In the second case each $y_i$ must be equal to either $x_i$ or some $x$ in $\Gamma$.

\begin{theorem}
If $\vdash M : T$ then one of the following holds:
\begin{enumerate}
\item $M$ is a value; or
\item there exists $N = \blockedp(x_1, M_1) \rpar{x_1} \dots \rpar{x_{n-1}} \blockedp(x_{n-1},
  M_{n-1}) \rpar{x_n} V$ such that $M \equiv N$ and $\Gamma \vdash N : T$; or
\item there exists $N$ such that $M \rto N$.
\end{enumerate}
\end{theorem}
%
\begin{proof}
By induction on the structure of the derivation of $\vdash M : T$ using
\thmref{free-progress}. \qed
\end{proof}

$\blockedp(x, M)$ means $M$ is blocked on a send or receive involving $x$.

$\blockedp'(x, M)$ means either $M = x$ or $M$ is blocked on a send, receive, link, or wait
involving $x$.

\section{Linear Logic}

\subsection{CP}

\todo{This section (particularly the text) needs quite a bit of tidying}

\todo{Should we write selection and choice the way other process calculi do? $x \triangleright
  l_i$ and $x \triangleleft \{ P;Q \}$.}

\begin{figure}[float]

\begin{mathpar}
\inferrule{ }{\cptyp{\link{x}{w}}{x:A,w:\cpdual{A}}}

\inferrule{\cptyp{P}{\Gamma,y:A} \\
           \cptyp{Q}{\Delta,y:\cpdual{A}}}
          {\cptyp{\cut{y}{A}{P}{Q}}{\Gamma,\Delta}}

\inferrule{ }{\cptyp{x[].0}{x:1}}

\inferrule{\cptyp{P}{\Gamma,y:A,x:B}}
          {\cptyp{x(y).P}{\Gamma,x:A \parr B}}

\inferrule{\cptyp{P}{\Gamma,y:A} \\
           \cptyp{Q}{\Delta,x:B}}
          {\cptyp{x[y].(P \mid Q)}{\Gamma,\Delta,x:A \otimes B}}

\inferrule{\cptyp{P}{\Gamma}}
          {\cptyp{x().P}{\Gamma,x:\bot}}

\inferrule{\cptyp{P}{\Gamma,x:A_i}}
          {\cptyp{\sel{x}{in_i}.P}{\Gamma,x:A_1 \oplus A_2}}

\inferrule{\cptyp{P}{\Gamma,x:A} \\
           \cptyp{Q}{\Gamma,x:B}}
          {\cptyp{\case{x}{P;Q}}{\Gamma,x:A \with B}}

\inferrule{ }{\cptyp{\case{x}{}}{\Gamma,x:\top}}
\end{mathpar}

\caption{Typing Rules for CP}\label{fig:cp-typing}
\end{figure}

The types of CP are the propositions of classical linear logic.
%
\[\begin{array}{@{}l@{~}r@{~}c@{~}l@{}}
  \text{Types} & A,B & ::= & A \otimes B \mid A \parr B \mid 1 \mid \bot \mid A \oplus B \mid A \with B \mid 0 \mid \top \\
\end{array}\]
CP adopts the standard notion of classical linear logic duality:
\[
\ba{@{}c@{\qquad}c@{\qquad}c@{\qquad}c@{}}
\begin{eqs}
  \cpdual{(A \otimes B)} &=& \cpdual{A} \parr \cpdual{B} \\
  \cpdual{(A \parr B)} &=& \cpdual{A} \otimes \cpdual{B} \\
\end{eqs}
&
\begin{eqs}
  \cpdual{1} &=& \bot \\
  \cpdual{\bot} &=& 1 \\
\end{eqs}
&
\begin{eqs}
  \cpdual{(A \oplus B)} &=& \cpdual{A} \with \cpdual{B} \\
  \cpdual{(A \with B)} &=& \cpdual{A} \oplus \cpdual{B} \\
\end{eqs}
&
\begin{eqs}
  \cpdual{\top} &=& 0 \\
  \cpdual{0} &=& \top \\
\end{eqs}
\ea
\]
where $X^{\perp\perp} = X$.
%
We let $\Gamma, \Delta$ range over type environments. The judgement $\cptyp{P}{\Gamma}$ states that
process $P$ uses channels $\Gamma$.
%
Typing rules for CP terms are given in Fig.~\ref{fig:cp-typing}. We write $fv(P)$ for the free
variables used in process $P$; in the typing rules, new bound variables are designated $y$.

\paragraph{Structural Rules.}

CP has two structural rules, axiom and cut. We interpret the axiom $\link{x}{w}$ as channel
forwarding: actions on channel $x$ are mirrored on $w$, and vice versa. Thus, $x$ and $w$ must have
dual type. Cut $\cut{y}{A}{P}{Q}$ is interpreted as communication between processes $P$ and $Q$ on
channel $y$; the duality of the typing of $y$ assures that its uses in $P$ and $Q$ are
compatible. We identify CP terms up to structural equivalence:
%
\begin{equations}
  \link{x}{w} &\equiv& \link{w}{x} \\
  \cut{y}{A}{P}{Q} &\equiv& \cut{y}{\cpdual{A}}{Q}{P} \\
  \cut{y}{A}{P}{\cut{z}{B}{Q}{R}} &\equiv& \cut{z}{B}{\cut{y}{A}{P}{Q}}{R}, \quad \text{if $y \not\in fv(R)$} \\
\end{equations}%
%
\begin{mathpar}
\inferrule
  {P_1 \equiv P_2}
  {\cut{x}{}{P_1}{Q} \equiv \cut{x}{}{P_2}{Q}}
\end{mathpar}

We take $\equiv$ to be the least equivalence relation that is closed under these rules.

\paragraph{Input and Output.}

The multiplicative connectives $\parr$ and $\otimes$ are interpreted as input and output. The
process $x(y).P$ inputs channel $y$ on channel $x$, and continues as $P$. The process $x[y].(P \mid
Q)$ is interpreted as bound output: it sends a fresh variable $y$ along $x$, spawns a process $P$ in
which $y$ is used, and continues as process $Q$ in which $x$ is used.  It amounts to the
$\pi$-calculus term $(\nu y) \overline{x}(y).(P \mid Q)$. We write $x[y].P$ as syntactic sugar for
$x[y'].(\link{y}{y'} \mid P)$. The units of $\parr$ and $\otimes$, $\bot$ and $1$, are interpreted
as nullary input and nullary output, respectively.

\paragraph{Selection and Choice.}

The additive connectives $\oplus$ and $\with$ are interpreted as selection and choice. The process
$\case{x}{P_1;P_2}$ offers a choice of processes $P_1$ and $P_2$; dually, the process
$\sel{x}{in_i}.P_i$ chooses the $i$-th alternative. The unit for choice is $0$, indicating
absurdity. Note that there is no term proving $0$. The dual of absurdity is $\top$, and provides
arbitrary behavior; as there is no term proving $0$, no term relying on $\top$ can reduce.

\subsection{Cut Elimination}


\begin{figure}[float]

\begin{equations}
\cut{x}{A}{\link{w}{x}}{P}
  &\rto& P[w/x] \\
\cut{x}{A \otimes B}{x[y].(P \mid Q)}{x(y).R}
  &\rto&
    \cut{y}{A}{Q}{\cut{x}{B}{P}{R}} \\
\cptyp{\cut{x}{1}{x[].0}{x().P}}{\Gamma}
  &\rto&
    P \\
\cut{x}{A \oplus B}{\sel{x}{in_i}.P}{\case{x}{Q_1; Q_2}}
  &\rto&
    \cut{x}{A}{P}{Q_i} \\
\end{equations}%
\caption{Principal Cut Elimination Rules}\label{fig:beta-reduction}

\end{figure}

Cut elimination corresponds to synchronous process reduction.  The principal cut reductions are
given in Fig.~\ref{fig:beta-reduction}. These are quite standard; for instance, cut reduction of
$\with$ against $\oplus$ corresponds to picking one of the offered alternatives.

\begin{mathpar}
\inferrule
  {P_1 \longrightarrow P_2}
  {\cut{x}{}{P_1}{Q} \longrightarrow \cut{x}{}{P_1}{Q}}
\end{mathpar}

\begin{figure}[float]

\begin{equations}
  \cut{z}{A}{x[y].(P \mid Q)}{R} &\rto& x[y].(\cut{z}{A}{P}{R} \mid Q), \qquad \text{if $z \not\in fv(Q)$} \\
  \cut{z}{A}{x[y].(P \mid Q)}{R} &\rto& x[y].(P \mid \cut{z}{A}{Q}{R}), \qquad \text{if $z \not\in fv(P)$} \\
  \cut{z}{A}{x(y).P}{Q} &\rto& x(y).\cut{z}{A}{P}{Q} \\
  \cut{z}{A}{\sel{x}{in_i}.P}{Q} &\rto& \sel{x}{in_i}.\cut{z}{A}{P}{Q} \\
  \cut{z}{A}{\case{x}{P;Q}}{R} &\rto& \case{x}{\cut{z}{A}{P}{R}; \cut{z}{A}{Q}{R}} \\
\end{equations}
\caption{Commuting Conversions}\label{fig:commuting}
\end{figure}

The commuting conversions push communication under process prefixes, and are given in
Fig.~\ref{fig:commuting}.

\todo{Think carefully about what to do with commuting conversions.}

\subsection{A Simpler Send}

\todo{Make this description clearer}

The CP send rule is appealing because if one erases the terms it is exactly the classical linear
logic rule for tensor. However, this correspondence comes at a price. Operationally, the process
$x[y].(P \mid Q)$ does three things: it introduces a fresh variable $y$, it sends $y$ to a freshly
spawned process $P$, and in parallel it continues as process $Q$.
%
This is painful on many levels, but in particular it complicates our attempts to relate the
semantics of CP with that of GV (whose send operator only does one thing: performing a send).

Fortunately, we can give an alternative rule for send, corresponding with the send operator of GV,
and which gives rise to a system which is entirely equivalent to CP, apart from having a slightly
different syntax.
%
\begin{mathpar}
\inferrule
  {\cptyp{P}{\Gamma,x:B,y:A}}
  {\cptyp{x[y].P}{\Gamma,x:A \otimes B,y:\cpdual{A}}}
\end{mathpar}
The cut rule for a send against a receive is straightforward:
\begin{equations}
\cut{x}{A \otimes B}{x[y].P}{x(y).Q} &\rto& \cut{x}{B}{P}{Q} \\
\end{equations}
%
For clarity let us refer to the original form as cut-send, and the one we have just defined as send.

It we take send as primitive, then we can express cut-send as a macro:
\[
x[y].P \defeq x[z].(\link{y}{z} \mid P)
\]
Conversely, if we take cut-send as primitive, then we can express send as a macro:
\[
x[y].(P \mid Q) \defeq \cut{y}{}{P}{x[y].Q}
\]

With cut-send as primitive we can simulate a cut of a send against a receive in two steps.
\begin{equations}
  \cut{x}{}{x[y].P}{x(y).Q}
    &\defeq& \cut{x}{}{x[z].(\link{y}{z} \mid P)}{x(y).Q} \\
    &\rto& \cut{z}{}{\link{y}{z}}{\cut{x}{}{P}{Q}} \\
    &\rto& \cut{x}{}{P}{Q} \\
\end{equations}

With send as primitive we can simulate a cut of a cut-send against a receive in one step.
\begin{equations}
  \cut{x}{}{x[y].(P \mid Q)}{x(y).R}
    &\defeq& \cut{x}{}{\cut{y}{}{P}{x[y].Q}}{x(y).R} \\
    &\equiv& \cut{y}{}{P}{\cut{x}{}{x[y].Q}{x(y).R}} \\
    &\rto& \cut{y}{}{P}{\cut{x}{}{Q}{R}} \\
\end{equations}

Using these two observations it is straightforward to show that CP with send is equivalent to CP
with cut-send. In order to simplify our formal development, we will work with CP with send from now
on.

\todo{I'm not sure whether or not we want to include the next bit.}

However, there is a slightly subtlety.
%
Let us consider the possible reductions on the representation of cut-send in terms of send. Let $P_1
= x[y].(P \mid Q)$ and $P_2 = \cut{y}{}{P}{x[y].Q}$. Notice that $P_1$ is blocked, but $P_2$ may not
be as it allows reductions to take place inside $P$.
%
Now let us consider the possible reductions on the representation of send in terms of cut-send. Let
$Q_1 = x[y].P$ and $Q_2 = x[z].(\link{y}{z} \mid P)$. Clearly both $Q_1$ and $Q_2$ are blocked.
%
This discrepancy, suggests that perhaps we should have added the following congruence rule to CP in
the first place:
\begin{mathpar}
\inferrule
  {P_1 \longrightarrow P_2}
  {x[y].(P_1 \mid Q) \longrightarrow x[y].(P_2 \mid Q)}
\end{mathpar}
%

\todo{Do we want to state anything more formal relating CP-cut-send with CP-send?}

\subsection{Translation from CP to GV}

We now present the translation $\togv{-}$ from CP to GV. On types:
\[
\ba{@{}c@{\qquad}c@{\qquad}c@{}}
\begin{eqs}
\togv{A \otimes B} &=& \gvout{\gvdual{\togv{A}}}{\togv{B}} \\
\togv{A \parr B}   &=& \gvin{\togv{A}}{\togv{B}} \\
\end{eqs}
&
\begin{eqs}
\togv{1}           &=& \outterm \\
\togv{\bot}        &=& \interm \\
\end{eqs}
&
\begin{eqs}
\togv{+\{l_i:A_i\}_i}     &=& +\{l_i:\togv{A_i}\}_i  \\
\togv{\with\{l_i:A_i\}_i} &=& \with\{l_i:\togv{A_i}\}_i \\
\end{eqs}
\ea
\]
%
The translation on type environments is defined pointwise. Figure~\ref{fig:fromcp} gives a
translation from CP terms to GV terms ($\togv{-}$) and a translation from CP terms to GV
configurations ($\togvc{-}$).

\begin{figure}[float]
\begin{equations}
  \togv{\cut{x}{}{P}{Q}} &=&
    \gvlet{x}{\gvfork{x}{\togv{P}}}{\togv{Q}} \\
  \togv{\link{x}{y}} &=& \gvlet{z}{\gvlink{x}{y}}{z} \\
  %% \togv{x[y].(P \mid Q)} &=&
  %%   \gvlet{y}{\gvfork{y}{\togv{P}}}{\gvlet{x}{\gvsend{(y, x)}}{\togv{Q}}} \\
  \togv{x[y].P} &=&
    \gvlet{x}{\gvsend{(y, x)}}{\togv{P}} \\
  \togv{x(y).P} &=&
    \gvlet{(y,x)}{\gvreceive{x}}{\togv{P}} \\
  \togv{x[].0} &=& x \\
  \togv{x().P} &=& \gvlet{()}{\gvwait{x}}{\togv{P}} \\
  \togv{\sel{x}{\mathit{l}}.P} &=&
    \gvlet{x}{\gvselect{l}{x}}{\togv{P}} \\
  \togv{\case{x}{l_i.P_i}_i} &=&
    \gvcase{x}{l_i.\togv{P_i}}_i
\medskip
\\
  \togvc{\cut{x}{}{P}{Q}} &=&
    (\nu x)(\togvc{P} \parallel \togvc{Q}) \\
  \togvc{P} &=& \togv{P}, \quad \text{$P$ is not a cut} \\
  %% \togvc{x[y].(P \mid Q)} &=&
  %%   (\nu y)(\togvc{P} \parallel \distinguish{\gvlet{x}{\gvsend{(y, x)}}{\togv{Q}}}) \\
  %% \togvc{P} &=& \distinguish{\togv{P}}, \quad \text{$P$ is not a cut or a send} \\
\end{equations}%

\caption{Translation of CP Terms into GV}\label{fig:fromcp}
\end{figure}

As CP processes have no return value, a CP judgement is translated to a non-returning configuration.

\begin{theorem}
If $P \vdash \Gamma$ then $\togv{\Gamma} \vdash^\wcirc \togvc{P}$.
\end{theorem}

Structural equivalence is preserved by the translation.

\begin{theorem}
If $P \equiv Q$, then $\togvc{P} \equiv \togvc{Q}$.
\end{theorem}

Every CP reduction can be simulated by one or more GV reductions.

\begin{theorem}
If $P \vdash \Gamma$ and $P \rto Q$, then $\togvc{P} \rto^+ \togvc{Q}$.
\end{theorem}


\subsection{Translation from GV to CP}

\todo{ANF translation.}

\todo{Ensure that the definition of $\equiv$ is appropriate for the theorems.}

\todo{Show that the A-normalisation rules are sound (easy).}

Attempt at the ANF syntax.  Should we pick a new letter for ANF terms? [SL: No.]

[SL: I fixed some bugs in the ANF syntax]

\begin{syntax}
  \text{Terms} & M,N & ::= & V \mid \gvlet{x}{V \app W}{N} \\
  & & \mid & \gvlet{(x,y)}{V \app W}{N} \mid \gvletunit{V \app W}{N} \\
  & & \mid & \gvcase{V}{\mkwd{inl}\,x \mapsto N; \mkwd{inr}\,x \mapsto N} \\
  & & \mid & \gvconst{absurd} \app V \\
\end{syntax}

\small\[
\ba{@{}c@{\qquad}c@{\qquad}c@{\qquad}c}
\begin{eqs}
\tocp{T + U} &=& \tocp{T} \with \tocp{U} \\
\tocp{T \times U} &=& \tocp{T} \parr \tocp{U} \\
\tocp{T \lto U} &=& \cpdual{\tocp{T}} \otimes \tocp U
\end{eqs}
&
\begin{eqs}
\tocp{\zero} &=& \top \\
\tocp{\one} &=& \bot
\end{eqs}
&
\begin{eqs}
\tocp{\gvout{T}{S}}        &=& \cpdual{\tocp{T}} \otimes \tocp{S} \\
\tocp{\gvin{T}{S}}         &=& \tocp{T} \parr \tocp{S} \\
\end{eqs}
&
\begin{eqs}
\tocp{\outterm}            &=& 1 \\
\tocp{\interm}             &=& \bot \\
\end{eqs}
%&
%\begin{eqs}
%\tocp{\oplus \{l_i:S_i \}_i} &=& \oplus \{l_i:\tocp{S_i}\}_i \\
%\tocp{\with \{l_i:S_i \}_i}  &=& \with \{l_i:\tocp{S_i}\}_i \\
%\tocp{\gvservice{S}}       &=& \cpquery{\tocp{S}} \\
%\tocp{\gvserver{S}}        &=& \cpbang{\tocp{S}} \\
%\end{eqs}
\ea
\]\normalsize

\small\begin{equations}
\tocp{x}z &=& \link{x}{z} \\
\tocp{\lambda x.N}z &=& z(x).\tocp{N}z \\
\tocp{\gvlet{y}{V \app W}{N}}z &=&
  \bl
    \cut y {} {\cut x {} {\tocp{V}x} {x[z].(\tocp{W}z \mid \link x y)}} {\tocp{N}z} \\
    \text{if $V$ is not a constant $K$}
  \el \\
\tocp{(V,W)}z &=& z[y].(\tocp{V}y \mid \tocp{W}z) \\
\tocp{\gvlet{(x,y)}{V}{N}}z &=& \cut y {} {\tocp{V}y} {y(x).\tocp{N}z} \\
\tocp{\mkwd {inl} \app V}z &=& z[\mkwd{inl}].\tocp{V}z\\
\tocp{\gvcase V {\mkwd {inl} \app x \mapsto M; \mkwd {inr} \app x \mapsto N}}z &=&
   \cut x {} {\tocp{V}x} {\mkwd{case} \app x \app \{ \mkwd{inl} \mapsto \tocp{M}z; \mkwd{inr} \mapsto \tocp{N}z \}} \\
\tocp{\mkwd{absurd} \app V}z &=& \cut x {} {\tocp{V}x} {\mkwd{case}\app x \app \{ \}} \\
\tocp{\gvlet{x}{\gvsend{(V,W)}}{N}}z &=& \cut{x}{}{\tocp{W}x}{\cut y {} {\tocp{V}y} {x[y].\tocp{N}z}} \\
\tocp{\gvlet{(x,y)}{\gvreceive{V}}{N}}z &=& \cut{y}{}{\tocp{V}y}{y(x).\tocp{N}z} \\
\tocp{\gvlet{()}{\gvconst{wait} \app V}{N}}z &=& \cut y {} {\tocp{V}y} {y().\tocp{N}z} \\
\tocp{\gvlet{x}{\gvfork{x}{M}}{N}}z &=& \cut{x}{}{\cut{y}{}{\tocp{M}y}{y[].0}}{\tocp{N}z} \\
\tocp{\gvlet{x}{\gvlink{V}{W}}{N}}z &=& \cut x {} {x().\cut y {} {\tocp{V}y} {\tocp{W}y}} {\tocp{N}z} \\
\end{equations}\normalsize

\begin{theorem}
  If $\Gamma \vdash M: T$, then $\tocp{M}z \vdash \tocp{\Gamma}, z:\tocp{T}^\perp$.
\end{theorem}

\begin{proof}
  By structural induction on the derivation of $\Gamma \vdash M: T$.  Representative cases follow.
  \begin{itemize}
  \item In case $M = x$, we must have $\Gamma = \{x:T\}$; we can directly conclude that $\link x z
    \vdash x:T,z:\cpdual T$.
  \item In case $M = \lambda x.N$, where $T = U \lto U'$, the induction hypothesis provides that
    $\tocp{N}z \vdash \tocp{\Gamma},x:\tocp{U},z:\cpdual{\tocp{U'}}$.  Therefore, from the rule for
    $\parr$ and the observation that $\cpdual{\tocp{U \lto U'}} = \tocp U \parr \cpdual{\tocp {U'}}$, we can
    conclude that $z(x).\tocp{N}z \vdash \tocp{\Gamma}, z:\cpdual{\tocp{U \lto U'}}$.
  \item In case $M = \mkwd{inl} \app V$, where $T = U + U'$, the induction hypothesis provides that
    $\tocp{V}z \vdash \tocp{\Gamma}, z:\cpdual{\tocp{U}}$.  Therefore, from the rule for $\oplus$
    and the observation that $\cpdual{\tocp{U + U'}} = \cpdual{\tocp{U}} \oplus \cpdual{\tocp{U'}}$,
    we have that $z[\mkwd{inl}].\tocp{M}z \vdash \tocp{\Gamma}, z:\cpdual{\tocp{U + U'}}$.
  \end{itemize}
\end{proof}

\small\begin{equations}
\tocp{M}z &=& \tocp{M}z \\
\tocp{\distinguish M}z &=& \tocp{M}z \\
\tocp{(\nu x)C}z &=& \tocp{C}z \\
\tocpbig{
  \inferrule
    {\Gamma,x:S \vdash^{\phi} C \\
     \Gamma',x:\gvdual{S} \vdash^{\phi'} C'}
    {\Gamma,\Gamma',x:\channel{S} \vdash^{\phi + \phi'} C \parallel C'}}z &=&
  \left\{
    \ba{l}
    \cut x {} {\tocp{C}x} {\cut y {} {\tocp{C'}y} {x().\link y z}} \\
    \qquad\text{if $\phi' = \bcirc$;} \\
    \cut x {} {\tocp{C}x} {\cut y {} {\tocp{C'}y} {y().\link x z}} \\
    \qquad\text{otherwise.}
    \ea \right.
\end{equations}\normalsize

\begin{theorem}
  If $\Gamma \vdash P$, then there is some $T$ such that $\tocp{P}z \vdash \tocp{\Gamma}, z:\cpdual{\tocp{T}}$.
\end{theorem}

\begin{theorem}
  If $M, N$ are GV-ANF terms and $M \equiv N$, then $\tocp{M}z \equiv \tocp{N}z$.
\end{theorem}

\begin{theorem}
  If $M$ is a GV-ANF term and $M \rto N$, then $\tocp{M}z \rto^+ \tocp{N}z$.
\end{theorem}

\section{Extending GV}

\subsection{Unifying $\gvend_x$}

We define a language GVX, which, depending on your perspective, either extends GV with mix or
combines the types of closed sessions.  The syntax is largely as in GV; the meaningful changes are
the elimination of $\interm$ and $\outterm$ in favor of $\gvend$, and the use of \gvconst{close} instead
of \gvconst{wait}.
\begin{syntax}
  \text{Session types} & S & ::= & \gvout{T}{S} \mid \gvin{T}{S} \mid \gvend \mid \channel{S} \\
  \text{Constants} & K & ::= & \gvconst{send} \mid \gvconst{receive} \mid \gvconst{fork} \mid \gvconst{close} \mid \gvconst{link}\\
\end{syntax}
The remaining parts of the grammar are unchanged from GV.  The definition of duality is updated to
reflect that $\gvend$ is self-dual:
\[
  \gvdual \gvend = \gvend
\]
We provide new typing rules for some of the constants
\begin{mathpar}
\gvconst{fork} : (S \lto \one) \lto \gvdual S

\gvconst{close} : \gvend \lto \one

\gvconst{link} : S \times \gvdual S \lto \one
\end{mathpar}
but otherwise the type system is unchanged from that of GV.  We require an extension of the type
system for configurations, however:
\begin{mathpar}
\inferrule
  {\Gamma \vdash M: T}
  {\Gamma \vdash^\bcirc \distinguish M}

\inferrule
  {\Gamma \vdash M: \one}
  {\Gamma \vdash^\wcirc M}

\inferrule
  {\Gamma, x: \channel S \vdash^\phi C}
  {\Gamma \vdash^\phi (\nu x)C}

\inferrule
  {\Gamma, x: S \vdash^\phi C \\
   \Gamma', x: \gvdual S \vdash^{\phi'} C'}
  {\Gamma,\Gamma',x:\channel S \vdash^{\phi + \phi'} C \parallel C'}

\inferrule
  {\Gamma \vdash^\phi C \\
   \Gamma' \vdash^{\phi'} C'}
  {\Gamma,\Gamma' \vdash^{\phi + \phi'} C \parallel C'}
\end{mathpar}
Perhaps the latter two rules can be combined by defining a suitable operation on environments;
however, it seems simpler now to just provide two typing rules.  Rules \textsc{Send, Fork, Lift} and
\textsc{Lift2} apply to GVX unchanged; the remaining reduction rules are
\begin{mathpar}
\inferrule
  { }
  {(\nu x)(F[\gvconst{close} \app x] \parallel F'[\gvconst{close} \app x)] \ceval F[()] \parallel F'[()]}

\inferrule
  {x \in \fv(P)}
  {F[\gvconst{link} \app (x,y)] \parallel P \ceval F[()] \parallel P \{y/x\}}
\end{mathpar}
The equivalences are similarly extended by
\begin{mathpar}
C \parallel () \equiv C
\end{mathpar}
We have a slightly different result about channels shared between processes, to account for the
multiple forms of composition:
\begin{lemma}
  If $\Gamma \vdash C$ and $C = \Cx[D \parallel D']$, then $\fv(D) \cap \fv(D')$ is either empty or
  the singleton set $\{x\}$ for some variable $x$.
\end{lemma}
The proof is again by induction on the derivation of $\Gamma \vdash C$.  However, note that this has
no consequence for the proof of deadlock freedom (which depended on their being two channels shared
among processes).  Thus we can conclude that
\begin{theorem}
  If $\Gamma \vdash M: T$ then $\distinguish M$ is deadlock free.
\end{theorem}

\subsection{Adding Exponentials}

Basic approach: add a new type \gvforever{T} in the functional fragment, subject to contraction and
weakening, and with the usual introduction and elimination rules
\begin{syntax}
  \text{Types} & T & ::= & \gvforever T \mid \dots \\
  \text{Terms} & M,N & ::= & \gvlet{{!x}}{M}{N} \mid {!M} \mid \dots \\
  \text{Values} & V & ::= & {!V} \mid \dots \\
  \text{Evaluation contexts} & E & ::= & \gvlet{{!x}}{E}{M} \mid {!E} \mid \dots
\end{syntax}

\begin{mathpar}
\inferrule
  {\Gamma \vdash M: T \\
   \gvforever\Gamma}
  {\Gamma \vdash M: \gvforever T}

\inferrule
  {\Gamma \vdash M: \gvforever T \\
   \Gamma', x:T \vdash N: U}
  {\Gamma \vdash \gvlet{{!x}}{M}{N}: U}

\inferrule
  {\Gamma \vdash M: T}
  {\Gamma, x: \gvforever U \vdash M: T}

\inferrule
  {\Gamma,x:\gvforever T,x':\gvforever T \vdash M: U}
  {\Gamma,x:\gvforever T \vdash M \{ x/x' \}: T}
\end{mathpar}
with suitable expansion of evaluation contexts and the reduction rule
\begin{mathpar}
\gvlet{{!x}}{{!V}}{M} \teval M \{V/x\}
\end{mathpar}
with the observation that $x$ may appear multiple times in $M$.  The extension of the deadlock
freedom results to this calculus are immediate.

Our previous work on GV provided unlimited service channels, which could be used to obtain
arbitrarily many copies of some concurrent behavior.  We can encode such channels by introducing new
dual session type constructors $Service(S)$ and $Server(S)$ and new constants \gvconst{replicate}
and \gvconst{request}, with the types
\begin{mathpar}
\gvconst{replicate} : (\gvforever(\gvdual S \lto \outterm)) \lto Server(S)

\gvconst{request} : Service(S) \lto S
\end{mathpar}
defined as follows
\begin{align*}
  Server(S) &\defeq \gvout{(\gvforever(\gvdual S \lto \outterm))}{\outterm} \\
  \gvconst{replicate} \app f &\defeq \gvconst{fork} \app (\lambda x. \gvsend{(f,x)}) \\
  \gvconst{request} \app s &\defeq
    \bl \gvlet{(f,s)}{\gvreceive{s}}{\\\gvletunit{\gvconst{wait}\app s}{\\\gvlet{{!g}}{f}{g}}} \el
\end{align*}

Note the parallel between the encoding of session-level sums using value-level sums and the encoding
of session-level replication using value-level replication---in each case, the key is ``trivial''
channels $\gvout{T}{\outterm}$ for suitable $T$.

\todo{\gvconst{replicate} was called \gvconst{serve} in the PLACES paper and was, like
  \gvconst{fork}, first order.  I find the newer name more representative of its meaning, but would
  it be better to stick with the previous presentation?}

\begin{equations}
  \tocp{{!M}}z &\defeq& \replicate z y.\tocp{M}y \\
  \tocp{\gvlet{{!x}}{V}{M}}z &\defeq& \cut y {} {\tocp{V}y} {\derelict{y}{x}.\tocp{M}z} \\
  \togv{\replicate{s}{x}.P} &\defeq& \gvconst{replicate} \app (\lambda x. \togv{P}) \\
  \togv{\derelict{s}{x}.P} &\defeq& \gvlet{x}{\gvconst{request} \app s}{\togv{P}} \\
  \togvbig{
    \inferrule
      {P \vdash \Gamma}
      {P \vdash \Gamma, x:\cpquery{A}}} &\defeq&
    \ba[c]{l} \gvlet{(y,s)}{\gvreceive{s}}{\\\gvletunit{\gvconst{wait}\app s}{\togv{P}}} \ea \\
  \togvbig{
    \inferrule
      {P \vdash \Gamma,x:\cpquery{A},y:\cpquery{A}}
      {P[x/y] \vdash \Gamma,x:\cpquery{A}}} &\defeq&
    \ba{l} \gvlet{f}{\gvconst{request}\app x}{\\\gvlet{x}{\gvconst{replicate}\app f}{\\\gvlet{y}{\gvconst{replicate}\app f}{\togv{P}}}} \ea
\end{equations}

The correspondence between the semantics is direct; the translation from CP terms into GV terms
emphasizes that, while weakening and contraction are implicit in CP syntax, they play a central role
in the CP semantics of exponentials.

\section{Related Work}\label{sec:related}

Something about connection to Carbone et al.  Their progress property requires that every
communication will eventually take place.  This is hopefully an easy consequence of ours.

\section{Conclusions and Future Work}\label{sec:conclusion}

Asynchrony and recursion.

\end{document}
