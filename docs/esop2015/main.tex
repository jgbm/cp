 % -*- fill-column: 100 -*-
\documentclass[oribibl,orivec,envcountsame]{llncs}

\renewcommand\floatpagefraction{.9}
\renewcommand\dblfloatpagefraction{.9} % for two column documents
\renewcommand\topfraction{.9}
\renewcommand\dbltopfraction{.9} % for two column documents
\renewcommand\bottomfraction{.9}
\renewcommand\textfraction{.1}
\setcounter{totalnumber}{50}
\setcounter{topnumber}{50}
\setcounter{bottomnumber}{50}

\usepackage{amsmath,amssymb,centernot,colortbl,mathwidth,scalerel,stmaryrd,url,xspace,mathrsfs,enumitem,bm}
\usepackage[table]{xcolor}
\addtolength{\jot}{-3px}

\usepackage{hyperref}
\hypersetup{colorlinks=true,citecolor=blue}

\usepackage[numbers,sort&compress,sectionbib,square]{natbib}
\renewcommand{\bibname}{References}

\usepackage{mathpartir}
\mprset{sep=1em}

\usepackage{float}
\floatstyle{boxed}
\restylefloat{figure}

\input{preamble.tex}

\title{A Semantics for Propositions as Sessions}
%\title{Deadlock-Freedom in a Session-Typed Functional Language}
\author{Sam Lindley \and J. Garrett Morris}
\institute{The University of Edinburgh \\
           \email{\{Sam.Lindley,Garrett.Morris\}@ed.ac.uk} \vspace{-5mm}}

\begin{document}

\maketitle

\begin{abstract}
  Session types provide a static guarantee that concurrent programs respect communication
  protocols. Recently Caires, Pfenning, and Toninho, and Wadler, have developed a correspondence
  between the propositions of linear logic and session typed $\pi$-calculus processes.
%
  We relate the cut-elimination semantics of this approach to an operational semantics for
  session-typed concurrency in a functional language.
%
  We begin by presenting a variant of Wadler's minimal session-typed functional language, GV. We
  give a small-step operational semantics for GV. We develop a suitable notion of deadlock for our
  functional setting, based on existing approaches for capturing deadlock in $\pi$-calculus, and
  show that all well-typed GV programs are deadlock-free, deterministic, and terminating.
%
  We relate GV to linear logic by giving translations between GV and CP, a process calculus with a
  type system and semantics based on classical linear logic.  We prove that both directions of our
  translation preserve reduction; previous translations from GV to CP, in contrast, failed to
  preserve $\beta$-reduction. Crucially, we use a weak form of explicit substitutions, effectively
  generalising lambda abstractions to closures, in order to maintain a correspondence with cut
  reduction.
%
  Finally, to demonstrate the modularity of our approach, we define two extensions of GV and show
  that they preserve deadlock freedom.
\end{abstract}

\section{Introduction}\label{sec:intro}

From massively distributed programs running across entire data centres, to hand-held apps reliant on
remote services for functionality, concurrency has become a critical aspect of modern programs and
thus a central problem in program correctness. Assuring correct concurrent behaviour requires
reasoning not just about the types of data communicated, but the order in which the communication
takes place. For example, the messages between an SMTP client and server are all strings, but a
client that sends the recipient's address before the sender's address is in violation of the
protocol, despite sending the correct type of data.

Session types, originally proposed by Honda~\cite{Honda93}, provide a mechanism to reason about the
state of communications.  The type of a session captures the expected behavior of a process
communicating on that session.  For example, we could express a simplified session type for an SMTP
client as
\[
  \gvout{SenderAddress}{\gvout{RcptAddress}{\gvout{Message}{\gvend}}},
\]
where $\gvout T S$ denotes the expectation that the process will send a value of type $T$, then
continue with the behavior specified by $S$. An important property of session types is duality: we
can derive the type of an SMTP server session from the client's session type:
\[
  \gvin{SenderAddress}{\gvin{RcptAddress}{\gvin{Message}{\gvend}}},
\]
where $\gvin T S$ denotes the expectation that the process will send a value of type $T$, then
continue with the behavior specified by $S$.  Honda originally defined session types for process
calculi; recent work~\cite{VasconcelosGR06,GayVasconcelos10} has investigated the use of session
types for concurrency in functional languages.

Session type systems are necessarily substructural---if processes can freely discard or duplicate
sessions, then the type system cannot guarantee that the observable messages on sessions match the
expectations of their types. Recent work has sought to establish a correspondence between session
types and linear logic, the archetypal substructural logic for reasoning about state.  Caires and
Pfenning~\cite{CairesPfenning10} developed a correspondence between cut elimination in
intuitionistic linear logic and process reduction in a session-typed process
calculus. Wadler~\cite{Wadler14} adapted their approach to classical linear logic, emphasising the
role of duality in typing; the semantics of his system is given directly by the cut elimination
rules of classical linear logic. He also gives a type-preserving translation from a simple
functional calculus (GV) to a process calculus (CP); however, he gives no semantics for GV besides
the semantics of the translated terms.

In this paper, we develop a minimal, session-typed functional language, also called GV.  (Our
language shares most of the distinctive features of Wadler's, although it differs in some details.)
We present a small-step operational semantics for GV, factored into functional and concurrent
portions following the approach of Gay and Vasconcelos~\cite{GayVasconcelos10}. The functional
portion of our semantics differs from standard presentations of call-by-value reduction only in that
we adopt a weak form of explicit substitution to better maintain a connection with cut
reduction. The concurrent portion of our semantics includes the typical reductions and equivalences
of $\pi$-calculus-like systems. We develop a characterisation of deadlock-free programs in our
setting; this is not completely trivial because closed expressions may return channels, so we cannot
simply require that all possible communication take place. We show that well-typed GV programs are
deadlock-free, deterministic, and terminating. We give translations between our variant of GV and
Wadler's CP, and show that these translations preserve reduction as well as typing. Finally, we show
that GV is a useful basis for further language development by giving two extensions of GV and
showing that our deadlock freedom results transfer easily to the extended languages.

The paper proceeds as follows.
\begin{itemize}
\item We define a core linearly-typed functional language, by extending linear lambda calculus with
  session-typed communication primitives~\secref{gv-static}. We present an (untyped) synchronous
  operational semantics for our core language~\secref{gv-eval}. We characterise deadlock and normal
  forms; we show that typed terms are deadlock-free, that closed typed terms evaluate to normal
  forms~\secref{gv-deadlock}, and that evaluation is deterministic and
  terminating~\secref{determinism}.
\item We connect our language to the interpretation of session types as linear logic propositions,
  by establishing a correspondence between the semantics of our language and that of CP. We begin by
  introducing CP~\secref{cp}. We show that we can simulate CP reduction in GV~\secref{togv}, and GV
  reduction in CP~\secref{tocp}. As $\pi$-calculus-like process calculi provide substitution only
  for names, not entire process expressions, the latter depends crucially on the use of weak
  explicit substitutions in the semantics of GV lambda abstractions.
\item We consider two extensions of our core language: one which has a single, self-dual type for
  closed sessions, harmonising the treatment of closed channels with their treatment in other
  session-typed calculi~\secref{gv-end}, and another which adds unlimited types and replicated
  behavior~\secref{gv-repl}. We show that these extensions preserve the essential deadlock freedom
  properties of the core language.
\end{itemize}
We conclude by discussing related~\secref{related} and future~\secref{conclusion} work.

%% \section{GV by Example}\label{sec:examples}
%%
%% \subsection{Books and Stores Therefore}
%%
%% \todo{This ended up being a bit long.  There are a couple of points that it makes tho:
%%   \begin{itemize}
%%   \item Transmission of channels (sending client channel to bank).
%%   \item Sending structured values along channels.
%%   \end{itemize}
%%   And it has a motivation.  However, I'm not sure that either of these is important enough to
%%   justify the length.  We could, for example, do the calculator with structured values and not take
%%   nearly as much space.}
%%
%% \begin{code}
%% Client \defeq \lambda c.
%%   \bl
%%   \gvlet{c}{\gvsend{(\text{``A Tale of Two Cities"}, c)}}{} \\
%%   \gvlet{(price,c)}{\gvreceive{c}}{} \\
%%   \mkwd{if}\ price \leq 20\ \mkwd{then} \\
%%   \quad\bl
%%     \gvlet{c}{\gvselect{purchase}{c}}{}\\
%%     \gvlet{c}{\gvsend{((ccName, ccNumber), c)}}{} \\
%%     \mkwd{offer}\,c\,\{ \\
%%     \quad \bl
%%       accept\,c \mapsto \gvconst{wait} \app c; \gvconst{print} \app \text{``:)"} \\
%%       decline\,c \mapsto \gvconst{wait} \app c; \gvconst{print} \app \text{``:("} \\
%%       challenge\,c \mapsto \\
%%       \quad \bl
%%         \gvlet{c}{\gvsend{(response, c)}}{} \\
%%         \mkwd{offer}\,c\,\{ \\
%%         \quad \bl
%%           accept\,c \mapsto \gvconst{wait} \app c; \gvconst{print} \app \text{``:)"} \\
%%           decline\,c \mapsto \gvconst{wait} \app c; \gvconst{print} \app \text{``:("} \} \}
%%         \el
%%       \el
%%     \el
%%   \el \\
%%   \mkwd{else} \\
%%   \quad \bl
%%     \gvlet{c}{\gvselect{stop}{c}}{} \\
%%     \gvconst{wait} \app c
%%     \el
%%   \el
%% \end{code}
%%
%% \begin{code}
%% Store \defeq \lambda b. \lambda c. \bl
%%   \gvlet{(product, c)}{\gvreceive{c}}{} \\
%%   \gvlet{c}{\gvsend{(price(product), c)}}{} \\
%%   \mkwd{offer}\,c\,\{ \\
%%   \quad \bl
%%     purchase\,c \mapsto \\
%%     \quad \bl
%%       \gvlet{((ccName, ccNumber), c)}{\gvreceive{c}}{} \\
%%       \gvlet{b}{\gvsend{((ccName, ccNumber, price(product), c), b)}}{} \\
%%       \mkwd{offer}\,b \, \{\\
%%       \quad \bl
%%         accept\,b \mapsto
%%           \gvlet{(c,b)}{\gvreceive{b}}{\gvconst{wait} \app b; \dots; c} \\
%%         reject\,b \mapsto
%%           \gvlet{(c,b)}{\gvreceive{b}}{\gvconst{wait} \app b; c} \}
%%       \el
%%     \el \\
%%     stop\,c \mapsto c \}
%%   \el
%% \el\end{code}
%%
%% \begin{code}
%% Bank \defeq \lambda b. \bl
%%   \gvlet{((ccName, ccNumber, amount, c), b)}{\gvreceive{b}}{} \\
%%   \mkwd{if}\ suspicious(ccNumber, amount)\ \mkwd{then} \\
%%   \quad\bl
%%     \gvlet{c}{\gvselect{challenge}{c}}{} \\
%%     \gvlet{(response, c)}{\gvreceive{c}}{} \\
%%     \mkwd{if}\ passes(response)\ \mkwd{then} \\
%%     \quad \bl
%%       \gvlet{c}{\gvselect{accept}{c}}{} \\
%%       \gvlet{b}{\gvselect{accept}{b}}{} \\
%%       \gvlet{b}{\gvsend{(c,b)}}{} \\
%%       \dots; c \el \\
%%     \mkwd{else} \\
%%     \quad \bl
%%       \gvlet{c}{\gvselect{reject}{c}}{} \\
%%       \gvlet{b}{\gvselect{reject}{b}}{} \\
%%       \gvlet{b}{\gvsend{(c,b)}}{} \\
%%       c \el
%%   \el
%% \el
%% \end{code}
%%
%% \begin{code}
%% System \defeq \bl
%%   \gvlet{bank}{\gvconst{fork} \app Bank}{} \\
%%   \gvlet{store}{\gvconst{fork} \app (Store \app bank)}{} \\
%%   Client \app store
%% \el
%% \end{code}
%%
\section{A Session-Typed Functional Language}\label{sec:gv}

\subsection{Syntax and Typing}\label{sec:gv-static}

\begin{figure}[float]
\begin{syntax}
  \text{Session types} & S & ::= & \gvout{T}{S} \mid \gvin{T}{S} \mid \interm \mid \outterm \mid \channel{S} \\
  \text{Types} & T,U & ::= & S \mid \one \mid T \gvtimes U \mid \zero \mid T \gvplus U \mid T \lto U
  \\ % \mid {!T} \\
  \text{Terms} & L,M,N & ::= & x \mid K \app M \mid \lambda x.M \mid M\,N \\
  & & \mid & (M,N) \mid \gvlet{(x,y)}{M}{N} \\
  & & \mid & \mkwd{inl}\,M \mid \mkwd{inr}\,M \mid \gvcase{M}{\mkwd{inl}\,x \mapsto N; \mkwd{inr}\,x \mapsto N} \\
  & & \mid & () \mid \gvletunit{M}{N} \mid \gvconst{absurd} \app M \\
  \text{Constants} & K & ::= & \gvconst{send} \mid \gvconst{receive} \mid \gvconst{fork} \mid \gvconst{wait} \mid \gvconst{link}\\
\end{syntax}
\caption{Syntax of GV Terms and Types}\label{fig:gv-syntax}
\end{figure}

\figref{gv-syntax} gives the syntax of GV types and terms. The types $T$ include nullary ($\zero$)
and binary ($T \gvplus U$) linear sums, nullary ($\one$) and binary ($T \times U$) linear products,
and linear implication ($T \lto U$). We frequently write $\gvletunit{M}{N}$ as the elimination form
of $\one$ in place of the more verbose $\gvlet{()}{M}{N}$. Session types $S$ include input ($\gvin T
S$), output ($\gvout T S$), and closed sessions ($\interm$, $\outterm$). We also include a type
$\channel S$ of channels; values of channel type cannot be used directly in terms, but will appear
in the typing of thread configurations. The terms are the standard $\lambda$-calculus terms,
augmented with constructs for pairs and sums. \figref{gv-typing} gives both typing rules and type
schemas for the constants.

\begin{figure}[float]
\vspace{1ex}
~Typing rules
\begin{mathpar}
\inferrule
  {T \not= \channel{S}}
  {\{x:T\} \vdash x:T}

\inferrule
  {K : T \lto U \\
   \Gamma \vdash M: T}
  {\Gamma \vdash K\,M: U}
\\
\inferrule
  {\Gamma,x:T \vdash M:U}
  {\Gamma \vdash \lambda x.M : T \lto U}

\inferrule
  {\Gamma \vdash M: T \lto U \\
   \Gamma' \vdash N: T}
  {\Gamma,\Gamma' \vdash M\,N: U}
\\
\inferrule
  {\Gamma \vdash M: T \\
   \Gamma' \vdash N: U}
  {\Gamma,\Gamma' \vdash (M,N): T \gvtimes U}

\inferrule
  {\Gamma \vdash M: T \gvtimes T' \\
   \Gamma',x:T,y:T' \vdash N: U}
  {\Gamma,\Gamma' \vdash \gvlet{(x,y)}{M}{N} : U}

\inferrule
  {\Gamma \vdash M: T}
  {\Gamma \vdash \mkwd{inl}\,M: T \gvplus U}

\inferrule
  {\Gamma \vdash M: T \gvplus T' \\
   \Gamma',x:T \vdash N: U \\
   \Gamma',x:T' \vdash N': U}
  {\Gamma,\Gamma' \vdash \gvcase{M}{\mkwd{inl}\,x \mapsto N; \mkwd{inr}\,x \mapsto N'} : U}

\inferrule
  { }
  {\vdash (): \one}

\inferrule
  {\Gamma \vdash M: \one \\
   \Gamma' \vdash N: T}
  {\Gamma,\Gamma' \vdash \gvlet{()}{M}{N}: T}

\inferrule
  {\Gamma \vdash M: \zero}
  {\Gamma, \Gamma' \vdash \gvconst{absurd} \app M : T}
\end{mathpar}
~Type schemas for constants
\begin{mathpar}
\gvconst{send} : T \gvtimes \gvout{T}{S} \lto S

\gvconst{receive} : \gvin{T}{S} \lto T \gvtimes S

\gvconst{fork} : (S \lto \outterm) \lto \gvdual{S}

\gvconst{wait} : \interm \lto \one

\gvconst{link} : S \gvtimes \gvdual{S} \lto \outterm
\end{mathpar}
~Duality
\begin{mathpar}
\gvdual{\gvout{T}{S}} = \gvin{T}{\gvdual S}

\gvdual{\gvin{T}{S}} = \gvout{T}{\gvdual S}

\gvdual{\interm} = \outterm

\gvdual{\outterm} = \interm
\end{mathpar}
\caption{GV Typing Rules}\label{fig:gv-typing}
\end{figure}

\subsubsection{Concurrency.}

Concurrent behavior is provided by the constants.  Communication is provided by \gvconst{send} and
\gvconst{receive}.  For example (assuming an extension of our core language with numbers and
arithmetic operators), a computation $M$ that received a pair of numbers along a channel $z$ and then
sent their sum along the same channel could be expressed by
%
\[
M \defeq
  \bl
    \gvlet{((x, y), z)}{\gvreceive{z}}
    {\gvsend{(x + y,z)}}
  \el
\]
%
(where the interpretation of nested patterns by sequences of bindings is standard).  Sessions are
treated linearly in GV. Thus, \gvconst{receive} returns not only the received value (the pair of $x$
and $y$) but also a new copy of the session used for receiving ($z$); similarly, \gvconst{send}
returns a copy of the session used for sending. Thus, the term above is well-typed in the context $z
: \gvin{(Int \gvtimes Int)}{\gvout{Int}{S}}$, and evaluates to a session of type $S$. Session
initiation is provided by \gvconst{fork}. If $f$ is a function from a session of type $S$ to a
closed session (of type $\outterm$), then $\gvconst{fork} \app f$ forks a new thread in which $f$
is applied to a fresh session of type $S$, and returns a session of type $\gvdual{S}$ in order to
communicate with the thread. For example, the term $\gvconst{fork} \app (\lambda z. M)$ returns a
channel of type $\gvout{(Int \gvtimes Int)}{\gvin{Int}{\interm}}$. Given a thread created by
$\gvconst{fork} \app f$, the session returned from $f$ is closed by $\gvconst{fork}$; however, the
other end of the channel must be closed by calling \gvconst{wait}. A client of the process $M$ could
be defined as follows:
%
\[N \defeq
  \bl
  \gvlet{z}{\gvsend{((6,7),z)}}
  {\gvlet{(x,z)}{\gvreceive{z}}}
  {\gvletunit{\gvconst{wait}\app z}{x}}
\el\]
%
The combined process $\gvlet{x}{\gvconst{fork}\app(\lambda z.M)}{N}$ evaluates to 13. The form
$\gvconst{link} \app (x, y)$ forwards messages sent on $x$ to be received on $y$ and vice versa.

\subsubsection{Choice.}

In addition to input and output, typical session type systems also provide session types
representing internal ($S_1 \oplus S_2$) and external ($S_1 \with S_2$) choice (also known as
selection and branching, respectively). For example, we could write a process that can either sum
two numbers or negate one:
%
\[\bl
  \mkwd{offer} \: z \: \{ \:
  \bl
     \mkwd{inl} \app z \mapsto \bl
       \gvlet{((x, y), z)}{\gvreceive{z}}
       {\gvsend{(x + y,z)}} \el \\
     \mkwd{inr} \app z \mapsto \bl
       \gvlet{(x, z)}{\gvreceive{z}}
       {\gvsend{(-x,z)}} \: \} \el \\
  \el
\el\]
%
This term initially requires $z : (\gvin{(Int \gvtimes Int)}{\gvout{Int}{S}}) \with
(\gvin{Int}{\gvout{Int}{S}})$.  A client of this process would begin by choosing which branch of the
session to take; for example, we could extend the preceding example as follows:
\[
\bl
  \gvlet{z}{\gvselect{\mkwd{inl}}{z}}
  {\gvlet{z}{\gvsend{((6,7),z)}}}
  {\gvlet{(x,z)}{\gvreceive{z}}}
  {\gvletunit{\gvconst{wait}\app z}{x}}
\el
\]
%
While we would expect a surface language to include selection and branching, we omit them from our
core calculus. Instead, we show that they are macro-expressible using the linear sum type. The
intuition is that selection is implemented by sending a suitably tagged process, while branching is
implemented by a term-level branch on a received value. Concretely, we define the types by:
\begin{mathpar}
S_1 \with S_2 \defeq \gvin{(S_1 \gvplus S_2)}{\interm}

S_1 \oplus S_2 \defeq \gvout{(\gvdual{S_1} \gvplus \gvdual{S_2})}{\outterm}
\end{mathpar}
Note that we have the expected duality relationship: $\gvdual{S_1 \with S_2} = \gvdual{S_1} \oplus
\gvdual{S_2}$.  We can implement the \gvconst{select} and \gvconst{offer} primitives as follows
(where $\ell$ ranges over $\{ \mkwd{inl}, \mkwd{inr} \}$):
%
\begin{align*}
  \gvconst{select} \app \ell \app M &\defeq \gvconst{fork} (\lambda x. \gvsend(\ell \app x, M)) \\
  \gvconst{offer} \app M \,\{ \mkwd{inl} \app x \mapsto P; \mkwd{inr} \app x \mapsto Q \}
    &\defeq \bl \gvlet{(x,y)}{\gvreceive{M}}{\\\gvletunit{\gvconst{wait} \app y}{\gvcase{x}{\mkwd{inl} \app x \mapsto P; \mkwd{inr} \app x \mapsto Q}}} \el
\end{align*}
Correspondingly, nullary choice and selection may be encoded with the $\zero$ type:
\begin{mathpar}
\with \{\} \defeq \gvin{\zero}{\interm}

\oplus \{\} \defeq \gvout{\zero}{\outterm}

\gvconst{offer} \app M \,\{ \}
  \defeq \gvlet{(x,y)}{\gvreceive{M}}{\gvletunit{\gvconst{wait} \app y}{\gvconst{absurd}\{ \}}}
\end{mathpar}

\subsection{Evaluation}\label{sec:gv-eval}

\begin{figure}[float]
\begin{syntax}
  \text{Values} & V,W & ::= & x \mid \lambda^\sigma x.M \\
  & & \mid & () \mid (V,W) \mid \mkwd{inl}\,V \mid \mkwd{inr}\,V  \\
  \text{Substitutions} & \sigma & ::= & \{ \bind {x_1} {V_1}, \dots, \bind {x_n} {V_n} \} \\
  & & & \qquad\text{ where the $x_i$ are pairwise distinct} \\
  \text{Evaluation contexts} & \Ex & ::= &  [~] \mid \Ex\,M \mid V\,\Ex \mid K \app V \mid \gvletunit{\Ex}{M} \\
  & & \mid & (\Ex,M) \mid (V,\Ex) \mid \gvlet{(x,y)}{\Ex}{M} \\
  & & \mid & \mkwd{inl}\,\Ex \mid \mkwd{inr}\,\Ex \mid \gvcase{\Ex}{\mkwd{inl}\,x \mapsto N; \mkwd{inr}\,x \mapsto N'} \\
  & \Fx & ::= & \phi \Ex \\
  \text{Configurations} & C,D & ::= & \phi M \mid C \parallel C' \mid (\nu x) C \\
  \text{Configuration contexts} & \Cx & ::= & [~] \mid \Cx \parallel P \mid (\nu x)\Cx \\
  \text{Flags} & \phi & ::= & \wcirc \mid \bcirc
\end{syntax}
\caption{Syntax of Values, Configurations, and Contexts}\label{fig:gv-eval-syntax}
\end{figure}

Following Gay and Vasconcelos~\cite{GayVasconcelos10}, we factor the semantics of GV into a
(deterministic) reduction relation on terms (called $\teval$) and a (non-deterministic) reduction on
configurations of processes (called $\ceval$).  \figref{gv-eval-syntax} gives the syntax of values,
configurations, and evaluation and configuration contexts.

\subsubsection{Terms.}

To preserve a close connection between the semantics of our term language and cut-reduction in
linear logic, we define term reduction using weak explicit substitutions~\cite{LevyM99}. In this
approach, we capture substitutions at $\lambda$-terms rather than immediately applying them to the
body of the term. Our language of terms, therefore, includes closures $\lambda^\sigma x.M$, where
$\sigma$ provides the captured substitution. We extend the typing judgement to include closures, as
follows:
\[
\inferrule
  {\Gamma, x:T \vdash M\sigma : U \\
   \dom(\sigma) = (\fv(M) \setminus \{ x \})}
  {\Gamma \vdash \lambda^\sigma x.M : T \lto U}
\]
The free variables of a closure $\lambda^\sigma x.M$ are the free variables of the range of
$\sigma$, not the free variables of $M$. The capture avoiding substitution $M\sigma$ of $\sigma$
applied to $M$ is defined as usual on the free variables of $M$. Note that the side condition on the
domain of $\sigma$ is preserved under substitution. We implicitly treat plain lambda abstractions
$\lambda x.M$ as closures $\lambda^\sigma x.M$, where $\sigma$ is a renaming substitution restricted
to the free variables of $M$ less $\{x\}$; concretely:
\[
\bl
\lambda x.M \defeq \lambda^\sigma x.(M\sigma') \\
\quad \text{where }
  \ba[t]{l@{\qquad}l}
  \fv(M)  = \{x_1, \dots, x_n\} &
  y_1, \dots, y_n \text{ are fresh variables} \\
  \sigma  = \{\bind{x_1}{y_1}, \dots, \bind{x_n}{y_n}\} &
  \sigma' = \{\bind{y_1}{x_1}, \dots, \bind{y_n}{x_n}\} \\
  \ea
\el
\]
%% GM: useful discussion, but not sure it's necessary to understand closures.
%%
%% (Note that the $\sigma$ annotation on the lambda abstraction is an object language construct that
%% binds the variables in the domain of $\sigma$ inside the body of the lambda abstraction, whereas
%% $M\sigma'$ is a meta-language application of the substitution $\sigma'$ to $M$.)

%% We will implicitly treat substitutions $\sigma$ as sets of bindings.  We define the application of
%% one substitution $\sigma$ to another $\sigma'$ by
%% \[
%%   \sigma'\sigma \defeq \{ \bind x {\sigma V} \mid \bind x v \in \sigma' \}.
%% \]
%% Note that this is not the standard notion of substitution composition.  Finally, we define the
%% application of a substitution to a term $M\sigma$ by the homomorphic extension of the following
%% \begin{align*}
%%   x\sigma  &\defeq V &&\text{if $(\bind x V) \in \sigma$} \\
%%   (\lambda^{\sigma'} x.M)\sigma  &\defeq \lambda^{\sigma' \sigma} x.M \\
%%   M\sigma  &\defeq M &&\text{if $x \not\in \fv(M)$}
%% \end{align*}

%% As values, we have closures, which combine an abstraction with a captured substitution.  We will
%% treat $\lambda x.M$ as syntactic sugar for $\lambda^\sigma x.M$ where $\sigma = \{ \bind x x \mid x
%% \in \fv(M) \setminus \{ x \}\}.$ We extend the typing rules for terms with a typing rule for
%% closures:
%% \[
%% \inferrule
%%   {\Gamma, x:T \vdash M\sigma : U \\
%%    \dom(\sigma) = (\fv(M) \setminus \{ x \})}
%%   {\Gamma \vdash \lambda^\sigma x.M : T \lto U}
%% \]
%% Note that the invariant on the domain of $\sigma$ is preserved under substitution.

\subsubsection{Configurations.}

The grammar of configurations includes the usual $\pi$-calculus forms for composition and name
restriction.  However, because functional computations return values (which may, in turn, contain
channels), we distinguish between the ``main'' thread $\distinguish M$ (which returns a meaningful
value) and the threads $\thread M$ created by \gvconst{fork} (which do not).

\subsubsection{Reduction.}

\begin{figure}[float]
\vspace{1ex}
~Term reduction
\begin{align*}
  (\lambda^\sigma x.M)\,V &\teval M(\{\bind x V\} \uplus \sigma) \\
  \gvletunit{()}{M} &\teval M \\
  \gvlet{(x,y)}{(V,V')}{M} &\teval M \{ \bind x V, \bind y {V'} \} \\
  \gvcase{(\mkwd{inl}\,V)}{\mkwd{inl}\,x \mapsto N; \mkwd{inr}\,x \mapsto N'} &\teval N \{ \bind x V \} \\
  E[M] &\teval E[M'] \qquad \text{if $M \teval M'$}
\end{align*}
~Configuration equivalence
\begin{mathpar}
\Fx[\mathsf{link}\,(x,y)] \equiv \Fx[\mathsf{link}\,(y,x)]

C \parallel D \equiv D \parallel C

C \parallel (D \parallel E) \equiv (C \parallel D) \parallel E

C \parallel (\nu x)D \equiv (\nu x)(C \parallel D) \text{ if $x \not\in \fv(C)$}

\Cx[C] \equiv \Cx[D] \text{ if $C \equiv D$}
\end{mathpar}
~Configuration reduction
\begin{mathpar}
\inferrule
  [Send]
  { }
  {\Fx[\gvconst{send} \app (V,x)] \parallel \Fx'[\gvconst{receive} \app x] \ceval \Fx[x] \parallel \Fx'[(V,x)]}

\inferrule
   [Lift]
   {C \ceval C'}
   {\Cx[C] \ceval \Cx[C']}

\inferrule
  [Fork]
  {\text{$x$ is a fresh channel name}}
  {\Fx[\gvconst{fork} \app (\clos{\sigma}{y}{M})] \ceval (\nu x)(\Fx[x] \parallel M(\{\bind y x\} \uplus \sigma)}
  %% [Fork]
  %% {\text{$x$ fresh}}
  %% {\Fx[\gvconst{fork} \app V] \ceval (\nu x)(\Fx[x] \parallel (V\,x))}

\inferrule
  [Wait]
  { }
  {(\nu x)(\Fx[\gvconst{wait} \app x] \parallel \phi x) \ceval
       \Fx[()]}

\inferrule
   [Link]
   {x \in \fv(M)}
   {\Fx[\gvconst{link} \app (x, y)] \parallel \Fx'[M] \ceval \Fx[x] \parallel \Fx'[\gvletunit{\gvconst{wait} \app x}{M\{y/x\}}]}

\inferrule
   [LiftV]
   {M \teval M'}
   {\Cx[M] \ceval \Cx[M']}

%% [Lift3] would allow us to slightly simplify [Send] and [Link]
%%
%% \inferrule
%%    [Lift3]
%%    {\Cx[M] \ceval \Cx[M']}
%%    {\Cx[\Fx[M]] \ceval \Cx[\Fx[M']]}
\end{mathpar}
\caption{Reduction Rules and Equivalences for Terms and Configurations}\label{fig:gv-reduction}
\end{figure}

Reduction rules for terms and configurations, and equivalences for configurations, are given in
\figref{gv-reduction}. Term reduction ($\teval$) is standard call-by-value left-to-right evaluation;
the only complication is that application not only substitutes for the $\lambda$-bound variables,
but also applies any substitution captured by the closure. Configuration equivalence ($\equiv$) is
also relatively standard. We provide an additional equivalence observing that \gvconst{link} is
symmetric in order to simplify the definition of reduction. Communication is provided by rule
\textsc{Send} and session initiation is provided by rule \textsc{Fork}. Rule \textsc{Wait} combines
synchronisation of closed channels with garbage collection of the associated name restriction.  Rule
\textsc{Link} is complicated by the need to produce a session of type $\outterm$; the inserted
\gvconst{wait} synchronises with the produced session.

%% [SL: unnecessary?]
%%
%% We do not incorporate equivalence directly in reduction; we will return to the treatment of
%% equivalence at the end of the section.

\subsubsection{Relation Notation.}
We write $R\,R'$ for the sequential composition of relations $R$ and $R'$, $R \cup R'$ for the union
of relations $R$ and $R'$, $R^?$ for the reflexive closure of $R$, $R^+$ for the transitive closure
of $R$, and $R^\star$ for the reflexive, transitive closure of $R$.

\subsubsection{Configuration Typing.}

\begin{figure}[float]
\vspace{1ex}
~Configuration typing
\begin{mathpar}
\inferrule
  { \Gamma \vdash M: T \\
    T \not= \outterm }
  {\Gamma \vdash^\bcirc \distinguish M}

\inferrule
  {\Gamma \vdash M: \outterm}
  {\Gamma \vdash^\wcirc \thread M}

\inferrule
  {\Gamma, x:\channel{S} \vdash^\phi C}
  {\Gamma \vdash^\phi (\nu x) C}

\inferrule
  {\Gamma,x:S \vdash^{\phi} C \\
   \Gamma',x:\gvdual{S} \vdash^{\phi'} C'}
  {\Gamma,\Gamma',x:\channel{S} \vdash^{\phi + \phi'} C \parallel C'}
\end{mathpar}
~Combination of flags
\begin{mathpar}
  \wcirc + \wcirc = \wcirc

  \wcirc + \bcirc = \bcirc

  \bcirc + \wcirc = \bcirc

  \bcirc + \bcirc \text{ undefined}
\end{mathpar}
~Reduction of configuration typing environments
\begin{mathpar}
\inferrule
  { }
  {\channel{(\gvout T S)} \ceval \channel S}

\inferrule
  { }
  {\channel{(\gvin T S)} \ceval \channel S}

\inferrule
  {T \ceval T'}
  {\Gamma,x:T \ceval \Gamma,x:T'}
\end{mathpar}
\caption{Configuration Typing}\label{fig:gv-conf-typing}
\end{figure}

Our syntax of configurations permits various forms of deadlocked configurations.  For example, if we
define the terms $M$ and $N$ by
\begin{align*}
  M &\defeq \bl
    \gvlet{(z,y)}{\gvreceive{y}}{} \\
    \gvlet{x}{\gvsend{(z,x)}}{M'} \el &
  N &\defeq \bl
    \gvlet{(z,x)}{\gvreceive{x}}{} \\
    \gvlet{y}{\gvsend{(z,y)}}{N'} \el
\end{align*}
given suitable terms $M'$ and $N'$, then it is apparent that configurations such as $(\nu xy)M$,
$(\nu xy)(M \parallel M)$ and $(\nu xy)(M \parallel N)$ cannot reduce further, even though $M$ and
$N$ can be individually well-typed.  To exclude such cases, we provide a type discipline for
configurations (\figref{gv-conf-typing}). It is based on type systems for linear
$\pi$-calculus~\cite{Kobayashi96} with two significant differences.
\begin{itemize}
\item First, we seek to assure that there is at most one main thread. This constraint is enforced by
  the flags ($\bcirc$ and $\wcirc$) on the derivations: a derivation $\Gamma \vdash^\bcirc C$
  indicates that configuration $C$ contains the main thread, while $\Gamma \vdash^\wcirc C$
  indicates that $C$ does not contain the main thread. We write $\Gamma \vdash C$ to abbreviate
  $\exists \phi.\Gamma \vdash^\phi C$, that is, $C$ may include a main thread.
\item Second, we require that exactly one channel is shared at each composition of processes.  This
  restricts standard type systems for linear $\pi$-calculus, which allow an arbitrary number of
  processes (including none) to be shared at a composition of processes.
\end{itemize}
We see that the earlier stuck examples are ill-typed in this system: $(\nu xy)M$ because $y$ must
have a type $\channel S$ in $M$; $(\nu xy)(M \parallel M)$ because there is no type $\channel S$
such that both $S$ and $\gvdual{S}$ are of the form $\gvin{T}{S'}$, as required by
\gvconst{receive}; and, $(\nu xy)(M \parallel N)$ because both $x$ and $y$ must be shared between
$M$ and $N$, but the typing rule for composition only allows one channel to be shared.

Observe that reduction may transform the types of sessions---for example, if $\Gamma \vdash
F[\gvconst{send}\app(V,x)] \parallel F'[\gvconst{receive}\app x]$, then $\Gamma$ must contain an
assignment $x : \channel{(\gvout{T}{S})}$ for some type $T$ and session type $S$. However, after
reduction, for $F[x] \parallel F'[(V,x)]$ to be well-typed we need $x:\channel S$. We capture this
constraint with the reduction relation $\Gamma \ceval \Gamma'$. Now, we can show that reduction
preserves typing. We begin with term reduction.
%
\begin{lemma}\label{lem:term-preservation}
  If $\Gamma \vdash M: T$ and $M \teval M'$, then $\Gamma \vdash M': T$
\end{lemma}
%
The proof is by induction on $M$; the cases are all standard.  We can extend this result to show
preservation of configuration typing under reduction.
%
\begin{theorem}\label{thm:preservation}
  If $\Gamma \vdash C$ and $C \ceval C'$ then there is some $\Gamma'$ such that $\Gamma \ceval^?
  \Gamma'$ and $\Gamma' \vdash C'$.
\end{theorem}
%
The proof is in Appendix~\ref{sec:proofs}.

\subsubsection{Typing and Configuration Equivalence.}

Alas, our notion of typing is not preserved by configuration equivalence.  For example, assume that
$\Gamma \vdash (\nu x y)(C \parallel (D \parallel E))$, where $x \in \fv(C), y \in \fv(D), \text{
  and } x,y \in \fv(E)$.  We have that $C \parallel (D \parallel E) \equiv (C \parallel D) \parallel
E$, but $\Gamma \nvdash (\nu x y)((C \parallel D) \parallel E)$, as both $x$ and $y$ must be shared
between the processes $C \parallel D$ and $E$.  However, we can show that starting from a well-typed
configuration, we need never rely on an ill-typed equivalent configuration to expose possible
reductions.
%
\begin{theorem}\label{thm:preservation-equiv}
  If $\Gamma \vdash C$, $C \equiv C'$ and $C' \ceval D'$, then there exist $\Gamma',D$ such that
  $\Gamma \ceval^? \Gamma'$, $D \equiv D'$, and $\Gamma' \vdash D$.
\end{theorem}
%
\begin{proof}
  Observe that if $\Gamma \vdash C$, then for any pair of terms $M_1, M_2$ appearing in $C$, there
  are environments $\Gamma_1,\Gamma_2$ and types $T_1,T_2$ such that $\Gamma_1 \vdash M_1 :
  T_1,\Gamma_2 \vdash M_2 : T_2$, and (because of the typing rule for composition) $\Gamma_1$ and
  $\Gamma_2$ share at most one variable. By examination of the reduction rules, we can conclude that
  there are well-typed $C_0,D_0$ such that $C' = \Cx[C_0]$, $C_0 \ceval D_0$ and $D' = \Cx[D_0]$.
  The result then follows by structural induction on $C$, examining the possible equivalences in
  each case. \qed
\end{proof}
%
We extend \thmref{preservation-equiv} to sequences of reductions, defining $\cevalstar$ as
$(\equiv\ceval\equiv)^\star$.
%
\begin{corollary}
  If $\Gamma \vdash C$ and $C \cevalstar D$, then there exist $\Gamma',D'$ such that $\Gamma
  \ceval^\star \Gamma'$, $D \equiv D'$, and $\Gamma' \vdash D'$.
\end{corollary}

\subsection{Deadlock and its Absence}\label{sec:gv-deadlock}
\newcommand{\blockedp}{\mathsf{blocked}}
\newcommand{\depp}{\mathsf{depends}}
\newcommand{\deadlockp}{\ensuremath{\mathsf{deadlocked}}}

Previously~\secref{gv-eval}, we saw several examples of deadlocked terms which were rejected by our
type system. We now present a general account of deadlock: we characterise deadlocked
configurations, and show that well-typed configurations do not evaluate to deadlocked
configurations.

We begin by observing that many examples of stuck configurations are already excluded by existing
session-typing disciplines: in particular, those configurations in which either too many or too few
threads attempt to synchronise on a given session.  The cases of interest to us are those in which
the threads individually obey the session-typing discipline, but the order of synchronisations in
the threads creates deadlock.  We say that a thread $M$ is blocked on a session $x$, written
$\blockedp(x,M)$, if $M$ has evaluated to some context surrounding a communication primitive applied
to $x$:
%
\[\begin{array}{rcl}
  \blockedp(x,M) &\defiff& \exists N. \; M = \Ex[\gvconst{send} \app (N,x)] \\
  && \quad \lor \, M = \Ex[\gvconst{receive} \app x] \\
  && \quad \lor \, M = \Ex[\gvconst{wait} \app x]
\end{array}\]
%
In such a case, $M$ can only reduce further in composition with another thread blocked on $x$, and
any communication on other sessions in $M$ will be delayed until a communication on $x$ has
occurred. In general, we abstract over the property that $y$ depends on $x$ in $M$, abbreviated
$\depp(x,y,M)$; in other words, $M$ is blocked on $x$, but has $y$ as one of its (other) free
variables. We extend this notion of dependency from single threads to configurations of threads,
with the observation that in a larger configuration intermediate sessions may participate in the
dependency.
\[\begin{array}{rcl}
  \depp(x,y,\Ex[M]) &\defiff& \blockedp(x,M) \land y \in \fv(\Ex) \\
  \depp(x,y,C) &\defiff& (C \equiv \Cx[M] \land \depp(x,y,M)) \lor \, (C \equiv \Cx[D \parallel D'] \\
  && \quad \land \, (\exists z. \depp(x,z,D) \land \depp(z,y,D')))
\end{array}\]
%
We now define deadlocked configurations as those with cyclic dependencies:
%
\[
\deadlockp(C) \defiff C \equiv \Cx[D \parallel D'] \land \exists x,y. \depp(x,y,D) \land \depp(y,x,D').
\]
%
Because the definition of dependency permits intermediate sessions, this definition encompasses
cycles involving an arbitrary number of sessions.  Finally, we say that a configuration $C$ is
deadlock free if, for all $D$ such that $C \cevalstar D$, $\lnot\deadlockp(D)$.  Observe that if
$C \equiv D$, then $\deadlockp(C) \iff \deadlockp(D)$.

At this point, we can observe that in any deadlocked configuration, there must be a composition of
configurations that shares more than one session.  This is precisely the situation that is excluded
by our configuration type system.

\begin{lemma}\label{lem:procs-share-one-channel}
  If $\Gamma \vdash C$, and $C = \Cx[D \parallel D']$, then there is exactly one variable $x$ such
  that $\fv(D) \cap \fv(D') = \{ x \}$.
\end{lemma}

\begin{proof}
  By structural induction on the derivation of $\Gamma \vdash C$; the only interesting case is for
  parallel composition, where the desired result is assured by the partitioning of the
  environment. \qed
\end{proof}

To extend this observation to deadlock freedom, we must take equivalence into account.  While it is
true that equivalence need not preserve typing, there are no equivalence rules that affect the free
variables of individual threads.  Thus, cycles of dependent sessions are preserved by equivalence.

\begin{lemma}\label{lem:typed-configs-df}
  If $\Gamma \vdash C$ then $\lnot \deadlockp(C)$.
\end{lemma}

\begin{proof}
  By contradiction. Suppose $\deadlockp(C)$, then by expanding the definition of $\deadlockp$ we
  know that there must exist variables $x_1,\dots,x_n$ and processes $M_1,\dots,M_n$ in $C$ such
  that
  \[
    \depp(x_1,x_2,M_1) \land \depp(x_2,x_3,M_2) \land \cdots \land \depp(x_n,x_1,M_n).
  \]
  Either $n = 1$, which violates linearity, or configuration $C$ must partition the cycle. However,
  any cut of the cycle is crossed by at least two channels, so $C$ must be ill-typed by
  \lemref{procs-share-one-channel}. \qed
\end{proof}

Finally, we can combine the previous result with preservation of typing to show that well-typed
terms never evaluate to deadlocked configurations.

\begin{theorem}\label{thm:typed-terms-df}
  If $\Gamma \vdash M: T$, then $\distinguish M$ is deadlock-free.
\end{theorem}

\begin{proof}
  If $\Gamma \vdash M: T$, then $\Gamma \vdash \distinguish{M}$, and so
  $\lnot\deadlockp(\distinguish M)$ and, for any $D$ such that $\distinguish M \cevalstar D$, we
  know that there is a well-typed $D' \equiv D$, and so $\lnot\deadlockp(D)$. \qed
\end{proof}

\subsubsection{Progress and Canonical Forms.}

We conclude the section by describing a canonical form for configurations, and characterising the
stuck terms resulting from the evaluation of well-typed terms.  One might hope that evaluation of a
well-typed term would always produce a value; however, this is complicated because terms may return
sessions.  For a simple example, consider the term
%
\[
  \distinguish{\gvconst{fork} \app (\lambda x. \gvlet{(y,x)}{\gvreceive{x}}{\gvsend(y,x)})}
\]
%
This term spawns a thread (which simply echoes once), and then returns the resulting session; thus,
the result of evaluation is a configuration equivalent to
\[
  (\nu x)(\distinguish{x} \parallel \thread{\gvlet{(y,x)}{\gvreceive{x}}{\gvsend(y,x)}}).
\]
Clearly, no more evaluation is possible, even though the configuration still contains blocked
threads.
%
However, it turns out that we can show that evaluation of terms that do not return sessions must
always produce a value.

\begin{definition}
A process $C$ is in canonical form if there is some sequence of variables $x_1,\dots,x_{n-1}$ and
terms $M_1,\dots,M_n$ such that
\[
  C = (\nu x_1)(\thread {M_1} \parallel (\nu x_2)(\thread {M_2} \parallel \dots \parallel (\nu x_{n-1})(\thread{M_{n-1}} \parallel \phi M_n)\dots)).
\]
\end{definition}

Note that canonical forms need not be unique.  For example, consider the configuration $\vdash (\nu
xy)(C \parallel D \parallel E)$ where $x \in \fv(C), y \in \fv(D), \text{ and } x,y \in \fv(E)$.
Both $(\nu x)(C \parallel (\nu y)(D \parallel E))$ and $(\nu y)(D \parallel (\nu x)(C \parallel E))$
are canonical forms of the original configuration.  We can show that any well-typed term must be
equivalent to a term in canonical form; again, the key insight is that captured by
\lemref{procs-share-one-channel}: if any two sub-configurations share at most one session, then we
can order the threads by the sessions they share.

\begin{lemma}\label{lem:canonical}
  If $\Gamma \vdash C$, then there is some $C' \equiv C$ such that $\Gamma \vdash C'$ and $C'$ is in
  canonical form.
\end{lemma}
The proof is in Appendix~\ref{sec:proofs}.

We can now state some progress results.  We begin with open configurations: each thread must be
blocked on either a free variable or a $\nu$-bound variable.
%
\begin{theorem}\label{thm:progress-open}
  Let $\Gamma \vdash C$, $C \centernot\ceval$ and let $C' = (\nu x_1)(\thread M_1 \parallel (\nu
  x_2)(\thread M_2 \parallel \dots \parallel (\nu x_{n-1})(\thread M_{n-1} \parallel \phi M_n)\dots))$ be a
  canonical form of $C$.  Then:
  \begin{enumerate}
  \item For $1 \leq i \leq n - 1$ either $\blockedp(x_j,M_i)$ where $j \leq i$ or $\blockedp(y,M_i)$
    for some $y \in \dom(\Gamma)$; and,
  \item Either $M_n$ is a value or $\blockedp(y,M_n)$ for some $y \in \{ x_i \mid 1 \leq i \leq n -
    1 \} \cup \dom(\Gamma)$.
  \end{enumerate}
\end{theorem}
%
\begin{proof}
  By induction on the derivation of $\Gamma \vdash C'$, using the definition of $\ceval$. \qed
\end{proof}

We can strengthen the result significantly when we move to configurations without free variables.
To see why, consider just the first two threads of a configuration $(\nu x_1)(M_1 \parallel (\nu
x_2)(M_2 \parallel \dots))$.  As there are no free variables, thread $M_1$ can only be blocked on
$x_1$.  Now, from the previous result, thread $M_2$ can be blocked on either $x_1$ or $x_2$.  But,
were it blocked on $x_1$, it could reduce with thread $M_1$; we can conclude it is blocked on $x_2$.
Generalising this observation gives the following progress result.
%
\begin{corollary}\label{thm:progress}
  Let $\vdash C$, $C \centernot\ceval$ and let $C' = (\nu x_1)(\thread M_1 \parallel (\nu
  x_2)(\thread M_2 \parallel \dots \parallel (\nu x_{n-1})(\thread M_{n-1} \parallel
  \phi M_n)\dots))$ be a canonical form of $C$.  Then:
  \begin{enumerate}
  \item For $1 \leq i \leq n - 1$, $\blockedp(x_i,M_i)$; and,
  \item $M_n$ is a value.
  \end{enumerate}
\end{corollary}
%
\begin{proof}
  By induction on the derivation of $\vdash P'$, relying on \thmref{progress-open}.  \qed
\end{proof}
%
Finally, observe that some subset of the variables $x_1,\dots,x_n$ must appear in the result $V$.
Therefore, if the original expression returns a value that does not contain any sessions, it will
evaluate to a configuration with no blocked threads.

%% \subsection{Direct GV semantics}
%%
%% \newcommand{\rpar}[1]{\mathbin{{[}\:\!\!\rangle}_{\!{#1}}\!}
%% \newcommand{\lrpar}[1]{\mathbin{\langle\hspace{-.3ex}\rangle}_{\!{#1}}\!}
%% \newcommand{\lpar}[1]{\mathbin{\langle\:\!\!{]}}_{{#1}}\!}
%%
%% \newcommand{\con}[3]{{#1} \rpar{#2} {#3}}
%%
%% \[
%% \gvconst{connect} : (S \lto \outterm, \gvdual{S} \lto T) \lto T
%% \]
%%
%% Syntactic sugar:
%% \begin{align*}
%% \con{M}{x}{N} &\defiff \gvconst{connect}(\lambda x.M, \lambda x.N) \\
%% \con{L}{x}{\con{M}{y}{N}} &\defiff \con{L}{x}{(\con{M}{y}{N})} \\
%% \end{align*}
%%
%% Equivalences ($\equiv$ is the transitive, reflexive, symmetric closure of the following rules):
%% \begin{align*}
%% \gvconst{link}\,(x,y) &\equiv \gvconst{link}\,(y,x) \\
%% \con{L}{x}{\con{M}{y}{N}} &\equiv \con{M}{y}{\con{L}{x}{N}} \\
%% \con{L}{x}{\con{M}{y}{N}} &\equiv \con{(\con{L}{x}{M})}{y}{N} \\
%% %\con{L}{x}{\con{M}{y}{N}} &\equiv \con{(\con{M}{x}{L})}{y}{N} \\
%% \end{align*}
%%
%% Interesting reductions
%% \begin{align*}
%% \con{E[\gvconst{send}\,(V,x)]}{x}{E'[\gvconst{receive}\,x]}
%%   &\rto \con{E[x]}{x}{E'[(V,x)]} \\
%% \con{E[\gvconst{receive}\,x]}{x}{E'[\gvconst{send}\,(V,x)]}
%%   &\rto \con{E[(V,x)]}{x}{E'[x]} \\[1ex]
%% \con{x}{x}{E[\gvconst{wait}\,x]}
%%   &\rto E[()] \\
%% \con{E[\gvconst{wait}\,x]}{x}{x}
%%   &\rto E[()] \\[1ex]
%% \con{E[\gvconst{link}\,(x,y)]}{x}{M}
%%   &\rto \con{E[x]}{x}{(\gvconst{wait}\,x; M[y/x])} \\
%% \con{M}{x}{E[\gvconst{link}\,(x,y)]}
%%   &\rto \con{(\gvconst{wait}\,x; M[y/x])}{x}{E[x]} \\[1ex]
%% \gvconst{link}\,(x,\gvconst{link}\,(y,z))
%%   &\rto \gvconst{wait}\,x; \gvconst{link}\,(y,z) \\
%% E[\con{M}{x}{N}]
%%   &\rto \con{M}{x}{E[N]} \\
%% \end{align*}
%%
%% An alternative is to remove the final commuting conversion rule and augment the notion of value to
%% include a suitable representation of a collection of blocked communicating processes.
%%
%% Preservation
%% \begin{theorem}
%% If $\Gamma \vdash M : T$ and $M \rto N$ then $\Gamma \vdash N : T$.
%% \end{theorem}
%% %
%% \begin{proof}
%% By induction on the structure of the derivation of $\Gamma \vdash M : T$ using a standard
%% substitution lemma for the case of $\beta$-reduction at function types. \qed
%% \end{proof}
%%
%% Progress
%% \begin{theorem}
%% \label{thm:free-progress}
%% If $\Gamma$ is a session environment (all variables in $\Gamma$ have session type) such that $\Gamma
%% \vdash M : T$ then one of the following holds:
%% \begin{enumerate}
%% \item $M$ is a value; or
%% \item there exists $N = \blockedp'(y_1, M_1) \rpar{x_1} \dots \rpar{x_{n}} \blockedp'(y_{n}, M_{n})$
%%   such that $M \equiv N$ and $\Gamma \vdash N : T$; or
%% \item there exists $N$ such that $M \rto N$.
%% \end{enumerate}
%% \end{theorem}
%% %
%% \begin{proof}
%% By induction on the structure of the derivation of $\Gamma \vdash M : T$. \qed
%% \end{proof}
%% % In the second case each $y_i$ must be equal to either $x_i$ or some $x$ in $\Gamma$.
%%
%% \begin{theorem}
%% If $\vdash M : T$ then one of the following holds:
%% \begin{enumerate}
%% \item $M$ is a value; or
%% \item there exists $N = \blockedp(x_1, M_1) \rpar{x_1} \dots \rpar{x_{n-1}} \blockedp(x_{n-1},
%%   M_{n-1}) \rpar{x_n} V$ such that $M \equiv N$ and $\Gamma \vdash N : T$; or
%% \item there exists $N$ such that $M \rto N$.
%% \end{enumerate}
%% \end{theorem}
%% %
%% \begin{proof}
%% By induction on the structure of the derivation of $\vdash M : T$ using
%% \thmref{free-progress}. \qed
%% \end{proof}
%%
%% $\blockedp(x, M)$ means $M$ is blocked on a send or receive involving $x$.
%%
%% $\blockedp'(x, M)$ means either $M = x$ or $M$ is blocked on a send, receive, link, or wait
%% involving $x$.

\subsection{Determinism and Termination}\label{sec:determinism}

It is straightforward to show that GV is deterministic. In fact, GV enjoys a strong form of
determinism, called the diamond property~\cite{Barendregt84}.
\begin{theorem}
% For well typed terms, the relation $\equiv\ceval\equiv$ satisfies the diamond property:
  If $\Gamma \vdash C$, $C \equiv\ceval\equiv D_1$, and $C \equiv\ceval\equiv D_2$, then there
  exists $D_3$ such that $D_1 \equiv\ceval\equiv D_3$, and $D_2 \equiv\ceval\equiv D_3$.
\end{theorem}
\begin{proof}
First, observe that $\teval$ is deterministic, and furthermore configuration reductions always treat
$\teval$ redexes linearly. This means we need only consider the interaction between different
configuration reductions.
%
Linear typing ensures that two configuration reductions cannot overlap. Furthermore, each
configuration reduction is linear in the existing redexes, so we can straightforwardly perform the
reductions in either order. \qed
\end{proof}
%
It is not hard to see that the system remains deterministic if we extend the functional part of GV
with any well-typed confluent reduction rules at all.

\begin{theorem}[Strong normalisation]
  If $\Gamma \vdash C$, then there are no infinite $\equiv\ceval\equiv$ reduction sequences
  beginning from $C$.
\end{theorem}
To prove strong normalisation for core GV, one can use an elementary argument based on
linearity. When we add replication~\secref{gv-repl} and other features, a standard logical relations
argument suffices. Strong normalisation also follows as a direct corollary of
\thmref{gv-reduction-simulated} and the cut-elimination theorem for classical linear logic.
 
\section{Classical Linear Logic}

\label{sec:cp}

%% \subsection{CP}
%% \label{sec:cp}

\begin{figure}[float]
\vspace{1ex}
~Syntax
\begin{syntax}
  \text{Types} & A,B & ::= & A \otimes B \mid A \parr B \mid 1 \mid \bot \mid A \oplus B \mid A \with B \mid 0 \mid \top \\
  \text{Terms} & P,Q & ::= & \link x y \mid \cut y {} P Q \mid x(y).P \mid x[y].(P \mid Q) \\
   & & \mid & x[in_i].P \mid \case{x}{P;Q} \mid x().P \mid x[].0 \mid \case{x}{} \\
\end{syntax}
~Duality
\[
\ba{@{}c@{\qquad}c@{\qquad}c@{\qquad}c@{}}
\begin{eqs}
  \cpdual{(A \otimes B)} &=& \cpdual{A} \parr \cpdual{B} \\
  \cpdual{(A \parr B)} &=& \cpdual{A} \otimes \cpdual{B} \\
\end{eqs}
&
\begin{eqs}
  \cpdual{1} &=& \bot \\
  \cpdual{\bot} &=& 1 \\
\end{eqs}
&
\begin{eqs}
  \cpdual{(A \oplus B)} &=& \cpdual{A} \with \cpdual{B} \\
  \cpdual{(A \with B)} &=& \cpdual{A} \oplus \cpdual{B} \\
\end{eqs}
&
\begin{eqs}
  \cpdual{\top} &=& 0 \\
  \cpdual{0} &=& \top \\
\end{eqs}
\ea
\]
~Typing
\begin{mathpar}
\inferrule{ }{\cptyp{\link{x}{w}}{x:A,w:\cpdual{A}}}

\inferrule{\cptyp{P}{\Delta,y:A} \\
           \cptyp{Q}{\Delta',y:\cpdual{A}}}
          {\cptyp{\cut{y}{A}{P}{Q}}{\Delta,\Delta'}}

\inferrule{ }{\cptyp{x[].0}{x:1}}

\inferrule{\cptyp{P}{\Delta,y:A,x:B}}
          {\cptyp{x(y).P}{\Delta,x:A \parr B}}

\inferrule{\cptyp{P}{\Delta,y:A} \\
           \cptyp{Q}{\Delta',x:B}}
          {\cptyp{x[y].(P \mid Q)}{\Delta,\Delta',x:A \otimes B}}

\inferrule{\cptyp{P}{\Delta}}
          {\cptyp{x().P}{\Delta,x:\bot}}

\inferrule{\cptyp{P}{\Delta,x:A_i}}
          {\cptyp{\sel{x}{in_i}.P}{\Delta,x:A_1 \oplus A_2}}

\inferrule{\cptyp{P}{\Delta,x:A} \\
           \cptyp{Q}{\Delta,x:B}}
          {\cptyp{\case{x}{P;Q}}{\Delta,x:A \with B}}

\inferrule{ }{\cptyp{\case{x}{}}{\Delta,x:\top}}
\end{mathpar}
\caption{CP Syntax and Typing}\label{fig:cp-typing}
\end{figure}

\figref{cp-typing} gives the syntax and typing rules for the multiplicative-additive fragment of CP;
we let $\Delta$ range over typing environments.  CP types and duality are the standard propositions
and duality function of classical linear logic, while the terms are based on a subset of the
$\pi$-calculus.  The types $\with$ and $\oplus$ are interpreted as external and internal choice; the
types $\parr$ and $\otimes$ are interpreted as input and output, while their units $\bot$ and $1$
are interpreted as nullary input and output.  Note that CP's typing rules implicitly rebind
identifiers: for example, in the hypothesis of the rule for $\parr$, $x$ identifies a proof of $B$,
while in the conclusion it identifies a proof of $A \parr B$.

CP includes two rules that are logically derivable: the axiom rule, which is interpreted as channel
forwarding, and the cut rule, which is interpreted as process composition.

Two of CP's terms differ from standard $\pi$-calculus terms.  The first is
com\-pos\-i\-tion---rather than having distinct name restriction and composition operators, CP
provides one combined operator.  This captures syntactically the restriction that composed processes
must share exactly one channel.  The second is output: the CP term $x[y].(P \mid Q)$ includes
output, composition, and name restriction (the name $y$ designates a new channel, bound in $P$).  We
will frequently write $x\sd{y}.P$ to abbreviate $x[z].(\link y z \mid P)$ (see
Appendix~\ref{sec:send} for more discussion of output in CP).

\subsubsection{Cut Elimination.}

\begin{figure}[float]
\vspace{1ex}
~Structural congruence
\begin{equations}
  \link{x}{w} &\equiv& \link{w}{x} \\
  \cut{y}{A}{P}{Q} &\equiv& \cut{y}{\cpdual{A}}{Q}{P} \\
  \cut{y}{A}{P}{\cut{z}{B}{Q}{R}} &\equiv& \cut{z}{B}{\cut{y}{A}{P}{Q}}{R}, \quad \text{if $y \not\in \fv(R)$} \\
\cut{x}{}{P_1}{Q} &\equiv& \cut{x}{}{P_2}{Q}, \quad \text{if $P_1 \equiv P_2$}
\end{equations}
~Primary cut reduction rules
\begin{equations}
\cut{x}{A}{\link{w}{x}}{P}
  &\crto& P[w/x] \\
\cut{x}{A \otimes B}{x[y].(P \mid Q)}{x(y).R}
  &\crto&
    \cut{x}{A}{Q}{\cut{y}{B}{P}{R}} \\
\cut{x}{1}{x[].0}{x().P}
  &\crto&
    P \\
\cut{x}{A \oplus B}{\sel{x}{in_i}.P}{\case{x}{Q_1; Q_2}}
  &\crto&
    \cut{x}{A}{P}{Q_i} \\
\cut{x}{}{P_1}{Q} &\crto& \cut{x}{}{P_2}{Q}, \quad \text{if $P_1 \crto P_2$}
\end{equations}
~Commuting conversions
\begin{equations}
  \cut{z}{A}{x[y].(P \mid Q)}{R} &\ccto& x[y].(\cut{z}{A}{P}{R} \mid Q), \qquad \text{if $z \not\in \fv(Q)$} \\
  \cut{z}{A}{x[y].(P \mid Q)}{R} &\ccto& x[y].(P \mid \cut{z}{A}{Q}{R}), \qquad \text{if $z \not\in \fv(P)$} \\
  \cut{z}{A}{x(y).P}{Q} &\ccto& x(y).\cut{z}{A}{P}{Q} \\
  \cut{z}{}{x().P}{Q} &\ccto& x().\cut{z}{}{P}{Q} \\
  \cut{z}{A}{\sel{x}{in_i}.P}{Q} &\ccto& \sel{x}{in_i}.\cut{z}{A}{P}{Q} \\
  \cut{z}{A}{\case{x}{P;Q}}{R} &\ccto& \case{x}{\cut{z}{A}{P}{R}; \cut{z}{A}{Q}{R}} \\
\end{equations}
\caption{CP Congruences and Cut Reduction}\label{fig:cp-reduction}
\end{figure}

The semantics of CP terms are given by cut reduction, as shown in \figref{cp-reduction}.  We write
$\fv(P)$ for the free names of process $P$.  Terms are identified up to structural congruence
$\equiv$ (as name restriction and composition are combined into one form, composition is not always
associative). We write $\crto$ for the cut reduction relation, $\ccto$ for the commuting conversion
relation, and $\rto$ for $\crto \cup \ccto$.  The majority of the cut reduction rules correspond
closely to synchronous reductions in $\pi$-calculus---for example, the reduction of $\with$ against
$\oplus$ corresponds to the synchronisation of an internal and external choice.  The rule for
reduction of $\parr$ against $\otimes$ is more complex than synchronisation of input and output, as
it must also manipulate the implicit name restriction and composition in CP's output term. The
commuting conversions do not correspond to any reduction rule in $\pi$-calculus. We write $\bigrto$
for $(\equiv\rto\equiv)^+$, $\bigcrto$ for $(\equiv\crto\equiv)^+$, and $\bigccto$ for
$\bigcrto(\ccto^\star)$.

Just as cut elimination in logic ensures that any proof may be transformed into an equivalent
cut-free proof, the reduction rules of CP transform any term into a term blocked only on external
communication---that is to say, if $P \vdash \Delta$, then $P \bigccto P'$ where $P' \not= \cut x {}
Q {Q'}$ for any $x,Q,Q'$. The final commuting conversions play a central role in this
transformation, moving any remaining internal communication after an external communication.

\subsection{Translation from CP to GV}\label{sec:togv}

\begin{figure}[float]
\vspace{1ex}
~On types
\[
\ba{@{}c@{\quad}c@{\quad}c@{\quad}c}
\begin{eqs}
\togv{A \otimes B} &=& \gvout{\gvdual{\togv{A}}}{\togv{B}} \\
\togv{A \parr B}   &=& \gvin{\togv{A}}{\togv{B}} \\
\end{eqs}
&
\begin{eqs}
\togv{1}           &=& \outterm \\
\togv{\bot}        &=& \interm \\
\end{eqs}
&
\begin{eqs}
\togv{A \oplus B} &=& \togv{A} \oplus \togv{B} \\
\togv{A \with B}  &=& \togv{A} \with \togv{B}
\end{eqs}
&
\begin{eqs}
\togv{0}    &=& \oplus \{ \} \\
\togv{\top} &=& \with \{ \}
\end{eqs}
\ea
\]
~On terms
\begin{equations}
  \togv{\cut{x}{}{P}{Q}} &=&
    \gvlet{x}{\gvfork{x}{\togv{P}}}{\togv{Q}} \\
  \togv{\link{x}{y}} &=& \gvlink{x}{y} \\
  \togv{x[y].(P \mid Q)} &=&
    \gvlet{x}{\gvsend{(\gvfork{y}{\togv{P}}, x)}}{\togv{Q}} \\
%%   \togv{x[y].P} &=&
%%     \gvlet{x}{\gvsend{(y, x)}}{\togv{P}} \\
  \togv{x(y).P} &=&
    \gvlet{(y,x)}{\gvreceive{x}}{\togv{P}} \\
  \togv{x[].0} &=& x \\
  \togv{x().P} &=& \gvlet{()}{\gvwait{x}}{\togv{P}} \\
  \togv{\sel{x}{\mathit{l}}.P} &=&
    \gvlet{x}{\gvselect{l}{x}}{\togv{P}} \\
  \togv{\case{x}{P;Q}} &=&
    \mkwd{offer} \: x \: \{ \mkwd{inl} \app x \mapsto \togv P; \mkwd{inr} \app x \mapsto \togv Q \} \\
  \togv{\case{x}{}} &=& \gvlet{(y,x)}{\gvreceive{x}}{\mkwd{absurd}\app y}
\medskip
\\
  \togvc{\cut{x}{}{P}{Q}} &=&
    (\nu x)(\togvc{P} \parallel \togvc{Q}) \\
  \togvc{P} &=& \thread \togv{P}, \quad \text{$P$ is not a cut} \\
\end{equations}
\caption{Translation of CP Terms into GV}\label{fig:from-cp}
\end{figure}

In this section, we show that GV can simulate CP. \figref{from-cp} gives the translation of CP into
GV; typing environments are translated by the pointwise extension of the translation on types.  We
rely on our encoding of choice in GV~\secref{gv-static}.
%% , extended to nullary branching
%% and choice as follows:
%% \begin{mathpar}
%% \with \{ \} \defeq \gvin{\zero}{\interm}

%% \oplus \{ \} \defeq \gvout \zero \outterm
%% \end{mathpar}

In translating CP terms to GV terms, the key observation is that CP terms contain their
continuations; for example, the translation of input includes both a call to \gvconst{receive} and
the translation of the continuation.  Additionally, the rebinding that is implicit in CP syntax is
made explicit in GV.  The translation $\togvc{-}$ translates top-level composition (i.e.,
composition not under any prefix) to GV configurations; cuts that appear under prefixes are
translated to applications of \gvconst{fork}.  As CP processes do not have return values, the
translation of a CP process contains no main thread.

It is straightforward to see that the translation preserves typing; note that the channels in the CP
typing environment become free variables in its translation.
%
\begin{theorem}
If $P \vdash \Delta$ then $\togv{\Delta} \vdash^\wcirc \togvc{P}$.
\end{theorem}
%
Structural congruence in CP is a subset of the structural congruence relation for GV configurations;
thus the translation trivially preserves congruence.
%
\begin{theorem}
If $P \equiv Q$, then $\togvc{P} \equiv \togvc{Q}$.
\end{theorem}
%
Finally, observe that the translation of any prefixed CP term is a GV thread of either the form $F[K
\app M]$ for $K \in \{ \gvconst{send}, \gvconst{receive}, \gvconst{wait} \}$ or is $\wcirc x$ for
some variable $x$.  Thus, we can see that any cut reduction immediately possible for a process $P$
is similarly possible for $\togv{P}$.  Following such a reduction, several additional GV reductions
may be necessary to expose the next possible communication, such as substituting the received values
into the continuation in the case of the translation of input, or spawning new threads in the
translation of composition.
%
\begin{theorem}\label{thm:cp-reduction-simulated}
If $P \vdash \Delta$ and $P \crto Q$, then $\togvc{P} \rto^+ \togvc{Q}$.
\end{theorem}
%
\begin{proof}
  By induction on $P$; the cases are all straightforward.
\end{proof}
%
The commuting conversions in CP do not expose additional reductions, but are only necessary to
assure that the result of evaluation does not have a cut at the top level.  Our characterisation of
deadlock freedom in GV has no such requirement, so we have no need of corresponding steps in GV.


%% \subsection{Functions as Processes}
%%
%% \todo{Probably scrap this, as it turns out to be wrong.}
%%
%% Following our previous work, we show that functions in GV can be translated into processes, and in
%% particular that the translation respects the semantics.

%% \[
%% \topi{T \lto U} = \gvout{\topi{T}}{\topi{U}}
%% \]
%%
%% \begin{equations}
%% \topi{\lambda x.M} &=& \gvfork{z}{\gvlet{(x, z)}{\gvreceive{z}}{\gvlink{\topi{M}}{z}}} \\
%% \topi{L\,M}        &=& \gvsend{(\topi{M},\topi{L})} \\
%% \topi{\gvfork{x}{M}} &=& \gvfork{x}{\gvsend{(x,\topi{M})}} \\
%% \end{equations}
%%
%%
\subsection{Translation from GV to CP}\label{sec:tocp}

In this section, we show that CP can simulate GV. \figref{from-gv-types} gives the translation on
types and \figref{from-gv-terms} gives the translation on terms, substitutions, and configurations;
we translate typing environments by the pointwise extension of the translation on types.

\begin{figure}[float]
\vspace{1ex}
~Session types
\[
\bl
\tocp{\gvout{T}{S}}        = \cpdual{\tocp{T}} \otimes \tocp{S} \qquad
\tocp{\gvin{T}{S}}         = \tocp{T} \parr \tocp{S} \qquad
\tocp{\outterm}            = 1 \qquad
\tocp{\interm}             = \bot \\
\el
\]
~Functional types
\[
\tocp{T} = \cpdual{\tocpflip{T}}, \quad \text{if $T$ is not a session type}
\]
%
\[
\ba{@{}c@{\qquad}c@{\qquad}c}
\begin{eqs}
\tocpflip{\zero} &=& \tocpflip{0} \\
\tocpflip{T \gvplus U} &=& \tocpflip{T} \oplus \tocpflip{U} \\
\end{eqs}
&
\begin{eqs}
\tocpflip{\one} &=& \tocpflip{1} \\
\tocpflip{T \gvtimes U} &=& \tocpflip{T} \otimes \tocpflip{U} \\
\end{eqs}
\ea
\]%
\begin{equations}
\tocpflip{T \lto U} &=& \cpdual{\tocpflip{T}} \parr \tocpflip U \\
\tocpflip{S} &=& \tocp{S} \\
\end{equations}
\caption{Translation of GV Types into CP}\label{fig:from-gv-types}
\end{figure}

\begin{figure}[float]
\vspace{1ex}
~Session terms
\begin{equations}
\tocp{\gvconst{fork}\:M}z &=&
  \boringcut{w}{}{\link w z}{\cut{x}{}{\tocp{M}x}{\cut{y}{}{x\sd{w}.\link x y}{y[]}}} \\
%% \tocp{\gvconst{fork}\:(\clos{\sigma}{x}{M})}z &=&
%%   \tocp{\sigma}(\cut{x}{}{\cut{y}{}{\tocp{M}{y}}{y[]}}{\link x z}) \\
%% \tocp{\gvlink{M}{N}}z &=& \cut{x}{}{\tocp{M}x}{\cut{y}{}{\tocp{N}y}{z().\link x y}} \\
\tocp{\gvlink{M}{N}}z &=&
  \boringcut{v}{}{\link v z}
    {\boringcut{w}{}{\link v w}
%&& \quad
      {\cut{x}{}{\tocp{M}x}{\cut{y}{}{\tocp{N}y}{w().\link x y}}}} \\
\tocp{\gvsend{(M,N)}}z &=&
  \cut{x}{}{\tocp{N}x}{\cut{y}{}{\tocp{M}y}{x\sd{y}.\link x z}} \\
%% SL: we need these eta-expanded definitions for receive and wait
%% in order for the simulation theorem to hold
\tocp{\gvreceive{M}}z &=&
  \cut{y}{}{\tocp{M}y}{y(x).\boringcut{w}{}{\link w y}{z\sd{x}.\link w z}} \\
\tocp{\gvwait{M}}z    &=&
  \boringcut{y}{}{\link y z}{\tocp{M}y} \\
%  \cut{y}{}{\tocp{M}y}{y().z[]} \\
%% \tocp{\gvreceive{M}}z &=& \tocp{M}z \\
%% \tocp{\gvwait{M}}z    &=& \tocp{M}z \\
\end{equations}
~Functional terms
\begin{equations}
\tocp{x}z &=& \link x z \\
\tocp{\lambda^\sigma x.M}z                         &=& \tocp{\sigma}(z(x).\tocp{M}z) \\
\tocp{L \app M}z                                 &=&
  \cut{x}{}{\tocp{M}x}{\cut{y}{}{\tocp{L}y}{y\sd{x}.\link y z}} \\
\tocp{()}z                                       &=& z[] \\
\tocp{\gvlet{()}{M}{N}}z                         &=& \cut{y}{}{\tocp{M}y} {y().\tocp{N}z} \\
\tocp{(M,N)}z                                    &=& \cut{x}{}{\tocp{M}x}{\cut{y}{}{\tocp{N}y}{z\sd{x}.\link y z}} \\
\tocp{\gvlet{(x,y)}{M}{N}}z                      &=& \cut{y}{}{\tocp{M}y}{y(x).\tocp{N}z} \\
\tocp{\mkwd {inl} \app M}z                       &=& \cut{x}{}{\tocp{M}x}{z[in_1].\link x z} \\
\tocp{\mkwd {inr} \app M}z                       &=& \cut{x}{}{\tocp{M}x}{z[in_2].\link x z} \\
\tocp{\gvcase{L}{\mkwd {inl} \app x \mapsto M;
                 \mkwd {inr} \app x \mapsto N}}z &=&
   \cut x {} {\tocp{L}x} {\case{x}{\tocp{M}z;
                                   \tocp{N}z}} \\
\tocp{\mkwd{absurd} \app L}z                     &=& \cut x {} {\tocp{L}x} {\mkwd{case}\app x \app \{ \}}
\end{equations}
~Substitutions
\begin{equations}
\tocp{\{\bind{x_i}{V_i}\}}(P) &=& \hat{\nu}(x_i \mapsto \tocp{V_i}x_i)_i[P] \medskip\\
\hat{\nu}(x_i \mapsto P_i)_i[P] &\defeq& \cut{x_1}{}{P_1}{\dots \cut{x_n}{}{P_n}{P}\dots}
\end{equations}
~Configurations
\begin{equations}
\tocp{\thread M}z        &=& \cut{y}{}{\tocp{M}y}{y[]} \\
\tocp{\distinguish M}z   &=& \tocp{M}z \\
\tocp{(\nu x)C}z         &=& \tocp{C}z \\
\tocp{C \parallel_x C'}z &=& \cut{x}{}{\tocp{C}z}{\tocp{C'}z} \\
\end{equations}
\caption{Translation of GV Terms, Substitutions, and Configurations into CP}\label{fig:from-gv-terms}
\end{figure}

The translation on session types is homomorphic except for output, where the output type is
dualised. This accounts for the discrepancy between $\gvdual{!T.S} = ?T.S$ and $\cpdual{(A \otimes
  B)} = \cpdual{A} \parr \cpdual{B}$.
%
Following our previous work~\cite{LindleyM14}, the translation on functional types is factored
through an auxiliary translation $\tocpflip{-}$. The intuition is that the translation $\tocp{T}$ of
a functional type $T$ is the type of its \emph{interface}, whereas $\tocpflip{T}$ is the type of its
\emph{implementation}.

As CP processes do not have return values, the translation $\tocp{M}z$ of a term $M$ of type $T$
includes the additional argument $z:\cpdual{\tocp{T}}$, which is a channel for simulating the return
value.
%
The translation on session terms is somewhat complicated by the need to include apparently trivial
axiom cuts (highlighted in grey).  These are needed to align with the translation of values, which
permit further reduction inside the value constructors.
%
The output in the translation of a fork arises from the need to apply the argument to a freshly
generated channel (notice that application is simulated by an output). Linking is simulated by a
link ($\leftrightarrow$) guarded by a nullary input which matches the nullary output of the output
channel. Sending is simulated by output as one might expect. Receiving is simulated by input
composed with sending the result to the return channel. Waiting is simulated by simply connecting
the result to the return channel.

Variables are linked to the return channel. Closures are simulated by input, subject to an
appropriate substitution, and application by output. Unit values are simulated by empty output to
the return channel. Pairs are simulated by evaluating both components in parallel and transmitting
the results to the return channel. Injections are simulated by injections. Each elimination form
(other than application) guards the continuation with a suitable prefix, delaying reduction of the
continuation until a value has been computed to pass to it.

The translation of configurations is quite direct. We write $C \parallel_x C'$ to indicate that the
variable $x$ is shared by $C$ and $C'$; in a well-typed GV configuration, there will always be
exactly one such variable, so the translation is unambiguous.

Our translation differs from both Wadler's~\cite{Wadler14} and our previous one~\cite{LindleyM14},
neither of which simulate even plain $\beta$-reduction. This is because the obvious translation to
CP cannot simulate substitution under a lambda abstraction, motivating our use of closures / weak
explicit substitution.
%
Indeed, others have taken advantage of full explicit substitutions in order simulate small-step
semantics of $\lambda$-calculi in the full $\pi$-calculus~\cite{BakelV09}.

Another departure from the previous translations to CP is that, despite the call-by-value semantics
of GV, our translation is more in the spirit of call-by-name. For instance, in the translation of an
application $L \app M$, the evaluation of $L$ and $M$ can happen in parallel, and $\beta$-reduction
can occur before $M$ has reduced to a value. The previous translations hide the evaluation of $M$
behind the prefix $y\sd{x}$, which means that reduction of $M$ can get stuck in the case that $L$ is
a free variable.
%
Short of performing CPS transformation on the translation, our new approach seems necessary in order
to ensure that $\tocp{-}$ preserves reduction.



%% %
%% As a concrete example, consider the following $\beta$-reduction using implicit substitution:
%% \[
%% (\lambda x.\lambda y.\gvwait{y}; x) \app () \teval \lambda y.\gvwait{y}; ()
%% \]
%% The old translation on the left-hand side yields a CP term $P$ that reduces to:
%% \[
%% z(y).y().\cut{x}{}{x[]}{\link{x}{z}}
%% \]
%% and the old translation on the right-hand side yields a CP term $Q$:
%% \[
%% z(y).y().z[]
%% \]
%% There is no way of reducing $P$ to $Q$ as the remaining cut is inside a prefix.
%% %
%% In contrast, with closures, the $\beta$-reduction becomes:
%% \[
%% (\lambda x.\lambda y.\gvwait{y}; x) \app () \teval \lambda y^{x \mapsto ()}.\gvwait{y}; x
%% \]
%% The new translation on the left-hand side yields a CP term that reduces to:
%% \[
%% \cut{x}{}{x[]}{z(y).\cut{v}{}{\cut{w}{}{\link y w}{\link v w}}{v().\link x z}}
%% \]
%% and the new translation on the right-hand side yields this term directly.
%% %
%% Another departure from our previous work is that, despite the call-by-value semantics of GV, our
%% translation is more in the spirit of call-by-name. For instance, in the translation of an
%% application $L \app M$, the evaluation of $L$ and $M$ can happen in parallel, and $\beta$-reduction
%% can occur before $M$ has reduced to a value. The old translation hides the evaluation of $M$ behind
%% the prefix $y\sd{x}$, which means reduction of $M$ can get stuck in the case that $L$ is a free
%% variable.
%% %
%% Short of performing a CPS transformation on the transformation, our new approach seems necessary in
%% order to ensure that $\tocp{-}$ preserves reduction.


It is straightforward to show that the translation preserves typing.
\begin{theorem}
~
\begin{enumerate}
\item If $\Gamma \vdash M : T$, then $\tocp{M}z \vdash \tocp{\Gamma}, z:\cpdual{\tocp{T}}$.
\item If $\Gamma \vdash C$, then $\exists T. \tocp{C}z \vdash \tocp{\Gamma}, z:\cpdual{\tocp{T}}$.
\end{enumerate}
\end{theorem}
\begin{proof}
By induction on derivations.\qed
\end{proof}

We now show that reduction in GV is preserved by reduction in CP. First, we observe that structural
equivalence is preserved.
%
\begin{theorem}
If $\Gamma \vdash C$, $\Gamma \vdash D$, and $C \equiv D$, then $\tocp{C}z \equiv \tocp{D}z$.
\end{theorem}
%
\begin{proof}
By induction on the derivation of $\Gamma \vdash C$.\qed
\end{proof}

As the translation on terms and configurations are compositional, we can mechanically lift them to
translations on evaluation contexts and configuration contexts such that the following lemma holds
by construction.
%
Each translation of a context takes two arguments: a function that describes the CP term to plug
into the hole, and an output channel.
%
%% In order to ease reasoning by induction, we lift the translation on terms to contexts.
%% \begin{equations}
%% \tocp{\Ex}[\Ex{M}]z &=& \tocp{\Ex[M]}z \\
%% \tocp{\Fx}[\Fx{M}]z &=& \tocp{\Fx[M]}z \\
%% \tocp{\Gx}[\Gx{M}]z &=& \tocp{\Gx[M]}z \\
%% \end{equations}
%% That these equations are well-defined follows from compositionality of the translation on terms.
%% The following lemmas can be made to hold, by construction.
%
\begin{lemma}
\label{lem:compositional-contexts}
For $X \in \{ \Ex, \Fx, \Cx \}$, $\tocp{X[M]}z = \tocp{X}[\tocp M]z$
%% ~
%% \begin{enumerate}
%% \item $\tocp{\Ex[M]}z = \tocp{\Ex}[\tocp{M}]z$
%% \item $\tocp{\Fx[M]}z = \tocp{\Fx}[\tocp{M}]z$
%% \item $\tocp{\Cx[C]}z = \tocp{\Cx}[\tocp{C}]z$
%% \end{enumerate}
\end{lemma}
%
We will make implicit use of \lemref{compositional-contexts} throughout our proofs. We write
$x \mapsto P$ for a function that maps a name $x$ to a process $P$ that depends on $x$.

We now show that substitution commutes with $\tocp{-}$.
\begin{lemma}
\label{lem:tocp-subst}
If $\Gamma \vdash M : T$, $\Gamma \vdash \sigma : \Delta$, and $z \notin \dom(\sigma)$, then
$\tocp{\sigma}(\tocp{M}z) \bigrto \tocp{M \sigma}z$.
\end{lemma}
\begin{proof}
By induction on the structure of $M$. Here we show the cases for variables and closures.
\begin{itemize}
\item Case $x$. By linearity there exists $V$ such that $\sigma = \{\bind{x}{V}\}$.
\[
\tocp{\sigma}(\tocp{x}z) =
\cut{x}{}{\tocp{V}x}{\link{x}{z}} \rto \tocp{V}z = \tocp{x \sigma}z
\]
\item Case $\clos{\sigma'}{x}{M}$.
\[
\bl
\quad \tocp{\sigma}(\tocp{\clos{\sigma'}{x}{M}}) \\
= \quad (\sigma' = \{\bind{x_i}{V_i}\}_i) \\
\quad \tocp{\sigma}(\hat{\nu} (x_i \mapsto (\tocp{V_i}x_i))_i[z(x).\tocp{M}z]) \\
= \quad (\sigma = \sigma_1 \uplus \dots \uplus \sigma_n \text{ where } \dom(\sigma_i) = \fv(V_i)) \\
\quad \tocp{\sigma_1}(\dots\tocp{\sigma_n} (\hat{\nu} (x_i \mapsto \tocp{V_i}x_i)_i[z(x).\tocp{M}z])) \\
= \quad (\text{structural equivalence}) \\
\quad \hat{\nu} (x_i \mapsto \tocp{\sigma_i}(\tocp{V_i}x_i))_i[z(x).\tocp{M}z] \\
\bigrto (\text{IH}) \\
\quad \hat{\nu} (x_i \mapsto \tocp{V_i \sigma_i}x_i)_i[z(x).\tocp{M}z] \\
= \quad (V_i \sigma_i = V \sigma) \\
\quad \hat{\nu} (x_i \mapsto \tocp{V_i \sigma}x_i)_i[z(x).\tocp{M}z] \\
= \quad (\text{definition of }\tocp{-}) \\
\quad \tocp{\clos{\sigma' \sigma}{x}{M}} \\
= \quad (\text{definition of substitution}) \\
\quad \tocp{\clos{\sigma'}{x}{M} \sigma} \\
\el
\]
\end{itemize}
Each of the remaining non-binding form cases follows straightforwardly using the induction
hypothesis. Each of the remaining binding form cases requires a commuting conversion to push the
appropriate substitution through a prefix.\qed
\end{proof}

%% [INLINED]
%%
%% \begin{lemma}
%% If $\tocp{M}z \rto \tocp{N}z$ then $\tocp{E}[\tocp{M}]z \rto \tocp{E}[\tocp{N}]z$.
%% \end{lemma}
%% \begin{proof}
%% This follows straightforwardly by observing that the translation of an evaluation context never
%% places its argument inside a prefix.
%% \end{proof}

Using the substitution lemma, we prove that $\tocp -$ preserves reduction on terms.
%
\begin{theorem}
\label{thm:teval-preserved}
If $\Gamma \vdash M$, $\Gamma \vdash N$, and $M \teval N$, then $\tocp{M}z
\bigrto \tocp{N}v$.
\end{theorem}
%
\begin{proof}
By induction on the derivation of $M \teval N$. Here we show the case of $\beta$-reduction.
\begin{itemize}
\item Case $(\lambda^\sigma x.M)\,V \teval M(\{\bind x V\} \cup \sigma)$.
\[
\bl
\quad \tocp{(\lambda^\sigma x.M)\,V}z \\
= \quad (\text{definition of }\tocp{-}) \\
\quad \cut{w}{}{\tocp{V}w}{\cut{y}{}{\tocp{\sigma}(y(x).\tocp{M}y)}{y[x](\link{w}{x} \mid \link{y}{z})}} \\
\bigcrto (\text{cut send against receive}) \\
\quad \cut{w}{}{\tocp{V}w}{\cut{y}{}{\link{y}{z}}{\cut{x}{}{\link{w}{x}}{\tocp{\sigma}(\tocp{M}y)}}} \\
\bigcrto (\text{cut links and $\alpha$ rename}) \\
\cut{x}{}{\tocp{V}x}{\tocp{\sigma}(\tocp{M}z)} \\
\bigrto \quad (\text{by \lemref{tocp-subst}}) \\
\tocp{M(\{\bind x V\} \uplus \sigma)}
\el
\]
\end{itemize}
The remaining base cases are similarly direct. The inductive case for reduction inside an evaluation
context follows straightforwardly by observing that the translation of an evaluation context never
places its argument inside a prefix.\qed
\end{proof}

Finally, we prove that $\tocp{-}$ preserves reduction on configurations.
%
\begin{theorem}
\label{thm:gv-reduction-simulated}
If $\Gamma \vdash C$, $\Gamma' \vdash D$, $\Gamma \rto \Gamma'$, and $C \ceval D$, then $\tocp{C}z
\bigrto \tocp{D}z$.
\end{theorem}
\begin{proof}
  By induction on the derivation of $C \ceval D$. The inductive cases follow straightforwardly from
  the compositionality of the definitions and \thmref{teval-preserved}. We give a representative
  example of the base cases. The other cases appear in Appendix~\ref{sec:proofs}.
\begin{itemize}
\item Case $\Fx[\gvconst{send} \app (V,x)] \parallel \Fx'[\gvconst{receive} \app x] \ceval \Fx[x]
  \parallel \Fx'[(V,x)]$.
%
\[
\bl
\quad \tocp{\Fx[\gvconst{send} \app (V,x)] \parallel \Fx'[\gvconst{receive} \app x]}z \\
= \\
\quad \cut{x}{}
        {\tocp{\Fx}[\tocp{\gvconst{send} \app (V,x)}y]z}
        {\tocp{\Fx'}[\tocp{\gvconst{receive} \app x}]z} \\
= \\
\quad
  \nu x(
    {\tocp{\Fx}
      [z \mapsto \cut{v}{}{\tocp{V}v}
        {\cut{w}{}{\link{x}{w}}{w\sd{v}.\link{w}{z}}}]z} \\
\qquad \mid
    {\tocp{\Fx'}
       [z \mapsto \cut{y}{}
          {\link{x}{y}}
          {y(v).\cut{w}{}{\link{y}{w}}{z\sd{v}.\link{w}{z}}}]z} \\
\bigcrto (\text{cut links}) \\
\quad
  \nu x(
    {\tocp{\Fx}
       [z \mapsto \cut{v}{}{\tocp{V}v}
         {x\sd{v}.\link x z}]z} \\
\qquad \mid
    {\tocp{\Fx'}
       [z \mapsto x(v).\cut{w}{}{\link{x}{w}}{z\sd{v}.\link{w}{z}}]z} \\
\bigcrto (\text{cut send against receive}) \\
\quad
  \cut{x}{}
    {\tocp{\Fx}
       [z \mapsto
         \cut{v}{}{\tocp{V}v}{\link x z}]}
    {\tocp{\Fx'}
       [z \mapsto \cut{w}{}{\link{x}{w}}{z\sd{v}.\link{w}{z}}]z} \\
\equiv \\
\quad
  \cut{x}{}
    {\tocp{\Fx}[z \mapsto \link x z]z}
    {\tocp{\Fx'}[z \mapsto
      \cut{v}{}{\tocp{V}v}
        {\cut{w}{}{\link{x}{w}}
          {z\sd{v}.\link{w}{z}}}]z} \\
= \\
\quad \tocp{\Fx[x] \parallel \Fx'[(V,x)]} \\
\el
\]

%% This is what goes wrong if we don't use the convoluted translation of receive.
%% \[
%% \bl
%% \quad \tocp{\gvconst{send} \app (V,x) \parallel \distinguish{\gvconst{receive} \app x}}z \\
%% = \\
%% \quad \cut{x}{}
%%         {\cut{y}{}{\tocp{\gvconst{send} \app (V,x)}y}{y[]}}
%%         {\tocp{\gvconst{receive} \app x}z} \\
%% = \\
%% \quad
%%   \cut{x}{}
%%     {\cut{y}{}{
%%      \cut{v}{}{\tocp{V}v}
%%       {\cut{w}{}{\link{x}{w}}{w[v].\link{w}{y}}}}{y[]}}
%%     {\link x z} \\
%% = \\
%% \quad
%%   \cut{v}{}{\tocp{V}v}
%%     {\cut{x}{}
%%       {\cut{y}{}
%%         {\cut{w}{}{\link{x}{w}}{w[v].\link{w}{y}}}{y[]}}
%%       {\link x z}} \\
%% = \\
%% \quad
%%   \cut{v}{}{\tocp{V}v}
%%     {\cut{y}{}
%%       {\cut{x}{}
%%         {\cut{w}{}{\link{x}{w}}{w[v].\link{w}{y}}}{\link x z}}
%%       {y[]}} \\
%% = \\
%% \quad
%%   \cut{v}{}{\tocp{V}v}
%%     {\cut{y}{}
%%       {\cut{w}{}
%%         {\cut{x}{}
%%           {\link{x}{w}}
%%           {\link x z}}
%%         {w[v].\link{w}{y}}}
%%       {y[]}} \\

%% %% \rto^* \\
%% %% \quad
%% %%     \cut{y}{}{
%% %%      \cut{v}{}{\tocp{V}v}
%% %%       {z[v].\link{z}{y}}}{y[]} \\
%% %% = \\
%% %% \dots \\
%% %% = \\
%% %% \quad
%% %%   \cut{x}{}
%% %%     {x[]}
%% %%     {\cut{v}{}{\tocp{V}v}
%% %%       {z[v].\link{x}{z}}} \\
%% %% {}^*\!\longleftarrow \\
%% = ...\\
%% \quad
%%   \cut{v}{}
%%     {\tocp{V}v}
%%     {\cut{y}{}
%%       {\cut{w}{}
%%         {\cut{x}{}
%%           {\link{x}{w}}
%%           {\link x y}}
%%         {z[v].\link{w}{z}}}
%%       {y[]}} \\
%% = \\
%% \quad
%%   \cut{v}{}
%%     {\tocp{V}v}
%%     {\cut{y}{}
%%       {\cut{x}{}
%%         {\link x y}
%%         {\cut{w}{}{\link{x}{w}}
%%           {z[v].\link{w}{z}}}}
%%       {y[]}} \\
%% = \\
%% \quad
%%   \cut{v}{}
%%     {\tocp{V}v}
%%     {\cut{x}{}
%%       {\cut{y}{}{\link x y}{y[]}}
%%       {\cut{w}{}{\link{x}{w}}
%%          {z[v].\link{w}{z}}}} \\
%% = \\
%% \quad
%%   \cut{x}{}
%%     {\cut{y}{}{\link x y}{y[]}}
%%     {\cut{v}{}{\tocp{V}v}
%%       {\cut{w}{}{\link{x}{w}}
%%          {z[v].\link{w}{z}}}} \\
%% = \\
%% \quad
%%   \cut{x}{}
%%     {\cut{y}{}{\link x y}{y[]}}
%%     {\tocp{(V,x)}z} \\
%% = \\
%% \quad \cut{x}{}{\cut{y}{}{\tocp{x}y}{y[]}}{\tocp{(V,x)}z} \\
%% = \\
%% \quad \tocp{x \parallel \distinguish{(V,x)}} \\
%% \el
%% \]
%%

\end{itemize}
\qed
\end{proof}




%% \paragraph{Why we need closures}

%% One might hope that reduction in GV without closures would be preserved by the translation to
%% CP. However, it turns out that this is not the case. Consider the following straightforward
%% $\beta$-reduction:
%% \[
%%   \tocp{(\lambda x.\lambda y.\gvwait{y}; x) \app ()}z \teval \lambda y.\gvwait{y}; ()
%% \]
%% Translating the left-hand side yields:
%% \[
%% \bl
%% \quad \tocp{(\lambda x.\lambda y.\gvwait{y}; x) \app ()}z \\
%% = \\
%% \quad \cut{w}{}{w(x).\tocp{\lambda y.\gvwait{y; x}w}}{\cut{x}{}{\tocp{()}x}{y[x].\link{y}{z}}} \\
%% \equiv \\
%% \quad \cut{w}{}{w(x).w(y).y().\link{x}{w}}{\cut{x}{}{x[]}{w[x].\link{w}{z}}} \\
%% \equiv \\
%% \quad \cut{x}{}{x[]}{\cut{w}{}{w(x).w(y).y().\link{x}{w}}{w[x].\link{w}{z}}} \\
%% \rto \\
%% \quad \cut{x}{}{x[]}{\cut{w}{}{w(y).y().\link{x}{w}}{\link{w}{z}}} \\
%% \rto \\
%% \quad \cut{x}{}{x[]}{z(y).y().\link{x}{z}} \\
%% \rto^* (\text{commuting conversions}) \\
%% \quad z(y).y().\cut{x}{}{x[]}{\link{x}{z}} = P \\
%% \el
%% \]
%% Translating the right-hand side yields:
%% \[
%% \bl
%% \quad \tocp{\lambda y.\gvwait{y}; ()} \\
%% = \\
%% \quad z(y).y().z[] = Q
%% \el
%% \]

%% Alas, $P$ does not reduce to $Q$.
%% %
%% Notice that we could reduce $P$ to $Q$ if we were allowed to reduce under a prefix.

%% %% As we have shown previously, we can translate a term $P$ from CP to GV and back, perform some
%% %% reductions, and arrive back at $P$.
%% %% \begin{theorem}
%% %% $\cut{z}{}{\togv{\tocp{P}}z}{z[]} \rto^* P$
%% %% \end{theorem}

\section{Extending GV}\label{sec:extend}

In this section, we consider two extensions of our core calculus: in the first, we have a single,
self-dual type for closed sessions; in the second, we support unlimited types.  In both cases, we
are able to directly apply our characterisation of deadlock to show that the extended systems are
deadlock free.

\subsection{Unifying $\interm$ and $\outterm$}\label{sec:gv-end}

\begin{figure}[float]
\vspace{1ex}
~Syntax
\begin{syntax}
  \text{Session types} & S & ::= & \gvout{T}{S} \mid \gvin{T}{S} \mid \gvend \mid \channel{S} \\
  \text{Constants} & K & ::= & \gvconst{send} \mid \gvconst{receive} \mid \gvconst{fork} \mid
    \gvconst{close} \mid \gvconst{link}\\
\end{syntax}
~Changes to duality
\[
  \gvdual \gvend = \gvend
\]
~Changes to type schemas for constants
\begin{mathpar}
\gvconst{fork} : (S \lto \one) \lto \gvdual S

\gvconst{close} : \gvend \lto \one

\gvconst{link} : S \gvtimes \gvdual S \lto \one
\end{mathpar}
\vspace{-4mm}
\caption{Syntax and Typing Rules for Combined Closed Channels}\label{fig:gv-end-syntax}
\end{figure}

We begin by defining a language, based on GV, but combining the types $\interm$ and $\outterm$ of
closed sessions.  \figref{gv-end-syntax} gives the alterations to the syntax and typing rules.  The
session types are updated to have a single, self-dual type $\gvend$; a new constant,
$\gvconst{close}$ is provided to eliminate sessions of type $\gvend$.  (In many existing systems,
sessions of type $\gvend$ are treated as unlimited, subject to weakening, rather than providing an
explicit \gvconst{close}.  We have left \gvconst{close} explicit to simplify the presentation.)  The
type schemas for \gvconst{fork} and \gvconst{link} have been simplified, as we no longer need to
build the elimination of closed sessions into \gvconst{fork}.  \figref{gv-end-conf-eval} gives the
updated evaluation rules for the extended language.  In addition to a new rule for \gvconst{close}
(replacing the rule for \gvconst{wait}), the rule for \gvconst{link} can be simplified significantly
(as it can now return a unit value instead of a closed channel).

\begin{figure}[float]
\vspace{1ex}
~Extended configuration equivalence
\begin{mathpar}
C \parallel \thread () \equiv C
\end{mathpar}
~Extended reduction rules (all other reduction rules apply as in GV)
\begin{mathpar}
\inferrule
  [Close]
  { }
  {(\nu x)(F[\gvconst{close} \app x] \parallel F'[\gvconst{close} \app x]) \ceval F[()] \parallel F'[()]}

\inferrule
[Link]
  { }
  {(\nu x)(F[\gvconst{link} \app (x,y)] \parallel C) \ceval F[()] \parallel C\{y/x\}}
\end{mathpar}
\vspace{-2mm}
\caption{Updated Configuration Evaluation Rules}\label{fig:gv-end-conf-eval}
\end{figure}

Our extended language is, perhaps surprisingly, strictly more expressive than GV.  To see this, we
can consider the following term (assuming well-typed $M,N$):
%
\[\bl
  \gvlet{w}{\gvconst{fork} \app (\lambda w. \gvletunit{\gvconst{close}\app w}{M})}{
  \gvletunit{\gvconst{close}\app w}{N}}
\el\]
%
Initially, the forked thread and its parent share (only) session $w$.  After both threads close $w$,
however, there can be no further communication between the threads; in contrast, in core GV, there
is always a final synchronisation with \gvconst{wait}.  To capture the increase in expressivity, we
must extend the existing configuration typing rules (\figref{gv-conf-typing}) with a rule for
composition in which no threads are shared (such as after the reduction of $\gvconst{close}\app w$
in the example):
\[
\inferrule
  {\Gamma \vdash^\phi C \\
   \Gamma' \vdash^{\phi'} C'}
  {\Gamma,\Gamma' \vdash^{\phi + \phi'} C \parallel C'}
\]

We have a slightly different result about channels shared between processes, to account for the
multiple possible typings of composition:
\begin{lemma}
  If $\Gamma \vdash C$ and $C = \Cx[D \parallel D']$, then $\fv(D) \cap \fv(D')$ is either empty or
  the singleton set $\{x\}$ for some variable $x$.
\end{lemma}
The proof is again by induction on the derivation of $\Gamma \vdash C$.  Clearly, this change does
not allow the introduction of cyclic dependencies.
\begin{theorem}
  If $\Gamma \vdash M: T$ then $\distinguish M$ is deadlock free.
\end{theorem}

\subsection{Adding Unlimited Types}\label{sec:gv-repl}

So far, we have limited GV to containing only linear types.  In this section, we consider one
standard approach to extending the term language to include unlimited types.  We will then show we
can encode replicated processes using term-level contraction and weakening.  Finally, we will show
that our encoding is equivalent to the replicated processes in CP.

\begin{figure}[float]
\vspace{1ex}
~Syntactic extensions
\begin{syntax}
  \text{Types} & T & ::= & \gvforever T \mid \dots \\
  \text{Terms} & M,N & ::= & \gvlet{{!x}}{M}{N} \mid {!M} \mid \dots \\
  \text{Values} & V & ::= & {!V} \mid \dots \\
  \text{Evaluation contexts} & E & ::= & \gvlet{{!x}}{E}{M} \mid {!E} \mid \dots
\end{syntax}
~Typing rules
\begin{mathpar}
\inferrule
  {\Gamma \vdash M: T \\
   \gvforever\Gamma}
  {\Gamma \vdash {!M}: \gvforever T}

\inferrule
  {\Gamma \vdash M: \gvforever T \\
   \Gamma', x:T \vdash N: U}
  {\Gamma \vdash \gvlet{{!x}}{M}{N}: U}
\\
\inferrule
  {\Gamma \vdash M: T}
  {\Gamma, x: \gvforever U \vdash M: T}

\inferrule
  {\Gamma,x:\gvforever T,x':\gvforever T \vdash M: U}
  {\Gamma,x:\gvforever T \vdash M \{ x/x' \}: T}
\end{mathpar}
~Reduction
\begin{mathpar}
\gvlet{{!x}}{{!V}}{M} \teval M \{ \bind x V \}
\end{mathpar}
\vspace{-5mm}
\caption{GV Extensions for Unlimited Types}
\label{fig:gv-repl}
\end{figure}

\figref{gv-repl} gives the extension of GV.  We begin by adding a new class of types, $\gvforever
T$, representing unlimited types.  (The typical notation for such types in linear logic, ${!T}$,
clashes with the notation for output in session types.)  We will write $T \to U$ to abbreviate
$\gvforever{(T \lto U)}$.  We add terms to construct and deconstruct values of type $\gvforever T$;
$\gvforever \Gamma$ denotes that every type in $\Gamma$ must be of the form $\gvforever U$ for some
type $U$.  Finally, we allow values of type $\gvforever T$ to be weakened (discarded) and contracted
(duplicated).  The reduction rule for $\gvforever T$ values is unsurprising---however, unlike in the
other reductions, $x$ be used non-linearly in $M$.  The extension of deadlock freedom to this
calculus is immediate.

Wadler's CP calculus provides unlimited service channels, which can be used to obtain arbitrarily
many copies of some concurrent behavior.  We can encode such channels as follows.  First, we
introduce new, dual session type constructors $Service(S)$ and $Server(S)$, defined by
\begin{align*}
  Server(S) &\defeq \gvout{(\gvdual S \to \outterm)}{\outterm} &
  Service(S) &\defeq \gvin{(S \to \outterm)}{\outterm}
\end{align*}
Note that $\gvdual{Server(S)} = Service(\gvdual S)$.
%% (We do not, however, extend our type system to
%% treat $Service(S)$ channels themselves as unlimited.)
Note the parallel between the encoding of session-level sums using value-level sums and the encoding
of session-level replication using value-level replication---in each case, the key is ``trivial''
channels $\gvout{T}{\outterm}$ for suitable $T$.  We then introduce new constants
\gvconst{replicate} and \gvconst{request}, with the types
\begin{mathpar}
\gvconst{replicate} : ((S \to \outterm) \times Server(S)) \lto \outterm

\gvconst{request} : Service(S) \lto S
\end{mathpar}
defined as follows:
\begin{align*}
  \gvconst{replicate} \app (f, s) &\defeq \gvconst{link} \app (s, \gvconst{fork} \app (\lambda x. \gvsend{(f,x)})) \\
  \gvconst{request} \app s &\defeq
    \gvlet{(f,s)}{\gvreceive{s}}{\gvletunit{\gvconst{wait}\app s}{\gvlet{{!g}}{f}{g}}}
\end{align*}
Now, we can extend the translation from GV into CP:
\begin{equations}
  \tocp{{!M}}z &\defeq& \cut{x} {} {\replicate z y.\link y x}{\tocp{M}x} \\
  \tocp{\gvlet{{!x}}{V}{M}}z &\defeq& \cut y {} {\tocp{V}y} {\derelict{y}{x}.\tocp{M}z}
\end{equations}
and similarly the translation from CP into GV:
\begin{equations}
\togv{\replicate{s}{x}.P} &\defeq& \gvconst{replicate} \app (\lambda x. \togv{P}, s) \\
  \togv{\derelict{s}{x}.P} &\defeq& \gvlet{x}{\gvconst{request} \app s}{\togv{P}} \\
  \togvbig{
    \inferrule
      {P \vdash \Delta}
      {P \vdash \Delta, x:\cpquery{A}}} &\defeq&
    \ba[c]{l} \gvlet{(y,s)}{\gvreceive{s}}{\\\gvletunit{\gvconst{wait}\app s}{\togv{P}}} \ea \\
  \togvbig{
    \inferrule
      {P \vdash \Delta,x:\cpquery{A},y:\cpquery{A}}
      {P[x/y] \vdash \Delta,x:\cpquery{A}}} &\defeq&
    \ba{l} \gvlet{f}{\gvconst{request}\app x}{\\
           \gvlet{x}{\gvconst{fork} \app (\lambda x. \gvconst{replicate}\app (f, x))}{\\
           \gvlet{y}{\gvconst{fork} \app (\lambda x. \gvconst{replicate}\app (f, y))}{\togv{P}}}} \ea
\end{equations}
The translation from CP into GV emphasises that, while weakening and contraction are implicit in CP
syntax, they play a central role in the CP semantics of exponentials, and thus have non-trivial
translation to GV.  Finally, the extensions of Theorems~\ref{thm:cp-reduction-simulated}
and~\ref{thm:gv-reduction-simulated} to unlimited channels is direct.


\section{Related Work}\label{sec:related}


\subsubsection{Session Types and Functional Languages.}

Session types were originally proposed by Honda~\cite{Honda93}, and later extended by Takeuchi et
al.~\cite{Takeuchi94} and by Honda et al.~\cite{Honda98}.  Honda's system relies on a substructural
type system (in which sessions cannot be duplicated or discarded) and adopts the syntax $\with$ and
$\oplus$ for choice; however, he does not draw a connection between his type system and the
connectives of linear logic, and his system includes a single, self-dual closed channel.
Vasconcelos et al.~\cite{VasconcelosGR06} develop a language that integrates session-typed
communication primitives and a functional language.  Gay and Vasconcelos~\cite{GayVasconcelos10}
extend the approach to describe asynchronous communication with statically-bounded buffers.  Their
approach provides a more flexible mechanism of session initiation, distinct from their construct for
thread creation, and they do not consider deadlock.  Kobayashi~\cite{Kobayashi02} describes an
embedding of session-typed $\pi$-calculus in polyadic linear $\pi$-calculus, relying on
multi-argument send and receive to capture the state of a communication and variant types to capture
choice; Dardha et al.~\cite{Dardha12} extend his approach to subtyping and polymorphism.

\subsubsection{Linear Logic and Session Types.}

When he originally described linear logic, Girard~\cite{Girard87} suggested that it would be suited
to reasoning about concurrency.  Abramsky~\cite{Abramsky92} and Bellin and
Scott~\cite{BellinScott94} give embeddings of linear logic proofs in $\pi$-calculus, and show that
cut reduction is simulated by $\pi$-calculus reduction.  Their work is not intended to provide a
type system for $\pi$-calculus: there are many processes which are not the image of some proof.

Caires and Pfenning~\cite{CairesPfenning10} present a session type system for $\pi$-calculus that
exactly corresponds to the proof system for the dual intuitionistic linear logic, and show that (up
to congruence) cut reductions corresponds to process reductions or process equivalences.  Toninho et
al.~\cite{ToninhoCP12} consider embeddings of the $\lambda$-calculus into session-typed
$\pi$-calculus; their focus is on expressing the concurrency inherent in $\lambda$-calculus terms,
rather than simulating standard reduction. Wadler~\cite{Wadler14} adapts the approach of Caires and
Pfenning to classical (rather than intuitionistic) linear logic, and gives a translation from GV
(his functional language) to CP (his process calculus). He does not give a direct semantics for
GV. In previous work~\cite{LindleyM14}, we give a translation between CP and GV.
%% , and show that
%% post-composing with the translation from GV to CP yields a translation from full GV into the process
%% fragment of GV.

\subsubsection{Deadlock Freedom and Progress.}

There have been several approaches to guarantee deadlock freedom in $\pi$-calculus.
Kobayashi~\cite{Kobayashi06} and Padovani~\cite{Padovani14} give type systems that guarantee
deadlock freedom.  Their approaches capturing priority information in types, restricting the order
in which channels are used, and thus statically eliminating the possibility of cyclic dependencies.
Their approaches can be seen as developments of linear $\pi$-calculus---they do not directly address
the evolution of types provided by session types.

Carbone and Debois~\cite{Carbone10} give a graphical characterisation of session-typed processes;
this allows them to directly identify cycles in the session interactions.  They show that all
possible interactions eventually take place in cycle-free processes.  Carbone et
al.~\cite{CarboneDM14} show similar results for well-typed processes under Kobayashi's type system
for deadlock freedom; their approach accommodates processes with open channels by defining a
type-directed closure of a process, and showing that open processes progress only if their typed
closures progress.

\section{Conclusion and Future Work}\label{sec:conclusion}

We have presented a small-step operational semantics for GV, a minimal session-typed functional
language. We have shown that it is deadlock-free, deterministic, and terminating, and have
established simulations both ways between our semantics for GV and cut-reduction in a process
calculus based on linear logic. Finally, we have demonstrated that GV is a suitable basis for future
modular language development by illustrating two extensions of GV, and observing that our proof of
deadlock freedom extends directly to these cases.

In closing, we identify two important directions for future work. The first direction is
recursion. Recursion is essential both for sessions (to capture repeating behavior, such as adding
recipients to a mail message) and for functional programming. Adding unchecked recursion to GV would
clearly compromise termination and introduce the possibility of livelock; we hope that adapting
approaches used for fixed points in linear logic might mitigate this issue. The second direction is
asynchrony. We hope to develop the approach of Gay and Vasconcelos~\cite{GayVasconcelos10} and show
a correspondence between synchronous and asynchronous semantics for GV.

\small
\label{sec:bib}
\bibliographystyle{abbrv}
\bibliography{main}
\normalsize

\appendix

\section{A Simpler Send}\label{sec:send}

The CP send rule is appealing because if one erases the terms it is exactly the classical linear
logic rule for tensor. However, this correspondence comes at a price. Operationally, the process
$x[y].(P \mid Q)$ does three things: it introduces a fresh variable $y$, it sends $y$ to a freshly
spawned process $P$, and in parallel it continues as process $Q$.  This complicates both the
reduction semantics of CP (as the cut reduction of $\otimes$ against $\parr$ must account for all
three behaviours) and the equivalence of CP and GV (where the behavior of \gvconst{send} is simpler).

We can give an alternative formulation of send, avoiding the additional name restriction and
composition, as follows:
\begin{mathpar}
\inferrule
  {\cptyp{P}{\Delta,x:B,y:A}}
  {\cptyp{x\sd{y}.P}{\Delta,x:A \otimes B,y:\cpdual{A}}}
\end{mathpar}
where $x\sd{y}.P$ is defined as $x[z].(\link y z \mid P)$.  In particular, note that
\begin{equations}
  \cut x {} {x\sd{y}.P}{x(z).Q}
     &=& \cut x {} {x[z].(\link y z \mid P)} {x(z).Q} \\
     &\crto& \cut z {} {\link y z} {\cut x {} P {Q}} \\
     &\crto& \cut x {} P {Q \{ y/z \}}
\end{equations}
as we would expect for synchronising a send and a receive.  Similarly, we note that any process
$x[y].(P \mid Q)$ can also be expressed as a process $\cut y {} P {x\sd{y}.Q}$, which reduces to the
original by one application of the commuting conversions.  However, the two formulations are not
quite identical. Let us consider the possible reductions of the two terms.  Notice that in $x[y].(P
\mid Q)$, both $P$ and $Q$ are blocked on $x$; however, the same is not true for $\cut y {} P
{x\sd{y}.Q}$; the latter permits reductions in $P$ before synchronising on $x$.

\section{Proofs of Selected Results}\label{sec:proofs}

\newenvironment{fake}[1]{\noindent\textbf{#1}\textit{}{}\ignorespacesafterend}

\begin{fake}{Theorem \ref{thm:preservation}.}
  If $\Gamma \vdash C$ and $C \ceval C'$ then there is some $\Gamma'$ such that $\Gamma \ceval^?
  \Gamma'$ and $\Gamma' \vdash C'$.
\end{fake}

\begin{proof}
  By induction on the derivation of $C \ceval C'$.  We include several representative cases.
  \begin{itemize}
  \item Case \textsc{Lift} is immediate by the induction hypothesis.
  \item Case \textsc{LiftV} follows from \lemref{term-preservation}.
  \item In case \textsc{Send}, from the assumption $\Gamma \vdash \Fx[\mkwd{send}\,(V,x)] \parallel
    \Fx'[\gvconst{receive} \app x]$, we can assume that $\Gamma$ partitions as
    $\Gamma_1,\Gamma_2,x:\channel{S}$ such that $S = \gvout{T}{S'}$, $V$ has type $T$, and
    $\Gamma_1,x:\gvout{T}{S'} \vdash \Fx[\gvconst{send} \app (V,x)]$,
    $\Gamma_2,x:\gvin{T}{\gvdual{S'}} \vdash \Fx'[\gvconst{receive} \app x]$.  As $\gvconst{send} : T
    \gvtimes \gvout{T}{S'} \lto S'$ and $\Gamma_1,x:\gvout{T}{S'} \vdash \Fx[\gvconst{send} \app
    (V,x)]$, we can conclude that $\Gamma_1,x:S' \vdash \Fx[x]$.  By a similar argument, we conclude
    that $\Gamma_2,x:\gvdual{S'} \vdash \Fx'[(V,x)]$. Finally, as $\channel{(\gvout{T}{S})} \ceval
    \channel{S}$, $\Gamma_1,\Gamma_2,x:\channel{(\gvout T S)} \ceval
    \Gamma_1,\Gamma_2,x:\channel{S}$, and we can recompose the resulting processes concluding that
    $\Gamma_1,\Gamma_2,x:\channel{S} \vdash \Fx[x] \parallel \Fx'[(V,x)]$.
  \item In case \textsc{Fork}, from the assumption $\Gamma \vdash \Fx[\gvconst{fork} \app V]$, we
    can conclude that $\Gamma$ splits as $\Gamma_1,\Gamma_2$ and there is some $S$ such that
    $\Gamma_1,x:S \vdash \Fx[x]$ and $\Gamma_2,x:\gvdual{S} \vdash V \app x$.  Thus we have that
    $\Gamma,x:S \vdash \Fx[x] \parallel V \app x$ and $\Gamma \vdash (\nu x)(\Fx[x] \parallel V \app
    x)$.
  \item In case \textsc{Wait}, from the assumption $\Gamma \vdash (\nu x)(\Fx[\gvconst{wait} \app
    x] \parallel x)$, we can conclude that $\Gamma,x:\interm \vdash \Fx[\gvconst{wait} \app x]$ and
    thus, from the typing of \gvconst{wait}, that $\Gamma \vdash \Fx[()]$.
  \item In case \textsc{Link}, from the assumptions $\Gamma \vdash (\nu x) (\Fx[\gvconst{link} \app
    (x, y)] \parallel \Fx'[M]), x \in \fv(M)$, we can conclude that $\Gamma$ partitions as
    $\Gamma_1,\Gamma_2,y:S$ such that $\Gamma_1,y:S,x:\gvdual{S} \vdash \Fx[\gvconst{link} \app (x,
    y)]$ and $\Gamma_2,x:S \vdash \Fx'[M]$.  (Note that the free variable assumption on the
    reduction rule for \gvconst{fork} allows us to assume that neither $\Fx$ nor $\Fx'$ binds $x$ or
    $y$.)  From the type of \gvconst{link}, we have that $\Gamma,x:\outterm \vdash \Fx[x]$;
    similarly, from $x \in \fv(M)$, we can conclude that $\Gamma_2,y:S \vdash \Fx'[M\{\bind x y\}]$.
    Finally, from the typing rule for \gvconst{wait}, we have that $\Gamma_2,x:\interm,y:S \vdash
    \Fx'[\gvletunit{\gvconst{wait} \app x}{M\{\bind x y\}}]$, and that $\Gamma \vdash (\nu
    x)(\Fx[x] \parallel \Fx'[\gvletunit{\gvconst{wait} \app x}{M\{\bind x y\}}])$
  \qed
  \end{itemize}
\end{proof}

\begin{fake}{Lemma \ref{lem:canonical}.}
  If $\Gamma \vdash C$, then there is some $C' \equiv C$ such that $\Gamma \vdash C'$ and $C'$ is in
  canonical form.
\end{fake}

\begin{proof}
  Let $x_1,\dots,x_{n-1}$ be the $\nu$-bound variables in $C$ and $M_1,\dots,M_n$ be the terms in
  $P$; the proof is by induction on $n$.  If $n > 1$, then pick some $M_i$ such that there is
  exactly one $\nu$-bound variable $x_j$ where $x_j \in \fv(M_i)$.  (That there must be such an
  $M_i$ and $x_j$ can be established by a standard counting argument, together with
  \lemref{procs-share-one-channel}.)  Now, construct $D$ from $C$ by the homomorphic extension of
  the mapping $(\nu x_j)E \mapsto E; E \parallel \phi M_i \mapsto E$.  From the assumption
  that $\Gamma \vdash C$, we can conclude that there is some $\Gamma' \subseteq \Gamma$ and type $S$
  such that $\Gamma',x_j:S \vdash D$.  By the induction hypothesis, there is some $D' \equiv D$ in
  canonical form.  Finally, let $C' = (\nu x_j)(\phi M_i \parallel D')$; we can see that
  straightforwardly that $C'$ is in canonical form; that $C \equiv C'$; and, that $\Gamma \vdash
  C'$. \qed
\end{proof}

\begin{fake}{Theorem \ref{thm:gv-reduction-simulated}.}
  If $\Gamma \vdash C$, $\Gamma' \vdash D$, $\Gamma \rto \Gamma'$, and $C \ceval D$, then $\tocp{C}z
  \bigrto \tocp{D}z$.
\end{fake}

\begin{proof}
  By induction on the derivation of $C \ceval D$. The inductive cases follow straightforwardly from
  the compositionality of the definitions and \thmref{teval-preserved}. The case for \gvconst{send}
  against \gvconst{receive} is included in the main body of the paper. The remaining cases follow.
  \begin{itemize}
  \item Case $(\nu x)(\Fx[\gvconst{wait} \app x] \parallel \thread x) \ceval \Fx[()]$.
    \[
    \bl
    \quad \tocp{(\nu x)(\Fx[\gvconst{wait} \app x] \parallel \thread x)}z \\
    %% = \\
    %% \quad \cut{x}{}{\tocp{\Fx}[y \mapsto \tocp{\gvconst{wait} \app x}y]z}
    %% {\tocp{\wcirc}[\tocp{x}]z} \\
    = \\
    \quad \cut{x}{}{\tocp{\Fx}[y \mapsto \cut{w}{}{\link w x}{\link w y}]z}
                   {\cut{y}{}{\link x y}{y[]}} \\
    \bigcrto (\text{cut links}) \\
    \quad \cut{x}{}{\tocp{\Fx}[y \mapsto \link x y]z}
                   {x[]} \\
    \bigcrto (\text{cut link}) \\
    %% \quad \cut{x}{}{\tocp{\Fx}[y \mapsto y[]]z}{x[]} \\
    %% = \\
    \quad \tocp{\Fx}[y \mapsto y[]]z \\
    = \\
    \quad \tocp{\Fx[()]}z \\
    \el
    \]

  \item Case $\Fx[\gvconst{fork} \app (\clos{\sigma}{x}{M})]
                          \ceval (\nu x)(\Fx[x] \parallel M\sigma)$.
    \[
    \bl
    \quad \tocp{\Fx[\gvconst{fork} \app (\clos{\sigma}{x}{M})]}z \\
    = \\
    \quad \tocp{\Fx}[\tocp{\gvconst{fork} \app (\clos{\sigma}{x}{M})}]z \\
    = \\
    \quad \tocp{\Fx}[z \mapsto
             \cut{x}{}{\tocp{x}z}
               {\cut{y}{}
                  {\tocp{\sigma}(y(x).\tocp{M}y)}
                  {\cut{w}{}{y\sd{x}.\link y w}{w[]}}}]z \\

    \bigcrto (\text{cut send against receive}) \\
    %% \quad \tocp{\Fx}[x \mapsto
    %%          \cut{v}{}{\tocp{v}x}
    %%            {\cut{y}{}
    %%               {\tocp{\sigma}(\tocp{M}y)}
    %%               {\cut{w}{}{\link y w}{w[]}}}]z \\
    %% = \\
    \quad \tocp{\Fx}[z \mapsto
             \cut{x}{}{\tocp{x}z}
               {\cut{y}{}
                 {\tocp{\sigma}(\tocp{M}y)}
                 {y[]}}]z \\

    %% = \\
    %% \quad \tocp{\Fx}[z \mapsto
    %%          \tocp{\sigma}
    %%             (\cut{x}{}
    %%                {\cut{y}{}
    %%                  {\tocp{M}{y}}{y[]}}
    %%                  {\tocp{x}z})]z \\
    %% \equiv \\
    %% \quad \tocp{\Fx}[
    %%         z \mapsto
    %%           \cut{x}{}
    %%             {\tocp{x}z}
    %%             {\tocp{\cut{y}{}{\tocp{\sigma}(\tocp{M}y)}{y[]}}} \\
    \equiv \\
    \quad \cut{x}{}
            {\tocp{\Fx}[\tocp{x}]z}
            {\tocp{\sigma}(\tocp{\cut{y}{}{\tocp{M}y}{y[]}})} \\
    %% = \\
    %% \quad \cut{x}{}
    %%         {\tocp{\Fx}[\tocp{x}]z}
    %%         {\tocp{\sigma}(\tocp{\wcirc}[\tocp{M}]z)} \\
    = \\
    \quad \tocp{(\nu x)(\Fx[x] \parallel M \sigma)}z \\
    \el
    \]

  \item Case $(\nu x) (\Fx[\gvconst{link} \app (x, y)] \parallel \Fx'[M]) \ceval
              (\nu x)(\Fx[x] \parallel \Fx'[\gvletunit{\gvconst{wait} \app x}{M\{y/x\}}])$.
    \[
    \bl
    \quad \tocp{(\nu x) (\Fx[\gvconst{link} \app (x, y)] \parallel \Fx'[M])}z \\
    = \\
    \quad \cut{x}{}
             {\tocp{\Fx}[\tocp{\gvconst{link} \app (x, y)}]z}
             {\tocp{\Fx'}[\tocp{M}]z} \\
    = \\
    %% \quad \cut{x}{}
    %%          {\tocp{\Fx}[z \mapsto
    %%                        \cut{w}{}{\link w z}
    %%                          {\cut{v}{}{\link v w}
    %%                            {\cut{x'}{}
    %%                              {\link{x}{x'}}
    %%                              {\cut{y'}{}{\link{y}{y'}}{w().\link{x'}{y'}}}}}]z}
    %%          {\tocp{\Fx'}[\tocp{M}]z} \\
    \quad \nu x
             (\tocp{\Fx}[z \mapsto
                           \nu v (\link v z \mid
                             \nu w (\link v w \mid \\
    \qquad
                               {\cut{x'}{}
                                 {\link{x}{x'}}
                                 {\cut{y'}{}{\link{y}{y'}}{w().\link{x'}{y'}}}}))]z \mid
             {\tocp{\Fx'}[\tocp{M}]z}) \\
    \bigcrto (\text{cut links}) \\
    \quad \cut{x}{}
             {\tocp{\Fx}[z \mapsto
                           \cut{v}{}{\link v z}
                             {\cut{w}{}{\link v w}
                                {w().\link{x}{y}}}]z}
             {\tocp{\Fx'}[\tocp{M}]z} \\
    \equiv \\
    \quad \cut{v}{}
             {\tocp{\Fx}[z \mapsto \link v z]z}
             {\cut{x}{}
               {\cut{w}{}
                  {\link v w}
                  {w().\link{x}{y}}}
               {\tocp{\Fx'}[\tocp{M}]z}} \\
    \equiv \\
    \quad
      \cut{v}{}
        {\tocp{\Fx}[z \mapsto \link v z]z}
        {\tocp{\Fx'}[z \mapsto
                      \cut{w}{}
                         {\link v w}
                         {w().\cut{x}{}{\link x y}{\tocp{M}z}}]z} \\
    = \\
    \quad \tocp{(\nu x)(\Fx[x] \parallel \Fx'[\gvletunit{\gvconst{wait} \app x}{M\{y/x\}}])}z
    \el
    \]
\end{itemize}
\end{proof}

\end{document}

%%  LocalWords:  Caires Pfenning Toninho Wadler Wadler's GV CP modularity SMTP RcptAddress gv eval
%%  LocalWords:  SenderAddress substructural intuitionistic Vasconcelos untyped cp togv tocp inl xy
%%  LocalWords:  inr nullary schemas versa LiftV conf rcl procs redexes repl CP's pos tion dualised
%%  LocalWords:  Congruences pointwise homomorphic compositional IH subst compositionality teval et
%%  LocalWords:  expressivity typings exponentials Takeuchi al Kobayashi polyadic multi Dardha
%%  LocalWords:  subtyping polymorphism Girard Abramsky Bellin embeddings Padovani Carbone Debois
%%  LocalWords:  Kobayashi's livelock asynchrony
