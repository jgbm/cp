 % -*- fill-column: 100 -*-

\documentclass[orivec,envcountsame]{llncs}

\usepackage{amsmath,amssymb,centernot,hyperref,mathwidth,scalerel,stmaryrd,url,xspace,mathrsfs,enumitem}
\usepackage[table]{xcolor}
\usepackage{colortbl}
\addtolength{\jot}{-3px}

\usepackage{mathpartir}
\mprset{sep=1em}

\usepackage{float}
\floatstyle{boxed}
\restylefloat{figure}

\input{preamble.tex}

\title{Session Freedom in a Functional Deadlock-typed Language}
\author{J. Garrett Morris \and Sam Lindley \and Philip Wadler}
\institute{The University of Edinburgh \\
           \email{\{Garrett.Morris,Sam.Lindley,Philip.Wadler\}@ed.ac.uk} \vspace{-5mm}}

\begin{document}

\maketitle

\begin{abstract}
\end{abstract}

\section{Introduction}\label{sec:intro}

In this paper, we make the following contributions.
\begin{itemize}
\item We define a core linearly-typed functional language, by extending linear lambda calculus
  with session-typed communication primitives~\secref{gv-static}.
\item We present an (untyped) synchronous operational semantics for our core language, introducing
  explicit closures in the semantics of $\lambda$ terms and following the approach of Gay and
  Vasconcelos for the semantics of concurrent processes~\secref{gv-eval}.
\item We characterize deadlock and normal forms; we show that typed terms are deadlock-free, and
  that closed typed terms evaluate to normal forms~\secref{gv-deadlock}.
\item We connect our language to the interpretation of session types as linear logic propositions,
  by establishing a correspondence between the semantics of our language and that of Wadler's
  calculus CP~\secref{cp}.
\item We consider two extensions of our core language~\secref{extend}: one which harmonizes the
  treatment of closed channels with their treatment in other session-typed calculi~\secref{gv-end},
  and another which adds unlimited types and replicated behavior~\secref{gv-repl}.  We show that
  these extensions preserve the essential deadlock-freedom properties of the core language.
\end{itemize}
Finally, we discuss related work~\secref{related} and conclude~\secref{conclusion}.

\section{GV by Example}\label{sec:examples}

\subsection{Books and Stores Therefore}

\todo{This ended up being a bit long.  There are a couple of points that it makes tho:
  \begin{itemize}
  \item Transmission of channels (sending client channel to bank).
  \item Sending structured values along channels.
  \end{itemize}
  And it has a motivation.  However, I'm not sure that either of these is important enough to
  justify the length.  We could, for example, do the calculator with structured values and not take
  nearly as much space.}

\begin{code}
Client \defeq \lambda c.
  \bl
  \gvlet{c}{\gvsend{(\text{``A Tale of Two Cities"}, c)}}{} \\
  \gvlet{(price,c)}{\gvreceive{c}}{} \\
  \mkwd{if}\ price \leq 20\ \mkwd{then} \\
  \quad\bl
    \gvlet{c}{\gvselect{purchase}{c}}{}\\
    \gvlet{c}{\gvsend{((ccName, ccNumber), c)}}{} \\
    \mkwd{offer}\,c\,\{ \\
    \quad \bl
      accept\,c \mapsto \gvconst{wait} \app c; \gvconst{print} \app \text{``:)"} \\
      decline\,c \mapsto \gvconst{wait} \app c; \gvconst{print} \app \text{``:("} \\
      challenge\,c \mapsto \\
      \quad \bl
        \gvlet{c}{\gvsend{(response, c)}}{} \\
        \mkwd{offer}\,c\,\{ \\
        \quad \bl
          accept\,c \mapsto \gvconst{wait} \app c; \gvconst{print} \app \text{``:)"} \\
          decline\,c \mapsto \gvconst{wait} \app c; \gvconst{print} \app \text{``:("} \} \}
        \el
      \el
    \el
  \el \\
  \mkwd{else} \\
  \quad \bl
    \gvlet{c}{\gvselect{stop}{c}}{} \\
    \gvconst{wait} \app c
    \el
  \el
\end{code}

\begin{code}
Store \defeq \lambda b. \lambda c. \bl
  \gvlet{(product, c)}{\gvreceive{c}}{} \\
  \gvlet{c}{\gvsend{(price(product), c)}}{} \\
  \mkwd{offer}\,c\,\{ \\
  \quad \bl
    purchase\,c \mapsto \\
    \quad \bl
      \gvlet{((ccName, ccNumber), c)}{\gvreceive{c}}{} \\
      \gvlet{b}{\gvsend{((ccName, ccNumber, price(product), c), b)}}{} \\
      \mkwd{offer}\,b \, \{\\
      \quad \bl
        accept\,b \mapsto
          \gvlet{(c,b)}{\gvreceive{b}}{\gvconst{wait} \app b; \dots; c} \\
        reject\,b \mapsto
          \gvlet{(c,b)}{\gvreceive{b}}{\gvconst{wait} \app b; c} \}
      \el
    \el \\
    stop\,c \mapsto c \}
  \el
\el\end{code}

\begin{code}
Bank \defeq \lambda b. \bl
  \gvlet{((ccName, ccNumber, amount, c), b)}{\gvreceive{b}}{} \\
  \mkwd{if}\ suspicious(ccNumber, amount)\ \mkwd{then} \\
  \quad\bl
    \gvlet{c}{\gvselect{challenge}{c}}{} \\
    \gvlet{(response, c)}{\gvreceive{c}}{} \\
    \mkwd{if}\ passes(response)\ \mkwd{then} \\
    \quad \bl
      \gvlet{c}{\gvselect{accept}{c}}{} \\
      \gvlet{b}{\gvselect{accept}{b}}{} \\
      \gvlet{b}{\gvsend{(c,b)}}{} \\
      \dots; c \el \\
    \mkwd{else} \\
    \quad \bl
      \gvlet{c}{\gvselect{reject}{c}}{} \\
      \gvlet{b}{\gvselect{reject}{b}}{} \\
      \gvlet{b}{\gvsend{(c,b)}}{} \\
      c \el
  \el
\el
\end{code}

\begin{code}
System \defeq \bl
  \gvlet{bank}{\gvconst{fork} \app Bank}{} \\
  \gvlet{store}{\gvconst{fork} \app (Store \app bank)}{} \\
  Client \app store
\el
\end{code}

\section{A Session-Typed Functional Language}\label{sec:gv}

I'm intentionally ignoring CP polymorphism forever.

\subsection{Syntax and Typing}\label{sec:gv-static}

\begin{figure}[t]
\begin{syntax}
  \text{Session types} & S & ::= & \gvout{T}{S} \mid \gvin{T}{S} \mid \interm \mid \outterm \mid \channel{S} \\
  \text{Types} & T,U & ::= & S \mid T \times U \mid \one \mid T + U \mid \zero \mid T \lto U \\ % \mid {!T} \\
  \text{Terms} & M,N & ::= & x \mid K \mid \lambda x.M \mid M\,N \\
  & & \mid & (M,N) \mid \gvlet{(x,y)}{M}{N} \\
  & & \mid & \mkwd{inl}\,M \mid \mkwd{inr}\,M \mid \gvcase{M}{\mkwd{inl}\,x \mapsto N; \mkwd{inr}\,x \mapsto N} \\
  & & \mid & () \mid \gvletunit{M}{N} \mid \gvconst{absurd} \app M \\
  \text{Constants} & K & ::= & \gvconst{send} \mid \gvconst{receive} \mid \gvconst{fork} \mid \gvconst{wait} \mid \gvconst{link}\\
\end{syntax}
\caption{Syntax of GV terms and types}\label{fig:gv-syntax}
\end{figure}

\figref{gv-syntax} gives the syntax of GV types and terms.  The types $T$ include 0-ary and binary
(linear) sums and pairs, and linear implication $T \lto U$.  We write $\gvletunit{M}{N}$ as the
elimination form of $\one$, rather than the more verbose $\gvlet{()}{M}{N}$.  Session types $S$
include input (\gvin T S), output (\gvout T S), and closed channels ($\interm$, $\outterm$).  We
also include a type $\channel S$ of channels; values of channel type cannot be used directly in
terms, but will appear in the typing of thread configurations.  The terms are the standard terms of
a (linear) lambda calculus, augmented with construction and deconstruction of 0-ary and binary pairs
and sums (there is, of course, no term to construct a 0-ary sum).  Typing rules, including the type schema for the constants $K$, are given in
\figref{gv-typing}


\begin{figure}[h]
Typing rules:
\begin{mathpar}
\inferrule
  {T \not= \channel{S}}
  {\{x:T\} \vdash x:T}

\inferrule
  {\Gamma,x:T \vdash M:U}
  {\Gamma \vdash \lambda x.M : T \lto U}

\inferrule
  {\Gamma \vdash M: T \lto U \\
   \Gamma' \vdash N: T}
  {\Gamma,\Gamma' \vdash M\,N: U}

\inferrule
  {\Gamma \vdash M: T \\
   \Gamma' \vdash N: U}
  {\Gamma,\Gamma' \vdash (M,N): T \times U}

\inferrule
  {\Gamma \vdash M: T \times T' \\
   \Gamma',x:T,y:T' \vdash N: U}
  {\Gamma,\Gamma' \vdash \gvlet{(x,y)}{M}{N} : U}

\inferrule
  {\Gamma \vdash M: T}
  {\Gamma \vdash \mkwd{inl}\,M: T+U}

\inferrule
  {\Gamma \vdash M: T+T' \\
   \Gamma',x:T \vdash N: U \\
   \Gamma',x:T' \vdash N': U}
  {\Gamma,\Gamma' \vdash \gvcase{M}{\mkwd{inl}\,x \mapsto N; \mkwd{inr}\,x \mapsto N'} : U}

\inferrule
  { }
  {\vdash (): \one}

\inferrule
  {\Gamma \vdash M: \one \\
   \Gamma' \vdash N: T}
  {\Gamma,\Gamma' \vdash \gvletunit{M}{N}: T}

\inferrule
  {\Gamma \vdash M: \zero}
  {\Gamma, \Gamma' \vdash \gvconst{absurd} \app M : T}
\end{mathpar}
Type schemas for constants:
\begin{mathpar}
\gvconst{send} : T \times \gvout{T}{S} \lto S

\gvconst{receive} : \gvin{T}{S} \lto T \times S

\gvconst{fork} : (S \lto \outterm) \lto \gvdual{S}

\gvconst{wait} : \interm \lto \one

\gvconst{link} : S \times \gvdual{S} \lto \outterm
\end{mathpar}
Duality:
\begin{mathpar}
\gvdual{\gvout{T}{S}} = \gvin{T}{\gvdual S}

\gvdual{\gvin{T}{S}} = \gvout{T}{\gvdual S}

\gvdual{\interm} = \outterm

\gvdual{\outterm} = \interm
\end{mathpar}
\caption{GV typing rules}\label{fig:gv-typing}
\end{figure}

\subsubsection{Concurrency.}

Concurrent behavior is provided by the constants $K$.  Communication is provided by \gvconst{send}
and \gvconst{receive}.  For example, a computation that received a pair of numbers along a channel
$z$ and then sent their sum along the same channel could be expressed by
%
\[\bl
  \gvlet{((x, y), z)}{\gvreceive{z}}{} \\
  \gvsend{(x+y,z)}
\el\]
%
(where the interpretation of nested patterns by sequences of bindings is standard).  Sessions are
treated linearly in GV.  Thus, \gvconst{receive} returns not just the received value (the pair of
$x$ and $y$) but also a new copy of the session used for receiving ($z$); similarly, \gvconst{send}
returns a copy of the session used for sending.  The term above, therefore, requires that $z :
\gvin{(Int \times Int)}{\gvout{Int}{S}}$ at its start, and evaluates to a session of type $S$. Session
initiation is provided by \gvconst{fork}.  If $f$ is a function from a session of type $S$ to a
closed session (of type $\outterm$), then $\gvconst{fork} \app f$ runs $f$ and returns a session (of
type $\gvdual S$) to communicate with it.  For example, the term
%
\[\bl
 \gvconst{fork} \app (\lambda z. \\
 \quad \bl
   \gvlet{((x, y), z)}{\gvreceive{z}}{} \\
   \gvsend{(x+y,z)}) \el
\el\]
%
returns a channel of type $\gvout{(Int \times Int)}{\gvin{Int}{\interm}}$.  In a process created by
$\gvconst{fork} \app f$, the session returned from $f$ is implicitly closed by $\gvconst{fork}$;
however, the other end of the channel must be explicity closed by calling \gvconst{wait}.  So a
client of the process above might look like
%
\[\bl
  \gvlet{z}{\gvsend{((6,7),z)}}{} \\
  \gvlet{(x,z)}{\gvreceive{z}}{} \\
  \gvletunit{\gvconst{wait}\app z}{x}
\el\]
%
The combination of these processes would evaluate to 13.  Finally, \gvconst{link} is used for
session forwarding; evaluating $\gvconst{link} \app (x, y)$ results in messages sent on $x$ being
received on $y$ and vice versa.

\subsubsection{Choice.}

In addition to input and output, most session typed systems also provide session types representing
internal ($S_1 \oplus S_2$) and external ($S_1 \with S_2$) choice (also called selection and
branching, respectively).  For example, we could write a process that can either sum two numbers or
negate one:
%
\[\bl
  \mkwd{offer} \: z \: \{ \:
  \bl
     \mkwd{inl} \app z \mapsto \bl
       \gvlet{((x, y), z)}{\gvreceive{z}}{} \\
       \gvsend{(x+y,z)} \el \\
     \mkwd{inr} \app z \mapsto \bl
       \gvlet{(x, z)}{\gvreceive{z}}{} \\
       \gvsend{(-x,z)} \: \} \el \\
  \el
\el\]
%
This term initially requires $z : (\gvin{(Int \times Int)}{\gvout{Int}{S}}) \with
(\gvin{Int}{\gvout{Int}{S}})$.  A client of this process would begin by choosing which branch of the
session to take; for example, we could extend the preceding example as follows:
%
\[\bl
  \gvlet{z}{\gvselect{\mkwd{inl}}{z}}{} \\
  \gvlet{z}{\gvsend{((6,7),z)}}{} \\
  \gvlet{(x,z)}{\gvreceive{z}}{} \\
  \gvletunit{\gvconst{wait}\app z}{x}
\el\]
%
In GV, we do not provide primitives for selection and branching in sessions; rather, we show that
they are macro-expressable using the term-level sum construct.  The intuition is that selection is
implemented by sending a suitably tagged process, while branching is implemented by a term-level
branch on a received value.  Concretely, we define the types by
\begin{mathpar}
S_1 \with S_2 \defeq \gvin{(S_1 + S_2)}{\interm}

S_1 \oplus S_2 \defeq \gvout{(\gvdual{S_1} + \gvdual{S_2})}{\outterm}
\end{mathpar}
Note that we have the expected duality relationship: $\gvdual{S_1 \with S_2} = \gvdual{S_1} \oplus
\gvdual{S_2}$.  We can implement the \gvconst{select} and \gvconst{offer} primitives as follows
(where $\ell$ ranges over $\{ \mkwd{inl}, \mkwd{inr} \}$)
%
\begin{align*}
  \gvconst{select} \app \ell \app M &\defeq \gvconst{fork} (\lambda x. \gvsend(\ell \app x, M)) \\
  \gvconst{offer} \app M \,\{ \mkwd{inl} \app x \mapsto P; \mkwd{inr} \app x \mapsto Q \}
    &\defeq \bl \gvlet{(y,m)}{\gvreceive{M}}{\\\gvletunit{\gvconst{wait} \app m}{\\\gvcase{x}{\mkwd{inl} \app x \mapsto P; \mkwd{inr} \app x \mapsto Q}}} \el
\end{align*}
%
While we would expect a surface langauge to include selection and branching, we will omit them, as
it simplifies the core calculus with no loss of expressivity.


\subsection{Evaluation}\label{sec:gv-eval}

\newcommand{\wcirc}{{\mathord{\circ}}}
\newcommand{\bcirc}{{\mathord{\bullet}}}
\newcommand{\distinguish}[1]{\bcirc #1}
\newcommand{\thread}[1]{\wcirc #1}


\begin{figure}[t]
\begin{syntax}
  \text{Values} & V,W & ::= & x \mid K \mid \lambda^\sigma x.M \\
  & & \mid & () \mid (V,W) \mid \mkwd{inl}\,V \mid \mkwd{inr}\,V  \\
  \text{Substitutions} & \sigma & ::= & \{ \bind {x_1} {V_1}, \dots, \bind {x_n} {V_n} \} \\
  & & & \qquad\text{ where the $x_i$ are pairwise distinct} \\
  \text{Evaluation contexts} & \Ex & ::= &  [~] \mid \Ex\,M \mid V\,\Ex \mid \gvletunit{\Ex}{M} \\
  & & \mid & (\Ex,M) \mid (V,\Ex) \mid \gvlet{(x,y)}{\Ex}{M} \\
  & & \mid & \mkwd{inl}\,\Ex \mid \mkwd{inr}\,\Ex \mid \gvcase{\Ex}{\mkwd{inl}\,x \mapsto N; \mkwd{inr}\,x \mapsto N'} \\
  & \Fx & ::= & \phi \Ex \\
  \text{Configurations} & C,D & ::= & \phi M \mid C \parallel C' \mid (\nu x) C \\
  \text{Configuration contexts} & \Cx & ::= & [~] \mid \Cx \parallel P \mid (\nu x)\Cx \\
  \text{Flags} & \phi & ::= & \wcirc \mid \bcirc
\end{syntax}
\caption{Syntax of values, configurations, and contexts}\label{fig:gv-eval-syntax}
\end{figure}

Following Gay and Vasconcelos~\cite{}, we factor the semantics of GV into a (deterministic)
reduction relation on terms (called $\teval$) and a (non-deterministic) reduction on configurations
of processes (called $\ceval$).  \figref{gv-eval-syntax} gives the syntax of values, configurations,
and evaluation and configuration contexts.

\subsubsection{Terms.}

To preserve a close connection between the semantics of our term language and cut-reduction in
linear logic, we define term reduction using weak explicit substitutions~\cite{}.  In this approach,
we capture substitutions at $\lambda$-terms rather than immediately applying them to the body of the
term.  Our language of terms, therefore, includes closures $\lambda^\sigma x.M$, where $\sigma$
provides the captured substitution.  We extend the typing judgement to include closures, as follows:
\[
\inferrule
  {\Gamma, x:T \vdash M\sigma : U \\
   \dom(\sigma) = (\fv(M) \setminus \{ x \})}
  {\Gamma \vdash \lambda^\sigma x.M : T \lto U}
\]
The free variables of a closure $\lambda^\sigma x.M$ are the free variables of the range of
$\sigma$, not the free variables of $M$; application of substitution $M\sigma$ is then defined as
usual on the free variables of terms.  Note that the side condition on the domain of $\sigma$ is
preserved under substitution.  Finally, we will implicitly treat terms $\lambda x.M$ as closures
$\lambda^\sigma x.M$ where $\sigma$ is the identity substitution restricted to the free variables of
$M$ less $\{x\}$.

%% We will implicitly treat substitutions $\sigma$ as sets of bindings.  We define the application of
%% one substitution $\sigma$ to another $\sigma'$ by
%% \[
%%   \sigma'\sigma \defeq \{ \bind x {\sigma V} \mid \bind x v \in \sigma' \}.
%% \]
%% Note that this is not the standard notion of substitution composition.  Finally, we define the
%% application of a substitution to a term $M\sigma$ by the homomorphic extension of the following
%% \begin{align*}
%%   x\sigma  &\defeq V &&\text{if $(\bind x V) \in \sigma$} \\
%%   (\lambda^{\sigma'} x.M)\sigma  &\defeq \lambda^{\sigma' \sigma} x.M \\
%%   M\sigma  &\defeq M &&\text{if $x \not\in \fv(M)$}
%% \end{align*}

%% As values, we have closures, which combine an abstraction with a captured substitution.  We will
%% treat $\lambda x.M$ as syntactic sugar for $\lambda^\sigma x.M$ where $\sigma = \{ \bind x x \mid x
%% \in \fv(M) \setminus \{ x \}\}.$ We extend the typing rules for terms with a typing rule for
%% closures:
%% \[
%% \inferrule
%%   {\Gamma, x:T \vdash M\sigma : U \\
%%    \dom(\sigma) = (\fv(M) \setminus \{ x \})}
%%   {\Gamma \vdash \lambda^\sigma x.M : T \lto U}
%% \]
%% Note that the invariant on the domain of $\sigma$ is preserved under substitution.

\subsubsection{Configurations.}

The grammar of configurations includes the usual $\pi$-calculus forms for composition and name
restriction.  However, because we are beginning with a functional language, in which computations
may return values (which may, in turn, contain channels), it is important to distinguish between the
``main'' thread (which returns a meaningful value) and the threads created by \gvconst{fork} (which
do not).  We designate the main thread in a configuration by $\bcirc M$ and forked threads by
$\wcirc M$.

\subsubsection{Reduction.}

\begin{figure}[t]
Term reduction:
\begin{align*}
  (\lambda^\sigma x.M)\,V &\teval M(\{\bind x V\} \uplus \sigma) \\
  \gvletunit{()}{M} &\teval M \\
  \gvlet{(x,y)}{(V,V')}{M} &\teval M \{ \bind x V, \bind y {V'} \} \\
  \gvcase{(\mkwd{inl}\,V)}{\mkwd{inl}\,x \mapsto N; \mkwd{inr}\,x \mapsto N'} &\teval N \{ \bind x V \} \\
  E[M] &\teval E[M'] \qquad \text{if $M \teval M'$}
\end{align*}
Configuration equivalence:
\begin{mathpar}
\Fx[\mathsf{link}\,(x,y)] \equiv \Fx[\mathsf{link}\,(y,x)]

C \parallel D \equiv D \parallel C

C \parallel (D \parallel E) \equiv (C \parallel D) \parallel E

C \parallel (\nu x)D \equiv (\nu x)(C \parallel D) \text{ if $x \not\in \fv(C)$}

\Cx[C] \equiv \Cx[D] \text{ if $C \equiv D$}
\end{mathpar}
Configuration reduction:
\begin{mathpar}
\inferrule
  [Send]
  { }
  {\Fx[\gvconst{send} \app (V,x)] \parallel \Fx'[\gvconst{receive} \app x] \ceval \Fx[x] \parallel \Fx'[(V,x)]}

\inferrule
   [Lift]
   {C \ceval C'}
   {\Cx[C] \ceval \Cx[C']}

\inferrule
  [Fork]
  {\text{$x$ is a fresh channel name}}
  {\Fx[\gvconst{fork} \app (\clos{\sigma}{y}{M})] \ceval (\nu x)(\Fx[x] \parallel M(\{\bind y x\} \uplus \sigma)}
  %% [Fork]
  %% {\text{$x$ fresh}}
  %% {\Fx[\gvconst{fork} \app V] \ceval (\nu x)(\Fx[x] \parallel (V\,x))}

\inferrule
  [Wait]
  { }
  {(\nu x)(\Fx[\gvconst{wait} \app x] \parallel \phi x) \ceval
       \Fx[()]}

\inferrule
   [Link]
   {x \in \fv(M)}
   {(\nu x) (\Fx[\gvconst{link} \app (x, y)] \parallel \Fx'[M]) \ceval (\nu x)(\Fx[x] \parallel \Fx'[\gvletunit{\gvconst{wait} \app x}{M\{y/x\}}])}

\inferrule
   [LiftV]
   {M \teval M'}
   {\Cx[M] \ceval \Cx[M']}

%% [Lift3] would allow us to slightly simplify [Send] and [Link]
%%
%% \inferrule
%%    [Lift3]
%%    {\Cx[M] \ceval \Cx[M']}
%%    {\Cx[\Fx[M]] \ceval \Cx[\Fx[M']]}
\end{mathpar}
\caption{Reduction rules and equivalences for terms and configurations}\label{fig:gv-reduction}
\end{figure}

Reduction rules for terms and configurations, and equivalences for configurations, are given in
\figref{gv-reduction}.  Term reduction is typical call-by-value left-to-right evaluation; the only
complication is that application not only substitutes for the $\lambda$-bound variables, but also
applies any substitution captured by the closure.  Configuration equivalence is also relatively
standard.  We provide an additional equivalence observing that \gvconst{link} is symmetric; this
reduces the number of reduction rules.  Communication is provided by rule \textsc{Send} and session
initiation is provided by rule \textsc{Fork}.  Rule \textsc{Wait} combines syncronization of closed
channels with garbage collection of the associated name restriction.  Rule \textsc{Link} is
complicated by the need to produce a session of type $\outterm$; the inserted \gvconst{wait}
synchronizes with the produced session.  Atypically, we do not include a structural rule, including
equivalence in reduction; we will return to the treatment of equivalence at the end of the section.

\subsubsection{Configuration typing.}

\begin{figure}[t]
Configuration typing:
\begin{mathpar}
\inferrule
  {\Gamma \vdash M: T \\
   T \not= \outterm}
  {\Gamma \vdash^\bcirc \distinguish M}

\inferrule
  {\Gamma \vdash M: \outterm}
  {\Gamma \vdash^\wcirc \thread M}

\inferrule
  {\Gamma, x:\channel{S} \vdash^\phi C}
  {\Gamma \vdash^\phi (\nu x) C}

\inferrule
  {\Gamma,x:S \vdash^{\phi} C \\
   \Gamma',x:\gvdual{S} \vdash^{\phi'} C'}
  {\Gamma,\Gamma',x:\channel{S} \vdash^{\phi + \phi'} C \parallel C'}
\end{mathpar}
Combination of flags:
\begin{mathpar}
  \wcirc + \wcirc = \wcirc

  \wcirc + \bcirc = \bcirc

  \bcirc + \wcirc = \bcirc

  \bcirc + \bcirc \text{ undefined}
\end{mathpar}
Reduction of configuration typing environments:
\begin{mathpar}
\inferrule
  { }
  {\channel{(\gvout T S)} \ceval \channel S}

\inferrule
  { }
  {\channel{(\gvin T S)} \ceval \channel S}

\inferrule
  {T \ceval T'}
  {\Gamma,x:T \ceval \Gamma,x:T'}
\end{mathpar}
\caption{Configuration typing}\label{fig:gv-conf-typing}
\end{figure}

Our syntax of configurations permits various forms of deadlocked configurations.  For example, if we
define the terms $M$ and $N$ by
\begin{align*}
  M &\defeq \bl
    \gvlet{(z,y)}{\gvreceive{y}}{} \\
    \gvlet{x}{\gvsend{(z,x)}}{M'} \el \\
  N &\defeq \bl
    \gvlet{(z,x)}{\gvreceive{x}}{} \\
    \gvlet{y}{\gvsend{(z,y)}}{N'} \el
\end{align*}
given suitable terms $M'$ and $N'$, then it is apparent that configurations such as $(\nu xy)M$,
$(\nu xy)(M \parallel M)$ and $(\nu xy)(M \parallel N)$ cannot reduce further, even though $M$ and
$N$ can be individually well-typed.  \figref{gv-conf-typing} gives our typing discipline for
configurations.  It is based on type systems for linear $\pi$-calculus~\cite{} with two significant
differences.
\begin{itemize}
\item First, we seek to assure that there is at most one main thread.  This is done by the flags
  ($\bcirc$ and $\wcirc$) on the derivations: a derivation $\Gamma \vdash^\bcirc C$ indicates that
  configuration $C$ contains the main thread, while $\Gamma \vdash^\wcirc C$ incidates that $C$ does
  not contain the main thread.  We will write $\Gamma \vdash C$ to abbreviate $\Gamma \vdash^\phi
  C$, that is, that $C$ may contain a main thread.
\item Second, we require that exactly one channel is shared at each composition of processes.  This
  restricts standard type systems for linear $\pi$-calculus, which allow an arbitrary number of
  processes (including none) to be shared at a composition of processes.
\end{itemize}
We can see that none of the earlier examples are well-typed in this type system: $(\nu xy)M$ is
ill-typed because $y$ must have a type $\channel S$ in $M$; $(\nu xy)(M \parallel M)$ is ill-typed
because there is no type $\channel S$ such that both $S$ and $\gvdual{S}$ are of the form
$\gvin{T}{S'}$, as required by \gvconst{request}, and $(\nu xy)(M \parallel N)$ is ill-typed because
both $x$ and $y$ must be shared between $M$ and $N$, but the typing rule for composition only allows
one channel to be shared.

Observe that reduction may transform the types of sessions---for example, if $\Gamma \vdash
F[\gvconst{send}\app(V,x)] \parallel F'[\gvconst{receive}\app x]$, then $\Gamma$ must contain an
assignment $x : \channel{(\gvout{T}{S})}$ for some type $T$ and session type $S$.  However, after
reduction, for $F[x] \parallel F'[(V,x)]$ to be well-typed we need $x:\channel S$.  We capture this
with the reduction relation $\Gamma \ceval \Gamma'$.  As long all reductions require evolution of
the type environment, we introduce the shorthand
\[
  \Gamma \ceval^? \Gamma' \defiff (\Gamma \ceval \Gamma') \lor (\Gamma = \Gamma').
\]
Finally, we can show that reduction preserves typing.  We begin with term reduction.
%
\begin{lemma}\label{thm:term-preservation}
  If $\Gamma \vdash M: T$ and $M \teval M'$, then $\Gamma \vdash M': T$
\end{lemma}
%
The proof is by induction on $M$; the cases are all standard.  We can extend this result to show
preservation of configuration typing under reduction.
%
\begin{theorem}\label{thm:preservation}
  If $\Gamma \vdash C$ and $C \ceval C'$ then there is some $\Gamma'$ such that $\Gamma \ceval^?
  \Gamma'$ and $\Gamma' \vdash C'$.
\end{theorem}
%
\begin{proof}
  By induction on the derivation of $C \ceval C'$.  We include several representative cases.
  \begin{itemize}
%%   \item Case \textsc{Lift} is immediate by the induction hypothesis.
%%   \item Case \textsc{LiftV} follows from \lemref{term-preservation}.
  \item In case \textsc{Send}, from the assumption $\Gamma \vdash \Fx[\mkwd{send}\,(V,x)] \parallel
    \Fx'[\gvconst{receive} \app x]$, we can assume that $\Gamma$ partitions as
    $\Gamma_1,\Gamma_2,x:\channel{S}$ such that $S = \gvout{T}{S'}$, $V$ has type $T$, and
    $\Gamma_1,x:\gvout{T}{S'} \vdash \Fx[\gvconst{send} \app (V,x)]$,
    $\Gamma_2,x:\gvin{T}{\gvdual{S'}} \vdash \Fx'[\gvconst{receive} \app x]$.  As $\gvconst{send} : T
    \times \gvout{T}{S'} \lto S'$ and $\Gamma_1,x:\gvout{T}{S'} \vdash \Fx[\gvconst{send} \app
    (V,x)]$, we can conclude that $\Gamma_1,x:S' \vdash \Fx[x]$.  By a similar argument, we conclude
    that $\Gamma_2,x:\gvdual{S'} \vdash \Fx'[(V,x)]$. Finally, as $\channel{(\gvout{T}{S})} \ceval
    \channel{S}$, $\Gamma_1,\Gamma_2,x:\channel{(\gvout T S)} \ceval
    \Gamma_1,\Gamma_2,x:\channel{S}$, and we can recompose the resulting processes concluding that
    $\Gamma_1,\Gamma_2,x:\channel{S} \vdash \Fx[x] \parallel \Fx'[(V,x)]$.
  \item In case \textsc{Fork}, from the assumption $\Gamma \vdash \Fx[\gvconst{fork} \app V]$, we
    can conlude that $\Gamma$ splits as $\Gamma_1,\Gamma_2$ and there is some $S$ such that
    $\Gamma_1,x:S \vdash \Fx[x]$ and $\Gamma_2,x:\gvdual{S} \vdash V \app x$.  Thus we have that
    $\Gamma,x:S \vdash \Fx[x] \parallel V \app x$ and $\Gamma \vdash (\nu x)(\Fx[x] \parallel V \app
    x)$.
%%   \item In case \textsc{Wait}, from the assumption $\Gamma \vdash (\nu x)(\Fx[\gvconst{wait} \app
%%     x] \parallel x)$, we can conclude that $\Gamma,x:\interm \vdash \Fx[\gvconst{wait} \app x]$ and
%%     thus, from the typing of \gvconst{wait}, that $\Gamma \vdash \Fx[()]$.
%%   \item In case \textsc{Link}, from the assumptions $\Gamma \vdash (\nu x) (\Fx[\gvconst{link} \app
%%     (x, y)] \parallel \Fx'[M]), x \in \fv(M)$, we can conclude that $\Gamma$ partitions as
%%     $\Gamma_1,\Gamma_2,y:S$ such that $\Gamma_1,y:S,x:\gvdual{S} \vdash \Fx[\gvconst{link} \app (x,
%%     y)]$ and $\Gamma_2,x:S \vdash \Fx'[M]$.  (Note that the free variable assumption on the
%%     reduction rule for \gvconst{fork} allows us to assume that neither $\Fx$ nor $\Fx'$ binds $x$ or
%%     $y$.)  From the type of \gvconst{link}, we have that $\Gamma,x:\outterm \vdash \Fx[x]$;
%%     similarly, from $x \in \fv(M)$, we can conclude that $\Gamma_2,y:S \vdash \Fx'[M\{\bind x y\}]$.
%%     Finally, from the typing rule for \gvconst{wait}, we have that $\Gamma_2,x:\interm,y:S \vdash
%%     \Fx'[\gvletunit{\gvconst{wait} \app x}{M\{\bind x y\}}]$, and that $\Gamma \vdash (\nu
%%     x)(\Fx[x] \parallel \Fx'[\gvletunit{\gvconst{wait} \app x}{M\{\bind x y\}}])$
    \qed
  \end{itemize}
\end{proof}

\subsubsection{Typing and configuration equivalence.}

Unfortunately, our notion of typing is not preserved by configuration equivalence.  For a simple
example, assume that $\Gamma \vdash (\nu x y)(C \parallel (D \parallel E))$, where $x \in \fv(C), y
\in \fv(D), \text{ and } x,y \in \fv(E)$.  We have that $C \parallel (D \parallel E) \equiv
(C \parallel D) \parallel E$, but $\Gamma \nvdash (\nu x y)((C \parallel D) \parallel E)$, as both
$x$ and $y$ must be shared between the processes $C \parallel D$ and $E$.  However, we can show that
starting from a well-typed configuration, we need never rely on an ill-typed equivalent
configuration to expose possible reductions.
%
\begin{theorem}\label{thm:preservation-equiv}
  If $\Gamma \vdash C$, $C \equiv C'$ and $C' \ceval D'$, then there are some $\Gamma',D$ such that
  $\Gamma \ceval^? \Gamma'$, $D \equiv D'$, and $\Gamma' \vdash D$.
\end{theorem}
%
\begin{proof}
  We begin by observing that if $\Gamma \vdash C$, then for any pair of terms $M_1, M_2$ appearing
  in $C$, there are environments $\Gamma_1,\Gamma_2$ and types $T_1,T_2$ such that $\Gamma_1 \vdash
  M_1 : T_1,\Gamma_2 \vdash M_2 : T_2$, and (because of the typing rule for composition) $\Gamma_1$
  and $\Gamma_2$ share at most one variable.  From this, by examination of the reduction rules, we
  can conclude that there are well-typed $C_0,D_0$ such that $C' = \Cx[C_0]$, $C_0 \ceval D_0$ and
  $D' = \Cx[D_0]$.  The desired result is then obtained by structural induction on $C$, examining
  the possible equivalences in each case. \qed
\end{proof}
%
Finally, we define $\ceval^\star$ as the reflexive, transitive closure of $\equiv\ceval\equiv$ on
configurations, and of $\ceval^?$ on typing environments.
%
\begin{corollary}
  $\Gamma \vdash C$ and $C \ceval^\star D$, there are some $\Gamma',D'$ such that $\Gamma
  \ceval^\star \Gamma'$, $D \equiv D'$, and $\Gamma' \vdash D'$.
\end{corollary}

\subsection{Deadlock and Its Absence}\label{sec:gv-deadlock}
\newcommand{\blockedp}{\mathsf{blocked}}
\newcommand{\depp}{\mathsf{depends}}
\newcommand{\deadlockp}{\ensuremath{\mathsf{deadlocked}}}

In the previous section, we showed several examples of deadlocked terms, and showed that they were
rejected by our type system.  This section generalizes that observation: we characterize deadlocked
configurations, and show that well-typed configurations do not evaluate to deadlocked
configurations.

We begin by observing that many examples of stuck configurations are already excluded by existing
session-typing disciplines: in particular, those configurations in which either too many or too few
threads attempt to synchronize on a given channel.  The cases of interest to us are those in which
the threads individually obey the session-typing discipline, but the order of synchronizations in
the threads creates deadlock.  We say that a thread $M$ is blocked on a channel $x$, written
$\blockedp(x,M)$, if $M$ has evaluated to some context surrounding a communication primitive applied
to $x$:
%
\[\begin{array}{rcl}
  \blockedp(x,M) &\defiff& \exists N. \; M = \Ex[\gvconst{send} \app (N,x)] \\
  && \quad \lor \, M = \Ex[\gvconst{receive} \app x] \\
  && \quad \lor \, M = \Ex[\gvconst{wait} \app x]
\end{array}\]
%
In such a case, $M$ can only reduce further in composition with another thread blocked on $x$, and
any synchronization on other channels in $M$ will be delayed until a synchronization on $x$ has
occurred.  We capture this by saying that $y$ depends on $x$ in $M$, written $\depp(x,y,M)$, $M$ is
blocked on $x$, but has $y$ as one of its (other) free variables.  We extend this notion of
dependency from single threads to configurations of threads, with the observation that in a larger
configuration there may be intermediate channels in the dependency.
\[\begin{array}{rcl}
  \depp(x,y,\Ex[M]) &\defiff& \blockedp(x,M) \land y \in \fv(\Ex) \\
  \depp(x,y,C) &\defiff& (C \equiv \Cx[M] \land \depp(x,y,M)) \lor \, (C \equiv \Cx[D \parallel D'] \\
  && \quad \land \, (\exists z. \depp(x,z,D) \land \depp(z,y,D')))
\end{array}\]
%
We now have a natural definition of deadlocked configurations as being those with a cycle of
dependencies:
%
\[
\deadlockp(C) \defiff C \equiv \Cx[D \parallel D'] \land \exists x,y. \depp(x,y,D) \land \depp(y,x,D').
\]
%
Because the definition of dependency permits intermediate channels, this definition encompasses
cycles involving an arbitrary number of channels.  Finally, we say that a configuration $C$ is
deadlock free if, for all $D$ such that $C \ceval^\star D$, $\lnot\deadlockp(D)$.  Observe that if
$C \equiv D$, then $\deadlockp(C) \iff \deadlockp(D)$.

At this point, we can observe that in any deadlocked configuration, there must be a composition of
configurations that shares more than one channel.  This is precisely the situation that is excluded
by our configuration type system.

\begin{lemma}\label{thm:procs-share-one-channel}
  If $\Gamma \vdash C$, and $C = \Cx[D \parallel D']$, then there is some variable $x$ such that
  $\fv(D) \cap \fv(D') = \{ x \}$.
\end{lemma}

\begin{proof}
  By structural induction on the derivation of $\Gamma \vdash C$; the only interesting case is for
  parallel composition, where the desired result is assured by the partitioning of the
  environment. \qed
\end{proof}

To extend this observation to deadlock freedom, we must take equivalence into account.  While it is
true that equivalence need not preserve typing, there are no equivalence rules that affect the free
variables of individual threads.  Thus, cycles of dependent channels are preserved by equivalence.

\begin{lemma}\label{thm:typed-configs-df}
  If $\Gamma \vdash C$ then $\lnot \deadlockp(C)$.
\end{lemma}

\begin{proof}
  By contradiction: suppose $\deadlockp(C)$.  Then we know there must be some variables
  $x_1,\dots,x_n$ and processes $M_1,\dots,M_n$ in $C$ such that
  \[
    \blockedp(x_1,x_2,M_1) \land \blockedp(x_2,x_3,M_2) \land \cdots \land \blockedp(x_n,x_1,M_n).
  \]
  But now there is no possible $\Gamma$ such that any $\Gamma \vdash C'$ for any process $C'$
  containing the $M_i$---such a $C'$ would violate \lemref{procs-share-one-channel}.  \qed
\end{proof}

Finally, we can combine the previous result with preservation of typing to show that well-typed
terms never evaluate to deadlocked configurations.

\begin{theorem}\label{thm:typed-terms-df}
  If $\Gamma \vdash M: T$, then $\distinguish M$ is deadlock-free.
\end{theorem}

\begin{proof}
  If $\Gamma \vdash M: T$, then $\Gamma \vdash \distinguish{M}$, and so
  $\lnot\deadlockp(\distinguish M)$ and, for any $D$ such that $\distinguish M \ceval^\star D$, we
  know that there is a well-typed $D' \equiv D$, and so $\lnot\deadlockp(D)$. \qed
\end{proof}

\subsubsection{Progress and Canonical Forms.}

We conclude the section by describing a canonical form for configurations, and characterizing the
stuck terms resulting from the evaluation of well-typed terms.  One might hope that evaluation of a
well-typed term would always produce a value; however, this is complicated by the possibility of
terms that return sessions.  For a simple example, consider the term
%
\[
  \gvconst{fork} \app (\lambda x. \gvlet{(y,x)}{\gvreceive{x}}{\gvsend(y,x)})
\]
%
This term spawns a thread (which simply echoes once), and then returns the resulting session; thus,
the result of evaluation is a configuration equivalent to
\[
  (\nu x)(\distinguish x \parallel \gvlet{(y,x)}{\gvreceive{x}}{\gvsend(y,x)}).
\]
Clearly, no more evaluation is possible, yet we would not describe this configuration itself as a
value.  However, we can give strong results about the configurations resulting from the evaluation
of closed term, and so to conclude that evaluation of terms that do not return channels does always
produce a value.

\begin{definition}
A process $C$ is in canonical form if there is some sequence of variables $x_1,\dots,x_{n-1}$ and
terms $M_1,\dots,M_n$ such that
\[
  C = (\nu x_1)(\thread {M_1} \parallel (\nu x_2)(\thread {M_2} \parallel \dots \parallel (\nu x_{n-1})(\thread{M_{n-1}} \parallel \phi M_n)\dots)).
\]
\end{definition}

Note that canonical forms need not be unique.  For example, consider the configuration $\vdash (\nu
xy)(C \parallel D \parallel E)$ where $x \in \fv(C), y \in \fv(D), \text{ and } x,y \in \fv(E)$.
Both $(\nu x)(C \parallel (\nu y)(D \parallel E))$ and $(\nu y)(D \parallel (\nu x)(C \parallel E))$
are canonical forms of the original configuration.  We can show that any well-typed term must be
equivalent to a term in canonical form; again, the key insight is that captured by
\lemref{procs-share-one-channel}: if any two subconfigurations share at most one channel, then we
can order the threads by the channels they share.

\begin{lemma}\label{thm:canonical}
  If $\Gamma \vdash C$, then there is some $C' \equiv C$ such that $\Gamma \vdash C'$ and $C'$ is in
  canonical form.
\end{lemma}

\begin{proof}
  Let $x_1,\dots,x_{n-1}$ be the $\nu$-bound variables in $C$ and $M_1,\dots,M_n$ be the terms in
  $P$; the proof is by induction on $n$.  If $n > 1$, then pick some $M_i$ such that there is
  exactly one $\nu$-bound variable $x_j$ where $x_j \in \fv(M_i)$.  (That there must be such an
  $M_i$ and $x_j$ can be established by a standard counting argument, together with
  \lemref{procs-share-one-channel}.)  Now, construct $D$ from $C$ by the homomorphic extension of
  the mapping $(\nu x_j)E \mapsto E$ and $E \parallel \phi M_i \mapsto E$.  From the assumption that
  $\Gamma \vdash C$, we can conclude that there is some $\Gamma' \subseteq \Gamma$ and type $S$ such
  that $\Gamma',x:S \vdash D$.  By the induction hypothesis, there is some $D' \equiv D$ in
  canonical form.  Finally, let $C' = (\nu x_j)(\phi M_i \parallel D')$; we can see that
  straightforwardly that $C'$ is in canonical form; that $C \equiv C'$; and, that $\Gamma \vdash
  C'$. \qed
\end{proof}

We can now state some simple progress results.  We begin with configurations that may have free
variables; of course, each thread must be blocked either on some previous $\nu$-bound variable or on
one of the free variables.
%
\begin{theorem}\label{thm:progress-open}
  Let $\Gamma \vdash C$, $C \centernot\ceval$ and let $C' = (\nu x_1)(\thread M_1 \parallel (\nu
  x_2)(\thread M_2 \parallel \dots \parallel (\nu x_{n-1})(\thread M_{n-1} \parallel \phi M_n)\dots))$ be a
  canonical form of $C$.  Then:
  \begin{enumerate}
  \item For $1 \leq i \leq n - 1$ either $\blockedp(x_j,M_i)$ where $j \leq i$ or $\blockedp(y,M_i)$
    for some $y \in \dom(\Gamma)$; and,
  \item Either $M_n$ is a value or $\blockedp(y,M_n)$ for some $y \in \{ x_i \mid i \leq i \leq n -
    1 \} \cup \dom(\Gamma)$.
  \end{enumerate}
\end{theorem}
%
\begin{proof}
  By induction on the derivation of $\Gamma \vdash C'$, using the definition of $\ceval$. \qed
\end{proof}

We can strengthen the result significantly when we move to configurations without free variables.
To see why, consider just the first two threads of a configuration $(\nu x_1)(M_1 \parallel (\nu
x_2)(M_2 \parallel \dots))$.  As there are no free varibles, thread $M_1$ can only be blocked on
$x_1$.  Now, from the previous result, thread $M_2$ can be blocked on either $x_1$ or $x_2$.  But,
were it blocked on $x_1$, it could reduce with thread $M_1$; we can conclude it is blocked on $x_2$.
Generalizing this observation gives the following progress result.
%
\begin{corollary}\label{thm:progress}
  Let $\vdash C$, $C \centernot\ceval$ and let $C' = (\nu x_1)(\thread M_1 \parallel (\nu
  x_2)(\thread M_2 \parallel \dots \parallel (\nu x_{n-1})(\thread M_{n-1} \parallel
  \phi M_n)\dots))$ be a canonical form of $C$.  Then:
  \begin{enumerate}
  \item For $1 \leq i \leq n - 1$, $\blockedp(x_i,M_i)$; and,
  \item $M_n$ is a value.
  \end{enumerate}
\end{corollary}
%
\begin{proof}
  By induction on the derivation of $\vdash P'$, relying on \thmref{progress-open}.  \qed
\end{proof}
%
Finally, observe that some subset of the variables $x_1,\dots,x_n$ must appear in the result $V$.
Therefore, if the original expression returns a value that does not contain any channels, it will
evaluate to a configuration with no blocked threads.

%% \subsection{Direct GV semantics}
%%
%% \newcommand{\rpar}[1]{\mathbin{{[}\:\!\!\rangle}_{\!{#1}}\!}
%% \newcommand{\lrpar}[1]{\mathbin{\langle\hspace{-.3ex}\rangle}_{\!{#1}}\!}
%% \newcommand{\lpar}[1]{\mathbin{\langle\:\!\!{]}}_{{#1}}\!}
%%
%% \newcommand{\con}[3]{{#1} \rpar{#2} {#3}}
%%
%% \[
%% \gvconst{connect} : (S \lto \outterm, \gvdual{S} \lto T) \lto T
%% \]
%%
%% Syntactic sugar:
%% \begin{align*}
%% \con{M}{x}{N} &\defiff \gvconst{connect}(\lambda x.M, \lambda x.N) \\
%% \con{L}{x}{\con{M}{y}{N}} &\defiff \con{L}{x}{(\con{M}{y}{N})} \\
%% \end{align*}
%%
%% Equivalences ($\equiv$ is the transitive, reflexive, symmetric closure of the following rules):
%% \begin{align*}
%% \gvconst{link}\,(x,y) &\equiv \gvconst{link}\,(y,x) \\
%% \con{L}{x}{\con{M}{y}{N}} &\equiv \con{M}{y}{\con{L}{x}{N}} \\
%% \con{L}{x}{\con{M}{y}{N}} &\equiv \con{(\con{L}{x}{M})}{y}{N} \\
%% %\con{L}{x}{\con{M}{y}{N}} &\equiv \con{(\con{M}{x}{L})}{y}{N} \\
%% \end{align*}
%%
%% Interesting reductions
%% \begin{align*}
%% \con{E[\gvconst{send}\,(V,x)]}{x}{E'[\gvconst{receive}\,x]}
%%   &\rto \con{E[x]}{x}{E'[(V,x)]} \\
%% \con{E[\gvconst{receive}\,x]}{x}{E'[\gvconst{send}\,(V,x)]}
%%   &\rto \con{E[(V,x)]}{x}{E'[x]} \\[1ex]
%% \con{x}{x}{E[\gvconst{wait}\,x]}
%%   &\rto E[()] \\
%% \con{E[\gvconst{wait}\,x]}{x}{x}
%%   &\rto E[()] \\[1ex]
%% \con{E[\gvconst{link}\,(x,y)]}{x}{M}
%%   &\rto \con{E[x]}{x}{(\gvconst{wait}\,x; M[y/x])} \\
%% \con{M}{x}{E[\gvconst{link}\,(x,y)]}
%%   &\rto \con{(\gvconst{wait}\,x; M[y/x])}{x}{E[x]} \\[1ex]
%% \gvconst{link}\,(x,\gvconst{link}\,(y,z))
%%   &\rto \gvconst{wait}\,x; \gvconst{link}\,(y,z) \\
%% E[\con{M}{x}{N}]
%%   &\rto \con{M}{x}{E[N]} \\
%% \end{align*}
%%
%% An alternative is to remove the final commuting conversion rule and augment the notion of value to
%% include a suitable representation of a collection of blocked communicating processes.
%%
%% Preservation
%% \begin{theorem}
%% If $\Gamma \vdash M : T$ and $M \rto N$ then $\Gamma \vdash N : T$.
%% \end{theorem}
%% %
%% \begin{proof}
%% By induction on the structure of the derivation of $\Gamma \vdash M : T$ using a standard
%% substitution lemma for the case of $\beta$-reduction at function types. \qed
%% \end{proof}
%%
%% Progress
%% \begin{theorem}
%% \label{thm:free-progress}
%% If $\Gamma$ is a session environment (all variables in $\Gamma$ have session type) such that $\Gamma
%% \vdash M : T$ then one of the following holds:
%% \begin{enumerate}
%% \item $M$ is a value; or
%% \item there exists $N = \blockedp'(y_1, M_1) \rpar{x_1} \dots \rpar{x_{n}} \blockedp'(y_{n}, M_{n})$
%%   such that $M \equiv N$ and $\Gamma \vdash N : T$; or
%% \item there exists $N$ such that $M \rto N$.
%% \end{enumerate}
%% \end{theorem}
%% %
%% \begin{proof}
%% By induction on the structure of the derivation of $\Gamma \vdash M : T$. \qed
%% \end{proof}
%% % In the second case each $y_i$ must be equal to either $x_i$ or some $x$ in $\Gamma$.
%%
%% \begin{theorem}
%% If $\vdash M : T$ then one of the following holds:
%% \begin{enumerate}
%% \item $M$ is a value; or
%% \item there exists $N = \blockedp(x_1, M_1) \rpar{x_1} \dots \rpar{x_{n-1}} \blockedp(x_{n-1},
%%   M_{n-1}) \rpar{x_n} V$ such that $M \equiv N$ and $\Gamma \vdash N : T$; or
%% \item there exists $N$ such that $M \rto N$.
%% \end{enumerate}
%% \end{theorem}
%% %
%% \begin{proof}
%% By induction on the structure of the derivation of $\vdash M : T$ using
%% \thmref{free-progress}. \qed
%% \end{proof}
%%
%% $\blockedp(x, M)$ means $M$ is blocked on a send or receive involving $x$.
%%
%% $\blockedp'(x, M)$ means either $M = x$ or $M$ is blocked on a send, receive, link, or wait
%% involving $x$.

\section{Linear Logic}\label{sec:cp}

\subsection{CP}

\begin{figure}[float]
Syntax:
\begin{syntax}
  \text{Types} & A,B & ::= & A \otimes B \mid A \parr B \mid 1 \mid \bot \mid A \oplus B \mid A \with B \mid 0 \mid \top \\
  \text{Terms} & P,Q & ::= & \link x y \mid \cut y {} P Q \mid x(y).P \mid x[y].(P \mid Q) \\
   & & \mid & x[in_i].P \mid \case{x}{P;Q} \mid x().P \mid x[].0 \mid \case{x}{} \\
\end{syntax}
Duality:
\[
\ba{@{}c@{\qquad}c@{\qquad}c@{\qquad}c@{}}
\begin{eqs}
  \cpdual{(A \otimes B)} &=& \cpdual{A} \parr \cpdual{B} \\
  \cpdual{(A \parr B)} &=& \cpdual{A} \otimes \cpdual{B} \\
\end{eqs}
&
\begin{eqs}
  \cpdual{1} &=& \bot \\
  \cpdual{\bot} &=& 1 \\
\end{eqs}
&
\begin{eqs}
  \cpdual{(A \oplus B)} &=& \cpdual{A} \with \cpdual{B} \\
  \cpdual{(A \with B)} &=& \cpdual{A} \oplus \cpdual{B} \\
\end{eqs}
&
\begin{eqs}
  \cpdual{\top} &=& 0 \\
  \cpdual{0} &=& \top \\
\end{eqs}
\ea
\]
Typing:
\begin{mathpar}
\inferrule{ }{\cptyp{\link{x}{w}}{x:A,w:\cpdual{A}}}

\inferrule{\cptyp{P}{\Gamma,y:A} \\
           \cptyp{Q}{\Delta,y:\cpdual{A}}}
          {\cptyp{\cut{y}{A}{P}{Q}}{\Gamma,\Delta}}

\inferrule{ }{\cptyp{x[].0}{x:1}}

\inferrule{\cptyp{P}{\Gamma,y:A,x:B}}
          {\cptyp{x(y).P}{\Gamma,x:A \parr B}}

\inferrule{\cptyp{P}{\Gamma,y:A} \\
           \cptyp{Q}{\Delta,x:B}}
          {\cptyp{x[y].(P \mid Q)}{\Gamma,\Delta,x:A \otimes B}}

\inferrule{\cptyp{P}{\Gamma}}
          {\cptyp{x().P}{\Gamma,x:\bot}}

\inferrule{\cptyp{P}{\Gamma,x:A_i}}
          {\cptyp{\sel{x}{in_i}.P}{\Gamma,x:A_1 \oplus A_2}}

\inferrule{\cptyp{P}{\Gamma,x:A} \\
           \cptyp{Q}{\Gamma,x:B}}
          {\cptyp{\case{x}{P;Q}}{\Gamma,x:A \with B}}

\inferrule{ }{\cptyp{\case{x}{}}{\Gamma,x:\top}}
\end{mathpar}
\caption{CP syntax and typing}\label{fig:cp-typing}
\end{figure}

\figref{cp-typing} gives the syntax and typing rules for the multiplicative-additive fragment of CP;
we let $\Delta$ range over typing environments.  The types and duality relation are the standard
propositions of classical linear logic, while the terms are based on a subset of the $\pi$-calculus.
The types $\with$ and $\oplus$ are interpreted as external and internal choice; the types $\parr$
and $\otimes$ are interpreted as input and output, while their units $\bot$ and $1$ are interpreted
as nullary input and output.  Note that CP's typing rules implicitly rebind identifiers: for
example, in the hypotheses of the rule for $\parr$, $x$ identifies a proof of $B$, while in the
conclusion it identifies a proof of $A \parr B$.

CP includes two rules that are logically derivable: the axiom rule at arbitrary propositions, which
is interpreted as channel forwarding, and the cut rule, which is interpreted as process composition.

Two of CP's terms differ from standard $\pi$-calculus terms.  The first is com\-pos\-i\-tion---rather than
having distinct name restriction and composition operators, CP provides one combined operator.  This
syntactically captures the restriction that composed processes must share exactly one channel.  The
second is output: the CP term $x[y].(P \mid Q)$ includes output, composition, and name restriction
(the name $y$ designates a new channel, bound in $P$).

\subsubsection{Cut elimination.}

\begin{figure}[t]
Structural congruence:
\begin{equations}
  \link{x}{w} &\equiv& \link{w}{x} \\
  \cut{y}{A}{P}{Q} &\equiv& \cut{y}{\cpdual{A}}{Q}{P} \\
  \cut{y}{A}{P}{\cut{z}{B}{Q}{R}} &\equiv& \cut{z}{B}{\cut{y}{A}{P}{Q}}{R}, \quad \text{if $y \not\in \fv(R)$} \\
\cut{x}{}{P_1}{Q} &\equiv& \cut{x}{}{P_2}{Q}, \quad \text{if $P_1 \equiv P_2$}
\end{equations}
Primary cut reduction rules:
\begin{equations}
\cut{x}{A}{\link{w}{x}}{P}
  &\crto& P[w/x] \\
\cut{x}{A \otimes B}{x[y].(P \mid Q)}{x(y).R}
  &\crto&
    \cut{x}{A}{Q}{\cut{y}{B}{P}{R}} \\
\cptyp{\cut{x}{1}{x[].0}{x().P}}{\Gamma}
  &\crto&
    P \\
\cut{x}{A \oplus B}{\sel{x}{in_i}.P}{\case{x}{Q_1; Q_2}}
  &\crto&
    \cut{x}{A}{P}{Q_i} \\
\cut{x}{}{P_1}{Q} &\crto& \cut{x}{}{P_2}{Q}, \quad \text{if $P_1 \crto P_2$}
\end{equations}%
Commuting conversions:
\begin{equations}
  \cut{z}{A}{x[y].(P \mid Q)}{R} &\ccto& x[y].(\cut{z}{A}{P}{R} \mid Q), \qquad \text{if $z \not\in \fv(Q)$} \\
  \cut{z}{A}{x[y].(P \mid Q)}{R} &\ccto& x[y].(P \mid \cut{z}{A}{Q}{R}), \qquad \text{if $z \not\in \fv(P)$} \\
  \cut{z}{A}{x(y).P}{Q} &\ccto& x(y).\cut{z}{A}{P}{Q} \\
  \cut{z}{A}{\sel{x}{in_i}.P}{Q} &\ccto& \sel{x}{in_i}.\cut{z}{A}{P}{Q} \\
  \cut{z}{A}{\case{x}{P;Q}}{R} &\ccto& \case{x}{\cut{z}{A}{P}{R}; \cut{z}{A}{Q}{R}} \\
\end{equations}
\caption{CP congurences and cut reduction}\label{fig:cp-reduction}
\end{figure}

The semantics of CP terms are given by cut reduction, as shown in \figref{cp-reduction}.  We write
$\fv(P)$ for the free names of process $P$.  Terms are identified up to structural congruence
$\equiv$.  Note that, as name restriction and composition are combined into one form, composition is
not associative.  The majority of the cut reduction rules correspond closely to the synchronous
reductions in $\pi$-calculus---for example, the reduction of $\with$ against $\oplus$ corresponds to
the synchronization of an internal and external choice.  The rule for reduction of $\parr$ against
$\otimes$ is more complex than the usual synchronization of input and output, as it must also
manipulate the implicit name restriction and composition in CP's output term.  The commuting
conversions allow composition to be moved under prefixes; they do not correspond to any reduction
rule in $\pi$-calculus.  We define $\bigcrto$ to be the reflexive, transitive closure of
$\equiv\crto\equiv$, and $\bigccto$ as $\bigcrto\ccto^\star$.

Just as cut elimination in logic can be used to show that any proof can be transformed to a proof
that does not make use of cut, the reduction rules of CP transform any term into a term blocked on
an external communication---that is to say, if $P \vdash \Delta$, then $P \bigccto P'$ where $P'
\not= \cut x {} Q {Q'}$ for any $x,Q,Q'$. Note that the commuting conversions play a central role in
this transformation, moving any further internal communication beneath the external communication.

\subsubsection{A simpler send.}

The CP send rule is appealing because if one erases the terms it is exactly the classical linear
logic rule for tensor. However, this correspondence comes at a price. Operationally, the process
$x[y].(P \mid Q)$ does three things: it introduces a fresh variable $y$, it sends $y$ to a freshly
spawned process $P$, and in parallel it continues as process $Q$.  This complicates both the
reduction semantics of CP (as the cut reduction of $\otimes$ against $\parr$ must account for all
three behaviors) and the equivalence of CP and GV (where the behavior of \gvconst{send} is simpler).

We can give an alternative formulation of send, avoiding the additional name restriction and
composition, as follows:
\begin{mathpar}
\inferrule
  {\cptyp{P}{\Gamma,x:B,y:A}}
  {\cptyp{x\sd{y}.P}{\Gamma,x:A \otimes B,y:\cpdual{A}}}
\end{mathpar}
where $x\sd{y}.P$ is defined as $x[z].(\link y z \mid P)$.  In particular, note that
\begin{equations}
  \cut x {} {x\sd{y}.P}{x(z).Q}
     &=& \cut x {} {x[z].(\link y z \mid P)} {x(z).Q} \\
     &\crto& \cut z {} {\link y z} {\cut x {} P {Q}} \\
     &\crto& \cut x {} P {Q \{ y/z \}}
\end{equations}
as we would expect for synchronizing a send and a receive.  Similarly, we note that any process
$x[y].(P \mid Q)$ can also be expressed as a process $\cut y {} P {x\sd{y}.Q}$, which reduces to the
original by one application of the commuting conversions.  However, the two formulations are not
quite identical. Let us consider the possible reductions of the two terms.  Notice that in $x[y].(P
\mid Q)$, both $P$ and $Q$ are blocked on $x$; however, the same is not true for $\cut y {} P
{x\sd{y}.Q}$; the latter permits reductions in $P$ before synchronizing on $x$.

\todo{End of revised text}

%% on the representation of cut-send in terms of send. Let $P_1 = x[y].(P \mid Q)$ and $P_2 =
%% \cut{y}{}{P}{x[y].Q}$. Notice that $P_1$ is blocked, but $P_2$ may not be as it allows reductions to
%% take place inside $P$.
%% %
%% Now let us consider the possible reductions on the representation of send in terms of cut-send. Let
%% $Q_1 = x[y].P$ and $Q_2 = x[z].(\link{y}{z} \mid P)$. Clearly both $Q_1$ and $Q_2$ are blocked.
%%
%% This is painful on many levels, but in particular it complicates our attempts to relate the
%% semantics of CP with that of GV (whose send operator only does one thing: performing a send).
%%
%% Fortunately, we can give an alternative rule for send, corresponding with the send operator of GV,
%% and which gives rise to a system which is entirely equivalent to CP, apart from having a slightly
%% different syntax.
%% %
%%
%% The cut rule for a send against a receive is straightforward:
%% \begin{equations}
%% \cut{x}{A \otimes B}{x[y].P}{x(y).Q} &\rto& \cut{x}{B}{P}{Q} \\
%% \end{equations}
%% %
%% For clarity let us refer to the original form as cut-send, and the one we have just defined as send.
%%
%% It we take send as primitive, then we can express cut-send as a macro:
%% \[
%% x[y].P \defeq x[z].(\link{y}{z} \mid P)
%% \]
%% Conversely, if we take cut-send as primitive, then we can express send as a macro:
%% \[
%% x[y].(P \mid Q) \defeq \cut{y}{}{P}{x[y].Q}
%% \]
%%
%% With cut-send as primitive we can simulate a cut of a send against a receive in two steps.
%% \begin{equations}
%%   \cut{x}{}{x[y].P}{x(y).Q}
%%     &\defeq& \cut{x}{}{x[z].(\link{y}{z} \mid P)}{x(y).Q} \\
%%     &\rto& \cut{z}{}{\link{y}{z}}{\cut{x}{}{P}{Q}} \\
%%     &\rto& \cut{x}{}{P}{Q} \\
%% \end{equations}
%%
%% With send as primitive we can simulate a cut of a cut-send against a receive in one step.
%% \begin{equations}
%%   \cut{x}{}{x[y].(P \mid Q)}{x(y).R}
%%     &\defeq& \cut{x}{}{\cut{y}{}{P}{x[y].Q}}{x(y).R} \\
%%     &\equiv& \cut{y}{}{P}{\cut{x}{}{x[y].Q}{x(y).R}} \\
%%     &\rto& \cut{y}{}{P}{\cut{x}{}{Q}{R}} \\
%% \end{equations}
%%
%% Using these two observations it is straightforward to show that CP with send is equivalent to CP
%% with cut-send. In order to simplify our formal development, we will work with CP with send from now
%% on.
%%
%% However, there is a slightly subtlety.
%%
%% This discrepancy, suggests that perhaps we should have added the following congruence rule to CP in
%% the first place:
%% \begin{mathpar}
%% \inferrule
%%   {P_1 \longrightarrow P_2}
%%   {x[y].(P_1 \mid Q) \longrightarrow x[y].(P_2 \mid Q)}
%% \end{mathpar}
%% %

\todo{Do we want to state anything more formal relating CP-cut-send with CP-send?}

\subsection{Translation from CP to GV}

\begin{figure}[float]
On types:
\[
\ba{@{}c@{\quad}c@{\quad}c@{\quad}c}
\begin{eqs}
\togv{A \otimes B} &=& \gvout{\gvdual{\togv{A}}}{\togv{B}} \\
\togv{A \parr B}   &=& \gvin{\togv{A}}{\togv{B}} \\
\end{eqs}
&
\begin{eqs}
\togv{1}           &=& \outterm \\
\togv{\bot}        &=& \interm \\
\end{eqs}
&
\begin{eqs}
\togv{A \oplus B} &=& \togv{A} \oplus \togv{B} \\
\togv{A \with B}  &=& \togv{A} \with \togv{B}
\end{eqs}
&
\begin{eqs}
\togv{0}    &=& \gvout{\zero}{\outterm} \\
\togv{\top} &=& \gvin{\zero}{\interm}
\end{eqs}
\ea
\]
On terms:
\begin{equations}
  \togv{\cut{x}{}{P}{Q}} &=&
    \gvlet{x}{\gvfork{x}{\togv{P}}}{\togv{Q}} \\
  \togv{\link{x}{y}} &=& \gvlink{x}{y} \\
  \togv{x[y].(P \mid Q)} &=&
    \gvlet{x}{\gvsend{(\gvfork{y}{\togv{P}}, x)}}{\togv{Q}} \\
%%   \togv{x[y].P} &=&
%%     \gvlet{x}{\gvsend{(y, x)}}{\togv{P}} \\
  \togv{x(y).P} &=&
    \gvlet{(y,x)}{\gvreceive{x}}{\togv{P}} \\
  \togv{x[].0} &=& x \\
  \togv{x().P} &=& \gvlet{()}{\gvwait{x}}{\togv{P}} \\
  \togv{\sel{x}{\mathit{l}}.P} &=&
    \gvlet{x}{\gvselect{l}{x}}{\togv{P}} \\
  \togv{\case{x}{P;Q}} &=&
    \mkwd{offer} \: x \: \{ \mkwd{inl} \app x \mapsto \togv P; \mkwd{inr} \app x \mapsto \togv Q \} \\
  \togv{\case{x}{}} &=& \gvlet{(y,x)}{\gvreceive{x}}{\mkwd{absurd}\app y}
\medskip
\\
  \togvc{\cut{x}{}{P}{Q}} &=&
    (\nu x)(\togvc{P} \parallel \togvc{Q}) \\
  \togvc{P} &=& \thread \togv{P}, \quad \text{$P$ is not a cut} \\
\end{equations}%
\caption{Translation of CP Terms into GV}\label{fig:from-cp}
\end{figure}

In this section, we show that CP can be simulated in GV.  \figref{from-cp} gives the translation of
CP types and terms into GV; we translate typing environments by the pointwise extension of the
translation on types.  We rely on our encoding of branching and choice in GV~\secref{gv-static} in
the translations of both types and terms; for example, expanding the translation of $\with$ would
give $\togv{A \with B} = \gvin{(\togv{A} + \togv{B})}{\interm}.$ In translating CP terms to GV
terms, the key observation is that CP terms contain their continuations; thus, for example, the
translation of input includes both a call to \gvconst{receive} and the translation of the
continuation.  Additionally, the rebinding that is implicit in CP syntax is made explicit in GV.
The translation $\togvc{-}$ translates top-level composition (i.e., composition not under any
prefix) to GV configurations; cuts that appear under prefixes (and thus in GV terms) are translated
to applications of \gvconst{fork}.  As CP processes do not have return values, we translated each
process to a thread returning $\outterm$; consequently, the translation of a CP process contains no
main thread.

It is a straightforward verification that the translation preserves typing; note that the channels
in the CP typing environment become free variables in its GV translation.
%
\begin{theorem}
If $P \vdash \Delta$ then $\togv{\Delta} \vdash^\wcirc \togvc{P}$.
\end{theorem}
%
Structural congruence in CP is a subset of the structural congruence relation for GV configurations;
thus the translation trivially preserves congruence.
%
\begin{theorem}
If $P \equiv Q$, then $\togvc{P} \equiv \togvc{Q}$.
\end{theorem}
%
Finally, observe that the translation of any prefixed CP term is a GV thread of either the form $F[K
\app M]$ for $K \in \{ \gvconst{send}, \gvconst{receive}, \gvconst{wait} \}$ or is $\wcirc x$ for
some variable $x$.  Thus, we can see that any cut reduction immediately possible for a process $P$
is similarly possible for $\togv{P}$.  Following such a reduction, however, several additional GV
reductions may be necessary to expose the next possible communication---for example, substituting
the received values into the continuation in the case of the translation of input, or spawning new
threads in the translation of composition.
%
\begin{theorem}\label{thm:cp-reduction-simulated}
If $P \vdash \Gamma$ and $P \crto Q$, then $\togvc{P} \rto^+ \togvc{Q}$.
\end{theorem}
%
\begin{proof}
  By induction on $P$; the cases are all straightforward.
\end{proof}
%
The commuting conversions in CP do not expose additional reductions, but are only necessary to
assure that the result of evaluation does not have a cut at the top level.  Our characterization of
deadlock freedom in GV has no such requirement, so we have no need of corresponding steps in GV.


%% \subsection{Functions as Processes}
%%
%% \todo{Probably scrap this, as it turns out to be wrong.}
%%
%% Following our previous work, we show that functions in GV can be translated into processes, and in
%% particular that the translation respects the semantics.

%% \[
%% \topi{T \lto U} = \gvout{\topi{T}}{\topi{U}}
%% \]
%%
%% \begin{equations}
%% \topi{\lambda x.M} &=& \gvfork{z}{\gvlet{(x, z)}{\gvreceive{z}}{\gvlink{\topi{M}}{z}}} \\
%% \topi{L\,M}        &=& \gvsend{(\topi{M},\topi{L})} \\
%% \topi{\gvfork{x}{M}} &=& \gvfork{x}{\gvsend{(x,\topi{M})}} \\
%% \end{equations}
%%
%%
\subsection{Direct Translation from GV to CP}

\newcommand{\tocpflip}[1]{\llceil{#1}\rrceil}

\[
\ba{@{}c@{\qquad}c@{\qquad}c}
\begin{eqs}
\tocp{\zero} &=& \top \\
\tocp{\one} &=& \bot
\end{eqs}
&
\begin{eqs}
\tocp{\gvout{T}{S}}        &=& \cpdual{\tocp{T}} \otimes \tocp{S} \\
\tocp{\gvin{T}{S}}         &=& \tocp{T} \parr \tocp{S} \\
\end{eqs}
&
\begin{eqs}
\tocp{\outterm}            &=& 1 \\
\tocp{\interm}             &=& \bot \\
\end{eqs}
\ea
\]

\begin{equations}
\tocp{T} &=& \cpdual{\tocpflip{T}}, \quad \text{if $T$ is not a session type} \\
\tocpflip{T + U} &=& \tocpflip{T} \oplus \tocpflip{U} \\
\tocpflip{T \times U} &=& \tocpflip{T} \otimes \tocpflip{U} \\
\tocpflip{T \lto U} &=& \cpdual{\tocpflip{T}} \parr \tocpflip U \\
\tocpflip{S} &=& \tocp{S} \\
\end{equations}

\begin{equations}
\tocp{x}z &=& \link x z \\
\tocp{\gvconst{fork}\:M}z &=&
  \cut{w}{}{\link w z}{\cut{x}{}{\tocp{M}x}{\cut{y}{}{x\sd{w}.\link x y}{y[]}}} \\
%% \tocp{\gvconst{fork}\:(\clos{\sigma}{x}{M})}z &=&
%%   \tocp{\sigma}(\cut{x}{}{\cut{y}{}{\tocp{M}{y}}{y[]}}{\link x z}) \\
\tocp{\gvlink{M}{N}}z &=& \cut{x}{}{\tocp{M}x}{\cut{y}{}{\tocp{N}y}{z().\link x y}} \\
\tocp{\gvsend{(M,N)}}z &=&
  \cut{x}{}{\tocp{N}x}{\cut{y}{}{\tocp{M}y}{x\sd{y}.\link x z}} \\
%% SL: we need these eta-expanded definitions for receive and wait
%% in order for the simulation theorem to hold
\tocp{\gvreceive{M}}z &=&
  \cut{y}{}{\tocp{M}y}{y(x).\cut{w}{}{\link w y}{z\sd{x}.\link w z}} \\
\tocp{\gvwait{M}}z    &=&
  \cut{y}{}{\tocp{M}y}{y().z[]} \\
%% \tocp{\gvreceive{M}}z &=& \tocp{M}z \\
%% \tocp{\gvwait{M}}z    &=& \tocp{M}z \\
\tocp{\lambda^\sigma x.M}z &=& \tocp{\sigma}(z(x).\tocp{M}z) \\
\tocp{L \app M}z &=&
  \cut{x}{}{\tocp{M}x}{\cut{y}{}{\tocp{L}y}{y\sd{x}.\link y z}} \\
\tocp{()}z    &=& z[] \\
\tocp{(M,N)}z &=& \cut{x}{}{\tocp{M}x}{\cut{y}{}{\tocp{N}y}{z\sd{x}.\link y z}} \\
\tocp{\gvlet{(x,y)}{M}{N}}z &=& \cut{y}{}{\tocp{M}y}{y(x).\tocp{N}z} \\
\tocp{\gvlet{()}{M}{N}}z &=& \cut y {} {\tocp{M}y} {y().\tocp{N}z} \\
\tocp{\mkwd {inl} \app M}z &=& \cut{x}{}{\tocp{M}x}{z[\mkwd{inl}].\link x z} \\
\tocp{\mkwd {inr} \app M}z &=& \cut{x}{}{\tocp{M}x}{z[\mkwd{inr}].\link x z} \\
\tocp{\gvcase{L}{\mkwd {inl} \app x \mapsto M;
                 \mkwd {inr} \app x \mapsto N}}z &=&
   \cut x {} {\tocp{L}x} {\case{x}{\mkwd{inl} \mapsto \tocp{M}z;
                                   \mkwd{inr} \mapsto \tocp{N}z}} \\
\tocp{\mkwd{absurd} \app L}z &=& \cut x {} {\tocp{L}x} {\mkwd{case}\app x \app \{ \}}
\medskip
\\
\tocp{[x_i \mapsto V_i]_i}P &=& \hat{\nu}(x_i \mapsto \tocp{V_i}x_i)[P] \\
\\
\hat{\nu}(x_i \mapsto P_i)_i[P] &\defeq& \cut{x_1}{}{P_1}{\dots \cut{x_n}{}{P_n}{P}\dots}
\end{equations}

\todo{Explain $\parallel_x$ notation; do we actually use this anywhere else?}

\todo{Sort out how we deal with constants. Currently our translation of fork doesn't make sense - it
  should be a translation of fork M. The translations of link (M, N) and send (M, N) are OK if we
  insist constants are always fully applied. But perhaps we can reasonably change them to
  translations of link M and send M.}

\todo{Actually, this translation is looser than we need. It captures call-by-value, but doesn't
  enforce left-to-right evaluation of applications and pairs. Is this what we want?}

\todo{In fact we can get away with the simpler definition for wait - perhaps we should?}

\begin{equations}
\tocp{\thread M}z        &=& \cut{y}{}{\tocp{M}y}{y[]} \\
\tocp{\distinguish M}z   &=& \tocp{M}z \\
\tocp{(\nu x)C}z         &=& \tocp{C}z \\
\tocp{C \parallel_x C'}z &=& \cut{x}{}{\tocp{C}z}{\tocp{C'}z} \\
%% \tocpbig{
%%   \inferrule
%%     {\Gamma,x:S \vdash^{\phi} C \\
%%      \Gamma',x:\gvdual{S} \vdash^{\phi'} C'}
%%     {\Gamma,\Gamma',x:\channel{S} \vdash^{\phi + \phi'} C \parallel C'}}z &=&
%%     \bl
%%     \cut{x}{}{\tocp{C_1}z}{\cut{y}{}{\tocp{C_2}y}{y[]}} \\
%%     \quad \text{where }C_1,C_2 =
%%     \left\{
%%       \ba{l}
%%        C,C' \quad \text{if }\phi = \bcirc \\
%%        C',C \quad \text{otherwise} \\
%%       \ea \right. \\
%%     \el \\
  %% \left\{
  %%   \ba{l}
  %%   \cut{x}{}{\cut{y}{}{\tocp{C}y}{y[]}}{\tocp{C'}z} \\
  %%   \qquad\text{if $\phi' = \bcirc$;} \\
  %%   \cut{x}{}{\tocp{C}z}{\cut{y}{}{\tocp{C'}y}{y[]}} \\
  %%   \qquad\text{otherwise.}
  %%   \ea \right.
\end{equations}

\paragraph{Type soundness}

\begin{theorem}
  If $\Gamma \vdash M : T$, then $\tocp{M}z \vdash \tocp{\Gamma}, z:\cpdual{\tocp{T}}$.
\end{theorem}
\begin{proof}
By induction on the derivation of $\Gamma \vdash M : T$.\qed
\end{proof}

\begin{theorem}
  If $\Gamma \vdash C$, then $\tocp{C}z \vdash \tocp{\Gamma}, z:\cpdual{\tocp{T}}$.
\end{theorem}
\begin{proof}
By induction on the derivation of $\Gamma \vdash C$.\qed
\end{proof}

\paragraph{Semantic soundness}

\begin{theorem}
If $\Gamma \vdash C \equiv D$, then $\tocp{C}z \equiv \tocp{D}z$.
\end{theorem}
%
\begin{proof}
By induction on the derivation of $\Gamma \vdash C$.\qed
\end{proof}

As the translation on terms and configurations are compositional, we can mechanically lift them to
translations on evaluation contexts and configuration contexts, such that the following lemma holds
by construction.
%
%% In order to ease reasoning by induction, we lift the translation on terms to contexts.
%% \begin{equations}
%% \tocp{\Ex}[\Ex{M}]z &=& \tocp{\Ex[M]}z \\
%% \tocp{\Fx}[\Fx{M}]z &=& \tocp{\Fx[M]}z \\
%% \tocp{\Gx}[\Gx{M}]z &=& \tocp{\Gx[M]}z \\
%% \end{equations}
%% That these equations are well-defined follows from compositionality of the translation on terms.
%% The following lemmas can be made to hold, by construction.
%
\begin{lemma}
~
\begin{enumerate}
\item $\tocp{\Ex[M]}z = \tocp{\Ex}[\tocp{M}]z$
\item $\tocp{\Fx[M]}z = \tocp{\Fx}[\tocp{M}]z$
\item $\tocp{\Cx[C]}z = \tocp{\Cx}[\tocp{C}]z$
\end{enumerate}
\end{lemma}
Each translation of a context takes two arguments: a function that describes the CP term to plug
into the hole, and an output channel.

\todo{Perhaps include the full definitions in an appendix?}

In order to prove that reduction is preserved by the translation we need a substitution lemma.
\begin{lemma}
\label{lem:tocp-subst}
If $\Gamma \vdash M : T$, $\Gamma \vdash \sigma : \Delta$, and $z \notin \dom(\sigma)$, then
$\tocp{\sigma}(\tocp{M}z) \rto^* \tocp{\sigma(M)}z$.
\end{lemma}
\begin{proof}
By induction on the structure of $M$. Here we show the cases for variables and closures.
\begin{itemize}
\item Case $x$. By linearity there exists $V$ such that $\sigma = [x \mapsto V]$.
\[
\tocp{\sigma}(\tocp{x}z) =
\cut{x}{}{\tocp{V}x}{\link{x}{z}} \rto \tocp{V}z = \tocp{\sigma(x)}z
\]
\item Case $\clos{\sigma'}{x}{M}$.
\[
\bl
\quad \tocp{\sigma}(\tocp{\clos{\sigma'}{x}{M}}) \\
= \quad (\sigma' = [x_i \mapsto V_i]) \\
\quad \tocp{\sigma}(\hat{\nu} (x_i \mapsto (\tocp{V_i}x_i))_i[z(x).\tocp{M}z]) \\
= \quad (\sigma = \sigma_1 \uplus \dots \uplus \sigma_n \text{ where } \dom(\sigma_i) = \fv(V_i)) \\
\quad \tocp{\sigma_1}(\dots\tocp{\sigma_n} (\hat{\nu} (x_i \mapsto \tocp{V_i}x_i)_i[z(x).\tocp{M}z])) \\
= \quad (\text{structural equivalence}) \\
\quad \hat{\nu} (x_i \mapsto \tocp{\sigma_i}(\tocp{V_i}x_i))_i[z(x).\tocp{M}z] \\
\rto^* (\text{IH}) \\
\quad \hat{\nu} (x_i \mapsto \tocp{\sigma_i(V_i)}x_i)_i[z(x).\tocp{M}z] \\
= \quad (\sigma_i(V_i) = \sigma(V)) \\
\quad \hat{\nu} (x_i \mapsto \tocp{\sigma(V_i)}x_i)_i[z(x).\tocp{M}z] \\
= \quad (\text{definition of }\tocp{-}) \\
\quad \tocp{\clos{\sigma(\sigma')}{x}{M}} \\
= \quad (\text{definition of substitution}) \\
\quad \tocp{\sigma(\clos{\sigma'}{x}{M})} \\
\el
\]
\end{itemize}
Each of the remaining non-binding form cases follows straightforwardly using the induction
hypothesis. Each of the remaining binding form cases requires a commuting conversion in order to
push the appropriate substitution through a prefix.\qed
\end{proof}

%% [INLINED]
%%
%% \begin{lemma}
%% If $\tocp{M}z \rto \tocp{N}z$ then $\tocp{E}[\tocp{M}]z \rto \tocp{E}[\tocp{N}]z$.
%% \end{lemma}
%% \begin{proof}
%% This follows straightforwardly by observing that the translation of an evaluation context never
%% places its argument inside a prefix.
%% \end{proof}

\begin{theorem}
If $\Gamma \vdash M$, $\Gamma \vdash N$, and $M \teval N$, then $\tocp{M}z
\rto^* \tocp{N}v$.
\end{theorem}
%
\begin{proof}
By induction on the derivation of $M \teval N$. Here we show the case of $\beta$-reduction.
\begin{itemize}
\item Case $(\lambda^\sigma x.M)\,V \teval M(\{\bind x V\} \cup \sigma)$.
\[
\bl
\quad \tocp{(\lambda^\sigma x.M)\,V}z \\
= \quad (\text{definition of }\tocp{-}) \\
\quad \cut{w}{}{\tocp{V}w}{\cut{y}{}{\tocp{\sigma}(y(x).\tocp{M}y)}{y[x](\link{w}{x} \mid \link{y}{z})}} \\
\rto (\text{cut send against receive}) \\
\quad \cut{w}{}{\tocp{V}w}{\cut{y}{}{\link{y}{z}}{\cut{x}{}{\link{w}{x}}{\tocp{\sigma}(\tocp{M}y)}}} \\
\rto^* (\text{cut links and $\alpha$ rename}) \\
\cut{x}{}{\tocp{V}x}{\tocp{\sigma}(\tocp{M}z)} \\
= \quad (\text{by Lemma~\ref{lem:tocp-subst}}) \\
\tocp{M(\{\bind x V\} \cup \sigma)}
\el
\]
\end{itemize}
The remaining base cases are similarly direct. The inductive case for reduction inside an evaluation
context follows straightforwardly by observing that the translation of an evaluation context never
places its argument inside a prefix.\qed
\end{proof}

\begin{theorem}\label{thm:gv-reduction-simulated}
If $\Gamma \vdash C$, $\Gamma' \vdash D$, $\Gamma \rto \Gamma'$, and $C \ceval D$, then $\tocp{C}z
\Longrightarrow \tocp{D}z$ where $\Longrightarrow ~\defeq~ (\equiv\rto\equiv)^*$.
\end{theorem}
\begin{proof}
By induction on the derivation of $C \ceval D$. Here we show the case of send/receive reduction.
\begin{itemize}
\item Case $\Fx[\gvconst{send} \app (V,x)] \parallel \Fx'[\gvconst{receive} \app x] \ceval \Fx[x]
  \parallel \Fx'[(V,x)]$.
%
\[
\bl
\quad \tocp{\Fx[\gvconst{send} \app (V,x)] \parallel \Fx'[\gvconst{receive} \app x]}z \\
= \\
\quad \cut{x}{}
        {\tocp{\Fx}[\tocp{\gvconst{send} \app (V,x)}y]z}
        {\tocp{\Fx'}[\tocp{\gvconst{receive} \app x}]z} \\
= \\
\quad
  \nu x(
    {\tocp{\Fx}
      [z \mapsto \cut{v}{}{\tocp{V}v}
        {\cut{w}{}{\link{x}{w}}{w\sd{v}.\link{w}{z}}}]z} \\
\qquad \mid
    {\tocp{\Fx'}
       [z \mapsto \cut{y}{}
          {\link{x}{y}}
          {y(v).\cut{w}{}{\link{y}{w}}{z\sd{v}.\link{w}{z}}}]z} \\
\Longrightarrow (\text{cut links}) \\
\quad
  \nu x(
    {\tocp{\Fx}
       [z \mapsto \cut{v}{}{\tocp{V}v}
         {x\sd{v}.\link x z}]z} \\
\qquad \mid
    {\tocp{\Fx'}
       [z \mapsto x(v).\cut{w}{}{\link{x}{w}}{z\sd{v}.\link{w}{z}}]z} \\
\Longrightarrow (\text{cut send against receive}) \\
\quad
  \cut{x}{}
    {\tocp{\Fx}
       [z \mapsto
         \cut{v}{}{\tocp{V}v}{\link x z}]}
    {\tocp{\Fx'}
       [z \mapsto \cut{w}{}{\link{x}{w}}{z\sd{v}.\link{w}{z}}]z} \\
\equiv \\
\quad
  \cut{x}{}
    {\tocp{\Fx}[z \mapsto \link x z]z}
    {\tocp{\Fx'}[z \mapsto
      \cut{v}{}{\tocp{V}v}
        {\cut{w}{}{\link{x}{w}}
          {z\sd{v}.\link{w}{z}}}]z} \\
= \\
\quad \tocp{\Fx[x] \parallel \Fx'[(V,x)]} \\
\el
\]

%% This is what goes wrong if we don't use the convoluted translation of receive.
%% \[
%% \bl
%% \quad \tocp{\gvconst{send} \app (V,x) \parallel \distinguish{\gvconst{receive} \app x}}z \\
%% = \\
%% \quad \cut{x}{}
%%         {\cut{y}{}{\tocp{\gvconst{send} \app (V,x)}y}{y[]}}
%%         {\tocp{\gvconst{receive} \app x}z} \\
%% = \\
%% \quad
%%   \cut{x}{}
%%     {\cut{y}{}{
%%      \cut{v}{}{\tocp{V}v}
%%       {\cut{w}{}{\link{x}{w}}{w[v].\link{w}{y}}}}{y[]}}
%%     {\link x z} \\
%% = \\
%% \quad
%%   \cut{v}{}{\tocp{V}v}
%%     {\cut{x}{}
%%       {\cut{y}{}
%%         {\cut{w}{}{\link{x}{w}}{w[v].\link{w}{y}}}{y[]}}
%%       {\link x z}} \\
%% = \\
%% \quad
%%   \cut{v}{}{\tocp{V}v}
%%     {\cut{y}{}
%%       {\cut{x}{}
%%         {\cut{w}{}{\link{x}{w}}{w[v].\link{w}{y}}}{\link x z}}
%%       {y[]}} \\
%% = \\
%% \quad
%%   \cut{v}{}{\tocp{V}v}
%%     {\cut{y}{}
%%       {\cut{w}{}
%%         {\cut{x}{}
%%           {\link{x}{w}}
%%           {\link x z}}
%%         {w[v].\link{w}{y}}}
%%       {y[]}} \\

%% %% \rto^* \\
%% %% \quad
%% %%     \cut{y}{}{
%% %%      \cut{v}{}{\tocp{V}v}
%% %%       {z[v].\link{z}{y}}}{y[]} \\
%% %% = \\
%% %% \dots \\
%% %% = \\
%% %% \quad
%% %%   \cut{x}{}
%% %%     {x[]}
%% %%     {\cut{v}{}{\tocp{V}v}
%% %%       {z[v].\link{x}{z}}} \\
%% %% {}^*\!\longleftarrow \\
%% = ...\\
%% \quad
%%   \cut{v}{}
%%     {\tocp{V}v}
%%     {\cut{y}{}
%%       {\cut{w}{}
%%         {\cut{x}{}
%%           {\link{x}{w}}
%%           {\link x y}}
%%         {z[v].\link{w}{z}}}
%%       {y[]}} \\
%% = \\
%% \quad
%%   \cut{v}{}
%%     {\tocp{V}v}
%%     {\cut{y}{}
%%       {\cut{x}{}
%%         {\link x y}
%%         {\cut{w}{}{\link{x}{w}}
%%           {z[v].\link{w}{z}}}}
%%       {y[]}} \\
%% = \\
%% \quad
%%   \cut{v}{}
%%     {\tocp{V}v}
%%     {\cut{x}{}
%%       {\cut{y}{}{\link x y}{y[]}}
%%       {\cut{w}{}{\link{x}{w}}
%%          {z[v].\link{w}{z}}}} \\
%% = \\
%% \quad
%%   \cut{x}{}
%%     {\cut{y}{}{\link x y}{y[]}}
%%     {\cut{v}{}{\tocp{V}v}
%%       {\cut{w}{}{\link{x}{w}}
%%          {z[v].\link{w}{z}}}} \\
%% = \\
%% \quad
%%   \cut{x}{}
%%     {\cut{y}{}{\link x y}{y[]}}
%%     {\tocp{(V,x)}z} \\
%% = \\
%% \quad \cut{x}{}{\cut{y}{}{\tocp{x}y}{y[]}}{\tocp{(V,x)}z} \\
%% = \\
%% \quad \tocp{x \parallel \distinguish{(V,x)}} \\
%% \el
%% \]

\item Case $(\nu x)(\Fx[\gvconst{wait} \app x] \parallel \wcirc\,x) \ceval \Fx[()]$.
\[
\bl
\quad \tocp{(\nu x)(\Fx[\gvconst{wait} \app x] \parallel \wcirc\,x)}z \\
%% = \\
%% \quad \cut{x}{}{\tocp{\Fx}[y \mapsto \tocp{\gvconst{wait} \app x}y]z}
%%                {\tocp{\wcirc}[\tocp{x}]z} \\
= \\
\quad \cut{x}{}{\tocp{\Fx}[y \mapsto \cut{w}{}{\link w x}{w().y[]}]z}
               {\cut{y}{}{\link x y}{y[]}} \\
\Longrightarrow (\text{cut links and cut end channels}) \\
\quad \cut{x}{}{\tocp{\Fx}[y \mapsto y[]]z}{x[]} \\
= \\
\quad \tocp{\Fx[()]}z \\
\el
\]

\item Case $\Fx[\gvconst{fork} \app (\clos{\sigma}{x}{M})]
                      \ceval (\nu x)(\Fx[x] \parallel M\sigma)$.
\[
\bl
\quad \tocp{\Fx[\gvconst{fork} \app (\clos{\sigma}{x}{M})]}z \\
= \\
\quad \tocp{\Fx}[\tocp{\gvconst{fork} \app (\clos{\sigma}{x}{M})}]z \\
= \\
\quad \tocp{\Fx}[z \mapsto
         \cut{x}{}{\tocp{x}z}
           {\cut{y}{}
              {\tocp{\sigma}(y(x).\tocp{M}y)}
              {\cut{w}{}{y\sd{x}.\link y w}{w[]}}}]z \\

\Longrightarrow (\text{cut send against receive}) \\
%% \quad \tocp{\Fx}[x \mapsto
%%          \cut{v}{}{\tocp{v}x}
%%            {\cut{y}{}
%%               {\tocp{\sigma}(\tocp{M}y)}
%%               {\cut{w}{}{\link y w}{w[]}}}]z \\
%% = \\
\quad \tocp{\Fx}[z \mapsto
         \cut{x}{}{\tocp{x}z}
           {\cut{y}{}
             {\tocp{\sigma}(\tocp{M}y)}
             {y[]}}]z \\

%% = \\
%% \quad \tocp{\Fx}[z \mapsto
%%          \tocp{\sigma}
%%             (\cut{x}{}
%%                {\cut{y}{}
%%                  {\tocp{M}{y}}{y[]}}
%%                  {\tocp{x}z})]z \\
%% \equiv \\
%% \quad \tocp{\Fx}[
%%         z \mapsto
%%           \cut{x}{}
%%             {\tocp{x}z}
%%             {\tocp{\cut{y}{}{\tocp{\sigma}(\tocp{M}y)}{y[]}}} \\
\equiv \\
\quad \cut{x}{}
        {\tocp{\Fx}[\tocp{x}]z}
        {\tocp{\sigma}(\tocp{\cut{y}{}{\tocp{M}y}{y[]}})} \\
%% = \\
%% \quad \cut{x}{}
%%         {\tocp{\Fx}[\tocp{x}]z}
%%         {\tocp{\sigma}(\tocp{\wcirc}[\tocp{M}]z)} \\
= \\
\quad \tocp{(\nu x)(\Fx[x] \parallel M\sigma)}z \\
\el
\]

Case $(\nu x) (\Fx[\gvconst{link} \app (x, y)] \parallel \Fx'[M]) \ceval
        (\nu x)(\Fx[x] \parallel \Fx'[\gvletunit{\gvconst{wait} \app x}{M\{y/x\}}])$.
\dots
%% \[
%% \bl
%% \quad \tocp{(\nu x) (\Fx[\gvconst{link} \app (x, y)] \parallel \Fx'[M])}z \\
%% = \\
%% \quad \cut{x}{}
%%          {\tocp{\Fx}[\tocp{\gvconst{link} \app (x, y)}]z}
%%          {\tocp{\Fx'}[\tocp{M}]z} \\
%% = \\
%% \quad \tocp{(\nu x)(\Fx[x] \parallel \Fx'[\gvletunit{\gvconst{wait} \app x}{M\{y/x\}}])}z
%% \el
%% \]

\end{itemize}
\end{proof}




\paragraph{Why we need closures}

One might hope that reduction in GV without closures would be preserved by the translation to
CP. However, it turns out that this is not the case. Consider the following straightforward
$\beta$-reduction:
\[
  \tocp{(\lambda x.\lambda y.\gvwait{y}; x) \app ()}z \teval \lambda y.\gvwait{y}; ()
\]
Translating the left-hand side yields:
\[
\bl
\quad \tocp{(\lambda x.\lambda y.\gvwait{y}; x) \app ()}z \\
= \\
\quad \cut{w}{}{w(x).\tocp{\lambda y.\gvwait{y; x}w}}{\cut{x}{}{\tocp{()}x}{y[x].\link{y}{z}}} \\
\equiv \\
\quad \cut{w}{}{w(x).w(y).y().\link{x}{w}}{\cut{x}{}{x[]}{w[x].\link{w}{z}}} \\
\equiv \\
\quad \cut{x}{}{x[]}{\cut{w}{}{w(x).w(y).y().\link{x}{w}}{w[x].\link{w}{z}}} \\
\rto \\
\quad \cut{x}{}{x[]}{\cut{w}{}{w(y).y().\link{x}{w}}{\link{w}{z}}} \\
\rto \\
\quad \cut{x}{}{x[]}{z(y).y().\link{x}{z}} \\
\rto^* (\text{commuting conversions}) \\
\quad z(y).y().\cut{x}{}{x[]}{\link{x}{z}} = P \\
\el
\]
Translating the right-hand side yields:
\[
\bl
\quad \tocp{\lambda y.\gvwait{y}; ()} \\
= \\
\quad z(y).y().z[] = Q
\el
\]

Alas, $P$ does not reduce to $Q$.
%
Notice that we could reduce $P$ to $Q$ if we were allowed to reduce under a prefix.

As we have shown previously, we can translate a term $P$ from CP to GV and back, perform some
reductions, and arrive back at $P$.
\begin{theorem}
$\cut{z}{}{\togv{\tocp{P}}z}{z[]} \rto^* P$
\end{theorem}

%% \paragraph{Some results that hold, but may be of no use}

%% \begin{theorem}
%% If $\Gamma \vdash C \equiv D$, then $\tocp{C}z \equiv \tocp{D}v$.
%% \end{theorem}
%% %
%% The following lemmas can be made to hold, by construction.
%% %
%% \begin{lemma}
%% $\tocp{\Ex[M]}z = \tocp{\Ex}[\tocp{M}]z$
%% \end{lemma}

%% \begin{lemma}
%% $\tocp{\Fx[M]}z = \tocp{\Fx}[\tocp{M}]z$
%% \end{lemma}

%% \begin{lemma}
%% $\tocp{\Cx[C]}z = \tocp{\Cx}[\tocp{C}]z$
%% \end{lemma}

%% \paragraph{A whole load of results that do not hold}

%% \begin{lemma}
%% $\cut{x}{}{\tocp{M}z}{\tocp{V}x} \rto^* \tocp{M[V/x]}z$
%% \end{lemma}

%% \begin{theorem}
%% If $\Gamma \vdash M$, $\Gamma \vdash N$, and $M \teval N$, then $\tocp{M}z
%% \rto^* \tocp{N}v$.
%% \end{theorem}

%% \begin{theorem}
%% If $\Gamma \vdash C$, $\Gamma' \vdash D$, $\Gamma \rto \Gamma'$, and $C \ceval D$, then $\tocp{C}z
%% \rto^* \tocp{D}v$.
%% \end{theorem}



%% OK. Bugger this. The substitution lemma is false.

%%     nu x.([[\y.wait y; x]]z | [[()]]x)
%%   =
%%     nu x.(z(y).y().x <-> z | x[])

%% But

%%   [[\y.wait; ()]]z = z(y).y().z[]

%% Similarly, the main theorem is false.

%%     [[(\x.\y.wait y; x)()]]z
%%   -->*
%%     nu x(z(y).y().x <-> z | x[])

%% But

%%   [[\y.wait y; ()]]z = z(y).y.z[]

%% \subsection{Indirect Translation from GV to CP}
%%
%%
%% \todo{ANF translation.}
%%
%% \todo{Ensure that the definition of $\equiv$ is appropriate for the theorems.}
%%
%% \todo{Show that the A-normalisation rules are sound (easy).}
%%
%% Attempt at the ANF syntax.  Should we pick a new letter for ANF terms? [SL: No.]
%%
%% [SL: I fixed some bugs in the ANF syntax]
%%
%% \begin{syntax}
%%   \text{Terms} & M,N & ::= & V \mid \gvlet{x}{V \app W}{N} \\
%%   & & \mid & \gvlet{(x,y)}{V \app W}{N} \mid \gvletunit{V \app W}{N} \\
%%   & & \mid & \gvcase{V}{\mkwd{inl}\,x \mapsto N; \mkwd{inr}\,x \mapsto N} \\
%%   & & \mid & \gvconst{absurd} \app V \\
%% \end{syntax}
%%
%% \small\[
%% \ba{@{}c@{\qquad}c@{\qquad}c@{\qquad}c}
%% \begin{eqs}
%% \tocp{T + U} &=& \tocp{T} \with \tocp{U} \\
%% \tocp{T \times U} &=& \tocp{T} \parr \tocp{U} \\
%% \tocp{T \lto U} &=& \cpdual{\tocp{T}} \otimes \tocp U
%% \end{eqs}
%% &
%% \begin{eqs}
%% \tocp{\zero} &=& \top \\
%% \tocp{\one} &=& \bot
%% \end{eqs}
%% &
%% \begin{eqs}
%% \tocp{\gvout{T}{S}}        &=& \cpdual{\tocp{T}} \otimes \tocp{S} \\
%% \tocp{\gvin{T}{S}}         &=& \tocp{T} \parr \tocp{S} \\
%% \end{eqs}
%% &
%% \begin{eqs}
%% \tocp{\outterm}            &=& 1 \\
%% \tocp{\interm}             &=& \bot \\
%% \end{eqs}
%% %&
%% %\begin{eqs}
%% %\tocp{\oplus \{l_i:S_i \}_i} &=& \oplus \{l_i:\tocp{S_i}\}_i \\
%% %\tocp{\with \{l_i:S_i \}_i}  &=& \with \{l_i:\tocp{S_i}\}_i \\
%% %\tocp{\gvservice{S}}       &=& \cpquery{\tocp{S}} \\
%% %\tocp{\gvserver{S}}        &=& \cpbang{\tocp{S}} \\
%% %\end{eqs}
%% \ea
%% \]\normalsize
%%
%% \small\begin{equations}
%% \tocp{x}z &=& \link{x}{z} \\
%% \tocp{\lambda x.N}z &=& z(x).\tocp{N}z \\
%% \tocp{\gvlet{y}{V \app W}{N}}z &=&
%%   \bl
%%     \cut y {} {\cut x {} {\tocp{V}x} {x[z].(\tocp{W}z \mid \link x y)}} {\tocp{N}z} \\
%%     \text{if $V$ is not a constant $K$}
%%   \el \\
%% \tocp{(V,W)}z &=& z[y].(\tocp{V}y \mid \tocp{W}z) \\
%% \tocp{\gvlet{(x,y)}{V}{N}}z &=& \cut y {} {\tocp{V}y} {y(x).\tocp{N}z} \\
%% \tocp{\mkwd {inl} \app V}z &=& z[\mkwd{inl}].\tocp{V}z\\
%% \tocp{\gvcase V {\mkwd {inl} \app x \mapsto M; \mkwd {inr} \app x \mapsto N}}z &=&
%%    \cut x {} {\tocp{V}x} {\mkwd{case} \app x \app \{ \mkwd{inl} \mapsto \tocp{M}z; \mkwd{inr} \mapsto \tocp{N}z \}} \\
%% \tocp{\mkwd{absurd} \app V}z &=& \cut x {} {\tocp{V}x} {\mkwd{case}\app x \app \{ \}} \\
%% \tocp{\gvlet{x}{\gvsend{(V,W)}}{N}}z &=& \cut{x}{}{\tocp{W}x}{\cut y {} {\tocp{V}y} {x[y].\tocp{N}z}} \\
%% \tocp{\gvlet{(x,y)}{\gvreceive{V}}{N}}z &=& \cut{y}{}{\tocp{V}y}{y(x).\tocp{N}z} \\
%% \tocp{\gvlet{()}{\gvconst{wait} \app V}{N}}z &=& \cut y {} {\tocp{V}y} {y().\tocp{N}z} \\
%% \tocp{\gvlet{x}{\gvfork{x}{M}}{N}}z &=& \cut{x}{}{\cut{y}{}{\tocp{M}y}{y[].0}}{\tocp{N}z} \\
%% \tocp{\gvlet{x}{\gvlink{V}{W}}{N}}z &=& \cut x {} {x().\cut y {} {\tocp{V}y} {\tocp{W}y}} {\tocp{N}z} \\
%% \end{equations}\normalsize
%%
%% \begin{theorem}
%%   If $\Gamma \vdash M: T$, then $\tocp{M}z \vdash \tocp{\Gamma}, z:\tocp{T}^\perp$.
%% \end{theorem}
%%
%% \begin{proof}
%%   By structural induction on the derivation of $\Gamma \vdash M: T$.  Representative cases follow.
%%   \begin{itemize}
%%   \item In case $M = x$, we must have $\Gamma = \{x:T\}$; we can directly conclude that $\link x z
%%     \vdash x:T,z:\cpdual T$.
%%   \item In case $M = \lambda x.N$, where $T = U \lto U'$, the induction hypothesis provides that
%%     $\tocp{N}z \vdash \tocp{\Gamma},x:\tocp{U},z:\cpdual{\tocp{U'}}$.  Therefore, from the rule for
%%     $\parr$ and the observation that $\cpdual{\tocp{U \lto U'}} = \tocp U \parr \cpdual{\tocp {U'}}$, we can
%%     conclude that $z(x).\tocp{N}z \vdash \tocp{\Gamma}, z:\cpdual{\tocp{U \lto U'}}$.
%%   \item In case $M = \mkwd{inl} \app V$, where $T = U + U'$, the induction hypothesis provides that
%%     $\tocp{V}z \vdash \tocp{\Gamma}, z:\cpdual{\tocp{U}}$.  Therefore, from the rule for $\oplus$
%%     and the observation that $\cpdual{\tocp{U + U'}} = \cpdual{\tocp{U}} \oplus \cpdual{\tocp{U'}}$,
%%     we have that $z[\mkwd{inl}].\tocp{M}z \vdash \tocp{\Gamma}, z:\cpdual{\tocp{U + U'}}$.
%%   \end{itemize}
%% \end{proof}
%%
%% \small\begin{equations}
%% \tocp{M}z &=& \tocp{M}z \\
%% \tocp{\distinguish M}z &=& \tocp{M}z \\
%% \tocp{(\nu x)C}z &=& \tocp{C}z \\
%% \tocpbig{
%%   \inferrule
%%     {\Gamma,x:S \vdash^{\phi} C \\
%%      \Gamma',x:\gvdual{S} \vdash^{\phi'} C'}
%%     {\Gamma,\Gamma',x:\channel{S} \vdash^{\phi + \phi'} C \parallel C'}}z &=&
%%   \left\{
%%     \ba{l}
%%     \cut x {} {\tocp{C}x} {\cut y {} {\tocp{C'}y} {x().\link y z}} \\
%%     \qquad\text{if $\phi' = \bcirc$;} \\
%%     \cut x {} {\tocp{C}x} {\cut y {} {\tocp{C'}y} {y().\link x z}} \\
%%     \qquad\text{otherwise.}
%%     \ea \right.
%% \end{equations}\normalsize
%%
%% \begin{theorem}
%%   If $\Gamma \vdash P$, then there is some $T$ such that $\tocp{P}z \vdash \tocp{\Gamma}, z:\cpdual{\tocp{T}}$.
%% \end{theorem}
%%
%% \begin{theorem}
%%   If $M, N$ are GV-ANF terms and $M \equiv N$, then $\tocp{M}z \equiv \tocp{N}z$.
%% \end{theorem}
%%
%% \begin{theorem}
%%   If $M$ is a GV-ANF term and $M \rto N$, then $\tocp{M}z \rto^+ \tocp{N}z$.
%% \end{theorem}
%%
\section{Extending GV}\label{sec:extend}

In this section, we consider two extensions of our core calculus.  The first unifies the session
types $\interm$ and $\outterm$ to have a single, self-dual session type $\gvend$; this more closely
mirrors other developments of session types, but results in a system that no longer corresponds to
Wadler's CP calculus.  The second introduces unlimited types in the term calculus; we show how they
can be lifted to provide replicated sessions, analogously to lifting term-level sums to provide
session-level choice, and that the resulting system is equivalent to the replicated channels in CP.
In both cases, we are able to directly apply our characterizations of deadlock and deadlock freedom
to show that the extended systems are deadlock free.

\subsection{Unifying $\interm$ and $\outterm$}\label{sec:gv-end}

\begin{figure}
Syntax:
\begin{syntax}
  \text{Session types} & S & ::= & \gvout{T}{S} \mid \gvin{T}{S} \mid \gvend \mid \channel{S} \\
  \text{Constants} & K & ::= & \gvconst{send} \mid \gvconst{receive} \mid \gvconst{fork} \mid
    \gvconst{close} \mid \gvconst{link}\\
\end{syntax}
Duality:
\[
  \gvdual \gvend = \gvend
\]
Type schemas for constants:
\begin{mathpar}
\gvconst{fork} : (S \lto \one) \lto \gvdual S

\gvconst{close} : \gvend \lto \one

\gvconst{link} : S \times \gvdual S \lto \one
\end{mathpar}
\caption{Syntax and typing rules for combined closed channels.}\label{fig:gv-end-syntax}
\end{figure}

We begin by defining a language, based on GV, but combining the types $\interm$ and $\outterm$ of
closed sessions.  \figref{gv-end-syntax} gives the alterations to the syntax and typing rules.  The
session types are updated to have a single, self-dual type $\gvend$; a new constant,
$\gvconst{close}$ is provided to eliminate sessions of type $\gvend$.  (In many existing systems,
sessions of type $\gvend$ are treated as unlimited, subject to weakening, rather than providing an
explicit \gvconst{close}.  We have left \gvconst{close} explicit to simplify the presentation.)  The
type schemas for \gvconst{fork} and \gvconst{link} have been simplified, as we no longer need to
build the elimination of closed sessions into \gvconst{fork}.  \figref{gv-end-conf-eval} gives the
update evaluation rules for the extended language.  In addition to a new rule for \gvconst{close}
(replacing the rule for \gvconst{wait}), the rule for \gvconst{link} can be simplified significantly
(as it can now return a unit value instead of a closed channel).

\begin{figure}
Extended configuration equivalence:
\begin{mathpar}
C \parallel \wcirc () \equiv C
\end{mathpar}
Extended reduction rules (all other reduction rules apply as in GV)
\begin{mathpar}
\inferrule
  [Close]
  { }
  {(\nu x)(F[\gvconst{close} \app x] \parallel F'[\gvconst{close} \app x]) \ceval F[()] \parallel F'[()]}

\inferrule
[Link]
  {x \in \fv(P)}
  {F[\gvconst{link} \app (x,y)] \parallel C \ceval F[()] \parallel C\{y/x\}}
\end{mathpar}
\caption{Updated configuration evaluation rules}\label{fig:gv-end-conf-eval}
\end{figure}

Our extended language is, perhaps surprisingly, strictly more expressive than GV.  To see this, we
can consider the following term (assuming sessions $x$ and $y$ are in scope):
%
\[\bl
  \mkwd{let}\:{w} = \gvconst{fork} \app (\lambda w.\:
    \bl \gvletunit{\gvconst{close}\app w}{} \\
        \gvlet{(z,x)}{\gvreceive{x}}{M}) \:\mkwd{in}\el \\
  \gvletunit{\gvconst{close}\app w}{} \\
  \gvlet{(z,y)}{\gvreceive{y}}{N}
\el\]
%
Initially, the forked thread and its parent share (only) session $w$.  After both threads close
session $w$, however, there can be no further synchronization between the threads; in contrast, in
GV, there is always a final synchronization with \gvconst{wait}.  To capture the increase in
expressivity, we must extend the existing configuration typing rules (\figref{gv-conf-typing}) with
a rule for composition in which no threads are shared (such as after the reduction of
$\gvconst{close}\app w$ in the example):
\[
\inferrule
  {\Gamma \vdash^\phi C \\
   \Gamma' \vdash^{\phi'} C'}
  {\Gamma,\Gamma' \vdash^{\phi + \phi'} C \parallel C'}
\]

We have a slightly different result about channels shared between processes, to account for the
multiple possible typings of composition:
\begin{lemma}
  If $\Gamma \vdash C$ and $C = \Cx[D \parallel D']$, then $\fv(D) \cap \fv(D')$ is either empty or
  the singleton set $\{x\}$ for some variable $x$.
\end{lemma}
The proof is again by induction on the derivation of $\Gamma \vdash C$.  However, note that this has
no consequence for the proof of deadlock freedom (which depended on their being two channels shared
among processes).  Thus we can conclude that
\begin{theorem}
  If $\Gamma \vdash M: T$ then $\distinguish M$ is deadlock free.
\end{theorem}

\subsection{Adding Unlimited Types}\label{sec:gv-repl}

So far, we have limited GV to containing only linear types.  In this section, we consider one
standard approach to extending the term language to include unlimited types (i.e., types subject to
contraction and weakening).  It is unsurprising that this does not introduce deadlock, as it is
purely at the term level.  However, we will then show we can encode replicated processes using
term-level contraction and weakening, similarly to the encoding of session-level choice using sums.
Finally, we will show that our encoding is equivalent to the replicated processes in CP.

\begin{figure}
Syntactic extensions:
\begin{syntax}
  \text{Types} & T & ::= & \gvforever T \mid \dots \\
  \text{Terms} & M,N & ::= & \gvlet{{!x}}{M}{N} \mid {!M} \mid \dots \\
  \text{Values} & V & ::= & {!V} \mid \dots \\
  \text{Evaluation contexts} & E & ::= & \gvlet{{!x}}{E}{M} \mid {!E} \mid \dots
\end{syntax}
Typing rules:
\begin{mathpar}
\inferrule
  {\Gamma \vdash M: T \\
   \gvforever\Gamma}
  {\Gamma \vdash {!M}: \gvforever T}

\inferrule
  {\Gamma \vdash M: \gvforever T \\
   \Gamma', x:T \vdash N: U}
  {\Gamma \vdash \gvlet{{!x}}{M}{N}: U}
\\
\inferrule
  {\Gamma \vdash M: T}
  {\Gamma, x: \gvforever U \vdash M: T}

\inferrule
  {\Gamma,x:\gvforever T,x':\gvforever T \vdash M: U}
  {\Gamma,x:\gvforever T \vdash M \{ x/x' \}: T}
\end{mathpar}
Reduction:
\begin{mathpar}
\gvlet{{!x}}{{!V}}{M} \teval M \{ \bind x V \}
\end{mathpar}
\caption{GV extensions for unlimited types}
\label{fig:gv-repl}
\end{figure}

\figref{gv-repl} gives the extension of GV.  We begin by adding a new class of types, $\gvforever
T$, representing unlimited types.  (The typical notation for such types in linear logic, ${!T}$,
clashes with the notation for output in session types.)  As usual, we will write $T \to U$ to
abbreviate $\gvforever{(T \lto U)}$.  We add terms to construct and deconstruct values of type
$\gvforever T$; we write $\gvforever \Gamma$ to denote that every type in $\Gamma$ must be of the
form $\gvforever U$ for some type $U$.  Finally, we allow values of type $\gvforever T$ to be
weakened (discarded) and contracted (duplicated).  The reduction rule for $\gvforever T$ values is
unsurprising---however, unlike in the other reductions, $x$ may appear multiple times in $M$.  The
extension of the deadlock freedom results to this calculus are immediate.

Wadler's CP calculus provides unlimited service channels, which can be used to obtain arbitrarily
many copies of some concurrent behavior.  We can encode such channels as follows.  First, we
introduce new, dual session type constructors $Service(S)$ and $Server(S)$, defined by
\begin{align*}
  Server(S) &\defeq \gvout{(\gvdual S \to \outterm)}{\outterm} \\
  Service(S) &\defeq \gvin{(S \to \outterm)}{\outterm}
\end{align*}
Note that $\gvdual{Server(S)} = Service(\gvdual S)$.  (We do not, however, extend our type system to
treat $Service(S)$ channels themselves as unlimited.)  Note the parallel between the encoding of
session-level sums using value-level sums and the encoding of session-level replication using
value-level replication---in each case, the key is ``trivial'' channels $\gvout{T}{\outterm}$ for
suitable $T$.  We then introduce new constants \gvconst{replicate} and \gvconst{request}, with the
types
\begin{mathpar}
\gvconst{replicate} : (\gvdual S \to \outterm) \lto Server(S)

\gvconst{request} : Service(S) \lto S
\end{mathpar}
defined as follows
\begin{align*}
 \\
  \gvconst{replicate} \app f &\defeq \gvconst{fork} \app (\lambda x. \gvsend{(f,x)}) \\
  \gvconst{request} \app s &\defeq
    \bl \gvlet{(f,s)}{\gvreceive{s}}{\\\gvletunit{\gvconst{wait}\app s}{\\\gvlet{{!g}}{f}{g}}} \el
\end{align*}
Finally, we can give translations from GV into CP.
\begin{equations}
  \tocp{{!M}}z &\defeq& \cut{x} {} {\replicate z y.\link y x}{\tocp{M}x} \\
  \tocp{\gvlet{{!x}}{V}{M}}z &\defeq& \cut y {} {\tocp{V}y} {\derelict{y}{x}.\tocp{M}z}
\end{equations}
And similarly translation from CP into GV.  The translation from CP into GV emphasizes that, while
weakening and contraction are implicit in CP syntax, they play a central role in the CP semantics of
exponentials, and thus have non-trivial translation to GV.
\begin{equations}
\togv{\replicate{s}{x}.P} &\defeq& \gvconst{replicate} \app (\lambda x. \togv{P}) \\
  \togv{\derelict{s}{x}.P} &\defeq& \gvlet{x}{\gvconst{request} \app s}{\togv{P}} \\
  \togvbig{
    \inferrule
      {P \vdash \Gamma}
      {P \vdash \Gamma, x:\cpquery{A}}} &\defeq&
    \ba[c]{l} \gvlet{(y,s)}{\gvreceive{s}}{\\\gvletunit{\gvconst{wait}\app s}{\togv{P}}} \ea \\
  \togvbig{
    \inferrule
      {P \vdash \Gamma,x:\cpquery{A},y:\cpquery{A}}
      {P[x/y] \vdash \Gamma,x:\cpquery{A}}} &\defeq&
    \ba{l} \gvlet{f}{\gvconst{request}\app x}{\\\gvlet{x}{\gvconst{replicate}\app f}{\\\gvlet{y}{\gvconst{replicate}\app f}{\togv{P}}}} \ea
\end{equations}
Finally, the extensions of Theorems~\ref{thm:cp-reduction-simulated}
and~\ref{thm:gv-reduction-simulated} to unlimited channels is direct.


\section{Related Work}\label{sec:related}

Something about connection to Carbone et al.  Their progress property requires that every
communication will eventually take place.  This is hopefully an easy consequence of ours.

\subsubsection{Linear logic and session types.}

\subsubsection{Progress and deadlock freedom.}


\section{Conclusions and Future Work}\label{sec:conclusion}

Asynchrony and recursion.

\end{document}
