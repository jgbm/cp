% -*- fill-column: 100 -*-

\documentclass[orivec,envcountsame]{llncs}

\usepackage{amsmath,amssymb,centernot,hyperref,mathwidth,stmaryrd,url,xspace}
\usepackage[table]{xcolor}
\usepackage{colortbl}
\addtolength{\jot}{-3px}

\usepackage{mathpartir}
\mprset{sep=1em}

\usepackage{float}
\floatstyle{boxed}
\restylefloat{figure}

\input{preamble.tex}

\title{Joke or Something}
\author{J. Garrett Morris \and Sam Lindley \and Philip Wadler}
\institute{The University of Edinburgh \\
           \email{\{Garrett.Morris,Sam.Lindley,Philip.Wadler\}@ed.ac.uk} \vspace{-5mm}}

\begin{document}

\maketitle

\begin{abstract}

\end{abstract}

\section{Introduction}\label{sec:intro}

\section{GV by Example}\label{sec:examples}

\begin{itemize}
\item Bookstore example (with delegation).  On second thought, I'm not sure the example as presented
  in the exceptions paper is quite the one I wanted---there's no reason for the bank and customer to
  interact.  On the other hand, perhaps that doesn't matter---or we could modify it slightly so that
  the bank either challenges the customer as part of the transaction (Verified By Visa).
\item Explain encoding of select and choice into send and receive with sums.
\end{itemize}

\section{I'm Pickin' Up Good Vibrations}

I'm intentionally ignoring replication for the time being.  I'm intentionally ignoring CP
polymorphism forever.

\subsection{Syntax}
\newcommand{\one}{\mathbf{1}}
\newcommand{\zero}{\mathbf{0}}
\begin{syntax}
  \text{Session types} & S & ::= & \gvout{T}{S} \mid \gvin{T}{S} \mid % \oplus \{ \overline{l:S} \} \mid \with \{ \overline{l:S} \} \mid
                                   \interm \mid \outterm \mid \channel{S} \\
  \text{Types} & T,U & ::= & S \mid T \times U \mid \one \mid T + U \mid \zero \mid T \lto U \\ % \mid {!T} \\
  \text{Terms} & M,N & ::= & x \mid K \mid \lambda x.M \mid M\,N \\
  & & \mid & (M,N) \mid \gvlet{(x,y)}{M}{N} \\
  & & \mid & \mkwd{inl}\,M \mid \mkwd{inr}\,M \mid \gvcase{M}{\mkwd{inl}\,x \mapsto N; \mkwd{inr}\,x \mapsto N} \\
  & & \mid & () \mid \gvletunit{M}{N} \mid \gvconst{absurd} \app M \\
  \text{Constants} & K & ::= & \gvconst{send} \mid \gvconst{receive} \mid \gvconst{fork} \mid \gvconst{wait} \mid \gvconst{link}\\
\end{syntax}

\begin{mathpar}
\gvdual{\gvout{T}{S}} = \gvin{T}{\gvdual S}

\gvdual{\gvin{T}{S}} = \gvout{T}{\gvdual S}

\gvdual{\interm} = \outterm

\gvdual{\outterm} = \interm
\end{mathpar}

\subsection{Typing}

\begin{mathpar}
\inferrule
  {T \not= \channel{S}}
  {\{x:T\} \vdash x:T}

\inferrule
  {\Gamma,x:T \vdash M:U}
  {\Gamma \vdash \lambda x.M : T \lto U}

\inferrule
  {\Gamma \vdash M: T \lto U \\
   \Delta \vdash N: T}
  {\Gamma,\Delta \vdash M\,N: U}

\inferrule
  {\Gamma \vdash M: T \\
   \Delta \vdash N: U}
  {\Gamma,\Delta \vdash (M,N): T \times U}

\inferrule
  {\Gamma \vdash M: T \times T' \\
   \Delta,x:T,y:T' \vdash N: U}
  {\Gamma,\Delta \vdash \gvlet{(x,y)}{M}{N} : U}

\inferrule
  {\Gamma \vdash M: T}
  {\Gamma \vdash \mkwd{inl}\,M: T+U}

\inferrule
  {\Gamma \vdash M: T+T' \\
   \Delta,x:T \vdash N: U \\
   \Delta,x:T' \vdash N': U}
  {\Gamma,\Delta \vdash \gvcase{M}{\mkwd{inl}\,x \mapsto N; \mkwd{inr}\,x \mapsto N'} : U}

\inferrule
  { }
  {\vdash (): \one}

\inferrule
  {\Gamma \vdash M: \one \\
   \Delta \vdash N: T}
  {\Gamma,\Delta \vdash \gvletunit{M}{N}: T}

\inferrule
  {\Gamma \vdash M: \zero}
  {\Gamma, \Gamma' \vdash \gvconst{absurd} \app M : T}

\gvconst{send} : T \times \gvout{T}{S} \lto S

\gvconst{receive} : \gvin{T}{S} \lto T \times S

\gvconst{fork} : (S \lto \outterm) \lto \gvdual{S}

\gvconst{wait} : \interm \lto \one

\gvconst{link} : S \times \gvdual{S} \lto \outterm
\end{mathpar}

\subsection{Evaluation}

\newcommand{\distinguish}[1]{\langle #1 \rangle}

\newcommand{\wcirc}{{\mathord{\circ}}}
\newcommand{\bcirc}{{\mathord{\bullet}}}

\begin{syntax}
  \text{Values} & V & ::= & x \mid K \mid \lambda x.M \\ % \mid K\,V \\
  & & \mid & () \mid (V,V') \mid \mkwd{inl}\,V \mid \mkwd{inr}\,V  \\
  \text{Expression contexts} & E & ::= &  [] \mid E\,M \mid V\,E \mid \gvletunit{E}{M} \\
  & & \mid & (E,M) \mid (V,E) \mid \gvlet{(x,y)}{E}{M} \\
  & & \mid & \mkwd{inl}\,E \mid \mkwd{inr}\,E \mid \gvcase{E}{\mkwd{inl}\,x \mapsto N; \mkwd{inr}\,x \mapsto N'} \\
  \text{Configurations} & P & ::= & M \mid \distinguish M \mid P \parallel P' \mid (\nu x) P \\
  \text{Configuration contexts} & C & ::= & E \mid \distinguish E \mid C \parallel P \mid (\nu x)C \\
  \text{Flags} & \phi & ::= & \wcirc \mid \bcirc
\end{syntax}
We define combination of flags $\phi + \phi'$ by
\begin{mathpar}
  \wcirc + \wcirc = \wcirc

  \wcirc + \bcirc = \bcirc

  \bcirc + \wcirc = \bcirc
\end{mathpar}
and leave $\bcirc + \bcirc$ undefined.  Configuration typing is given by
\begin{mathpar}
\inferrule
  {\Gamma \vdash M: T}
  {\Gamma \vdash^\bcirc \distinguish M}

\inferrule
  {\Gamma \vdash M: \outterm}
  {\Gamma \vdash^\wcirc M}

\inferrule
  {\Gamma, x:\channel{S} \vdash^\phi P}
  {\Gamma \vdash^\phi (\nu x) P}

\inferrule
  {\Gamma,x:S \vdash^{\phi} P \\
   \Gamma',x:\gvdual{S} \vdash^{\phi'} P'}
  {\Gamma,\Gamma',x:\channel{S} \vdash^{\phi + \phi'} P \parallel P'}
\end{mathpar}
We will write $\Gamma \vdash P$ for $\Gamma \vdash^\bcirc P$.  Note that while we can write the
classic deadlocked configuration
\[
  (\nu x)(\nu y)(\distinguish{\gvlet{(z,x)}{\gvconst{receive} \app x}{\gvconst{send} \app (z,y)}} \parallel
                 \gvlet{(z,y)}{\gvconst{receive} \app y}{\gvconst {send} \app (z,x)})
\]
it is not well typed: we can only split one of $x,y$ at the $\parallel$.  Term reductions:
\begin{align*}
  (\lambda x.M)\,V &\teval M\{V/x\} \\
  \gvletunit{()}{M} &\teval M \\
  \gvlet{(x,y)}{(V,V')}{M} &\teval M\{V/x,V'/y\} \\
  \gvcase{(\mkwd{inl}\,V)}{\mkwd{inl}\,x \mapsto N; \mkwd{inr}\,x \mapsto N'} &\teval N\{V/x\} \\
  E[M] &\teval E[M'] \qquad \text{if $M \teval M'$}
\end{align*}
Configuration (context) equivalence:
\begin{mathpar}
C[\mathsf{link}\,(x,y)] \equiv C[\mathsf{link}\,(y,x)]

C_0 \parallel C_1 \equiv C_1 \parallel C_0

C_0 \parallel (C_1 \parallel C_2) \equiv (C_0 \parallel C_1) \parallel C_2

C_0 \parallel (\nu x)C_1 \equiv (\nu x)(C_0 \parallel C_1) \text{ if $x \not\in \fv(C_0)$}
\end{mathpar}

Awkwardly enough, the equivalence rules do not preserve typing.  For example, supposing that $x \in
\fv(P), y \in \fv(Q), \text{ and } x,y \in \fv(R)$, we have $\vdash (\nu x
y)(P \mid (Q \mid R))$ but not $\nvdash (\nu x y)((P \mid Q) \mid R)$.  We have a simple reduction
rule for configuration types, given by
\begin{mathpar}
\inferrule
%  [T-Output]
  { }
  {\channel{(\gvout T S)} \ceval \channel S}

\inferrule
%  [T-Input]
  { }
  {\channel{(\gvin T S)} \ceval \channel S}

\inferrule
%  [T-Context]
  {T \ceval T'}
  {\Gamma,x:T \ceval \Gamma,x:T'}
\end{mathpar}
Configuration reduction is given by
\begin{mathpar}
\inferrule
  [Send]
  { }
  {C[\gvconst{send} \app (V,x)] \parallel C'[\gvconst{receive} \app x] \ceval C[x] \parallel C'[(V,x)]}

\inferrule
  [Fork]
  {\text{$x$ fresh}}
  {C[\gvconst{fork} \app V] \ceval (\nu x)(C[x] \parallel (V\,x))}

\inferrule
  [Wait]
  { }
  {(\nu x)(C[\gvconst{wait} \app x] \parallel x) \ceval C[()]}

\inferrule
   [Link]
   {x \in \fv(M)}
   {(\nu x) (C[\gvconst{link} \app (x, y)] \parallel C'[M]) \ceval (\nu x)(C[x] \parallel C'[\gvletunit{\gvconst{wait} \app x}{M\{y/x\}}])}

\inferrule
   [Lift]
   {P \ceval P'}
   {C[P] \ceval C[P']}

\inferrule
   [Lift2]
   {M \teval M'}
   {C[M] \ceval C[M']}
%%
%% \inferrule
%%    [DLink]
%%    {x \in \fv(M)}
%%    {(\nu x) (C[\mathsf{link}\,(x, y)] \parallel \distinguish M) \ceval (\nu x)(C[x] \parallel \distinguish{\gvletunit{\mathsf{wait}\,x}{M\{y/x\}}})}
%%
%%
%% \inferrule
%%   {C_0 \equiv C_0' \\
%%    C_0' \ceval C_1' \\
%%    C_1' \equiv C_1}
%%   {C_0 \ceval C_1}
\end{mathpar}
Some things that might be useful.
\begin{lemma}\label{thm:term-preservation}
  If $\Gamma \vdash M: T$ and $M \teval M'$, then $\Gamma \vdash M': T$
\end{lemma}

\noindent
The proof is standard.

\begin{theorem}\label{thm:preservation}
  If $\Gamma \vdash P$ and $P \ceval P'$ then there is some $\Gamma'$ such that either $\Gamma
  \ceval \Gamma'$ or $\Gamma = \Gamma'$ and $\Gamma' \vdash P'$.
\end{theorem}

\begin{proof}
  By induction on the derivation of $P \ceval P'$.
  \begin{itemize}
  \item Case \textsc{Lift} is immediate by the induction hypothesis.
  \item Case \textsc{Lift2} follows from \lemref{term-preservation}, with $\Gamma = \Gamma'$.
  \item In case \textsc{Send}, from the assumption $\Gamma \vdash C[\mkwd{send}\,(V,x)] \parallel
    C'[\gvconst{receive} \app x]$, we can assume that $\Gamma$ partitions as
    $\Gamma_1,\Gamma_2,x:\channel{S}$ such that $S = \gvout{T}{S'}$, $V$ has type $T$, and
    $\Gamma_1,x:\gvout{T}{S'} \vdash C[\gvconst{send} \app (V,x)]$,
    $\Gamma_2,x:\gvin{T}{\gvdual{S'}} \vdash C'[\gvconst{receive} \app x]$.  As $\gvconst{send} : T
    \times \gvout{T}{S'} \lto S'$ and $\Gamma_1,x:\gvout{T}{S'} \vdash C[\gvconst{send} \app
    (V,x)]$, we can conclude that $\Gamma_1,x:S' \vdash C[x]$.  By a similar argument, we conclude
    that $\Gamma_2,x:\gvdual{S'} \vdash C'[(V,x)]$. Finally, as $\channel{(\gvout{T}{S})} \ceval
    \channel{S}$, $\Gamma_1,\Gamma_2,x:\channel{(\gvout T S)} \ceval
    \Gamma_1,\Gamma_2,x:\channel{S}$, and we can recompose the resulting processes concluding that
    $\Gamma_1,\Gamma_2,x:\channel{S} \vdash C[x] \parallel C'[(V,x)]$.
  \item In case \textsc{Fork}, from the assumption $\Gamma \vdash C[\gvconst{fork} \app V]$, we can
    conlude that $\Gamma$ splits into $\Gamma_1,\Gamma_2$ and there is some $S$ such that
    $\Gamma_1,x:S \vdash C[x]$ and $\Gamma_2,x:\gvdual{S} \vdash V \app x$.  Thus we have that
    $\Gamma,x:S \vdash C[x] \parallel V \app x$ and $\Gamma \vdash (\nu x)(C[x] \parallel
    V \app x)$.
  \item In case \textsc{Wait}, from the assumption $\Gamma \vdash (\nu x)(C[\gvconst{wait} \app
    x] \parallel x)$, we can conclude that $\Gamma,x:\interm \vdash C[\gvconst{wait} \app x]$ and
    thus, from the typing of \gvconst{wait}, that $\Gamma \vdash C[()]$.
  \item In case \textsc{Link}, from the assumptions $\Gamma \vdash (\nu x) (C[\gvconst{link} \app
    (x, y)] \parallel C'[M]), x \in \fv(M)$, we can conclude that $\Gamma$ partitions as
    $\Gamma_1,\Gamma_2,y:S$ such that $\Gamma_1,y:S,x:\gvdual{S} \vdash C[\gvconst{link} \app (x,
    y)]$ and $\Gamma_2,x:S \vdash C'[M]$.  (Note that the free variable assumption on the reduction
    rule for \gvconst{fork} allows us to assume that neither $C$ or $C'$ binds $x$ or $y$.)  From
    the type of \gvconst{link}, we have that $\Gamma,x:\outterm \vdash C[x]$; similarly, from $x \in
    \fv(M)$, we can conclude that $\Gamma_2,y:S \vdash C'[M\{y/x\}]$.  Finally, from the typing rule
    for \gvconst{wait}, we have that $\Gamma_2,x:\interm,y:S \vdash C'[\gvletunit{\gvconst{wait}
      \app x}{M\{y/x\}}]$, and that $\Gamma \vdash (\nu x)(C[x] \parallel
    C'[\gvletunit{\gvconst{wait} \app x}{M\{y/x\}}])$ \qed
  \end{itemize}
\end{proof}

\begin{theorem}\label{thm:preservation-equiv}
  If $\Gamma \vdash P$, $P \equiv P'$ and $P' \ceval Q'$, then there are some $\Gamma',Q$ such that
  either $\Gamma = \Gamma'$ or $\Gamma \ceval \Gamma'$, $Q' \equiv Q$, and $\Gamma' \vdash Q$.
\end{theorem}

\begin{proof}
  We begin by observing that if $P \ceval Q$, then there is some well-typed $P'$ such that $P =
  C[P']$, $P' \ceval Q'$, and $Q = C[Q']$.  The desired result is then obtained by structural
  induction on $P$, examining the possible equivalences in each case. \qed
\end{proof}

Define $\ceval^\star$ as the reflexive, transitive closure of $\equiv\ceval\equiv$.

\subsection{Deadlock and Its Absence}

Blocked terms:
\newcommand{\blockedp}{\mathsf{blocked}}
\newcommand{\depp}{\mathsf{depends}}
\[\begin{array}{rcl}
  \blockedp(x,M) &\defiff& \exists N. \; M = E[\gvconst{send} \app (x,N)] \\
  && \quad \lor \, M = E[\gvconst{receive} \app x] \\
  && \quad \lor \, M = E[\gvconst{wait} \app x] \\
  \depp(x,y,E[M]) &\defiff& \blockedp(x,M) \land y \in \fv(E) \\
  \depp(x,y,P) &\defiff& (P \equiv C[M] \land \depp(x,y,M)) \lor \, (P \equiv C[Q \parallel Q'] \\
  && \quad \land \, (\exists z. \depp(x,z,Q) \land \depp(z,y,Q')))
\end{array}\]
Finally, we have a natural definition of deadlock:
\newcommand{\deadlockp}{\ensuremath{\mathsf{deadlocked}}}
\[
\deadlockp(P) \defiff P \equiv C[Q \parallel Q'] \land \exists x,y. \depp(x,y,Q) \land \depp(y,x,Q').
\]
Because this definition depends on blocked processes (that is, those waiting to read or write) it
avoids the problems with return values (since a process returning a channel is not blocked on it, it
cannot be part of a deadlocked pair).  We say a process $P$ is deadlock-free if for all $Q$ such
that $P \ceval^\star Q$, $\lnot\deadlockp(Q)$.  Observe that if $P \equiv Q$, then $\deadlockp(P)
\iff \deadlockp(Q)$.

\begin{lemma}\label{thm:procs-share-one-channel}
  If $\Gamma \vdash P$, and $P = C[Q \parallel Q']$, then there is some variable $x$ such that
  $\fv(Q) \cap \fv(Q') = \{ x \}$.
\end{lemma}

\begin{proof}
  By structural induction on the derivation of $\Gamma \vdash P$; the only interesting case is for
  parallel composition, where the desired result is assured by the partitioning of the
  environment. \qed
\end{proof}

I think we can now show fairly directly that

\begin{lemma}\label{thm:typed-configs-df}
  If $\Gamma \vdash P$ then $\lnot \deadlockp(P)$.
\end{lemma}

\begin{proof}
  By contradiction: suppose $\deadlockp(P)$.  Then we know there must be some variables
  $x_1,\dots,x_n$ and processes $M_1,\dots,M_n$ in $P$ such that
  \[
    \blockedp(x_1,x_2,M_1) \land \blockedp(x_2,x_3,M_2) \land \cdots \land \blockedp(x_n,x_1,M_n).
  \]
  But now there is no possible $\Gamma$ such that any $\Gamma \vdash P'$ for any process $P'$
  containing the $M_i$---such a $P'$ would violate \lemref{procs-share-one-channel}.  \qed
\end{proof}

Finally, the following is trivial.

\begin{theorem}\label{thm:typed-terms-df}
  If $\Gamma \vdash M: T$, then $\distinguish M$ is deadlock-free.
\end{theorem}

\begin{proof}
  If $\Gamma \vdash M: T$, then $\Gamma \vdash \distinguish{M}$, and so
  $\lnot\deadlockp(\distinguish M)$ and, for any $Q$ such that $\distinguish M \ceval^\star Q$, we
  know that there is a well-typed $Q' \equiv Q$, and so $\lnot\deadlockp(Q)$. \qed
\end{proof}

\begin{definition}
A process $P$ is in canonical form if there is some sequence of variables $x_1,\dots,x_{n-1}$ and
terms $M_1,\dots,M_n$ such that
\[
  P = (\nu x_1)(M_1 \parallel (\nu x_2)(M_2 \parallel \dots \parallel (\nu x_{n-1})(M_{n-1} \parallel \distinguish{M_n})\dots)).
\]
\end{definition}

\begin{lemma}\label{thm:canonical}
  If $\Gamma \vdash P$, then there is some $P' \equiv P$ such that $\Gamma \vdash P'$ and $P'$ is in
  canonical form.
\end{lemma}

\begin{proof}
  Let $x_1,\dots,x_{n-1}$ be the $\nu$-bound variables in $P$ and $M_1,\dots,M_n$ be the terms in
  $P$; the proof is by induction on $n$.  If $n > 1$, then pick some $M_i$ such that there is
  exactly one $\nu$-bound variable $x_j$ where $x_j \in \fv(M_i)$.  (That there must be such an
  $M_i$ and $x_j$ can be established by a standard counting argument, together with
  \lemref{procs-share-one-channel}.)  Now, construct $Q$ from $P$ by the homomorphic extension of
  the mapping $(\nu x_j)P \mapsto P$ and $P \parallel M_i \mapsto P$.  From the assumption that
  $\Gamma \vdash P$, we can conclude that there is some $\Gamma' \subseteq \Gamma$ and type $S$ such
  that $\Gamma',x:S \vdash Q$.  By the induction hypothesis, there is some $Q' \equiv Q$ in
  canonical form.  Finally, let $P' = (\nu x_j)(M_i \parallel Q')$; we can see that
  straightforwardly that $P'$ is in canonical form; that $P \equiv P'$; and, that $\Gamma \vdash
  P'$. \qed
\end{proof}

\begin{theorem}\label{thm:progress-open}
  Let $\Gamma \vdash P$, $P \centernot\ceval$ and let $P' = (\nu x_1)(M_1 \parallel (\nu
  x_2)(M_2 \parallel \dots \parallel (\nu x_{n-1})(M_{n-1} \parallel \distinguish{M_n})\dots))$ be
  a canonical form of $P$.  Then:
  \begin{enumerate}
  \item For $1 \leq i \leq n - 1$ either $\blockedp(x_j,M_i)$ where $j \leq i$ or $\blockedp(y,M_i)$
    for some $y \in \dom(\Gamma)$; and,
  \item Either $M_n$ is a value or $\blockedp(y,M_n)$ for some $y \in \{ x_i \mid i \leq i \leq n -
    1 \} \cup \dom(\Gamma)$.
  \end{enumerate}
\end{theorem}

\begin{proof}
  By induction on the derivation of $\Gamma \vdash P'$, using the definition of $\ceval$. \qed
\end{proof}

\begin{corollary}\label{thm:progress}
  Let $\vdash P$, $P \centernot\ceval$ and let $P' = (\nu x_1)(M_1 \parallel (\nu
  x_2)(M_2 \parallel \dots \parallel (\nu x_{n-1})(M_{n-1} \parallel \distinguish{M_n})\dots))$ be
  a canonical form of $P$.  Then:
  \begin{enumerate}
  \item For $1 \leq i \leq n - 1$, $\blockedp(x_i,M_i)$; and,
  \item $M_n = \distinguish V$ for some value $V$.
  \end{enumerate}
\end{corollary}

\begin{proof}
  By induction on the derivation of $\vdash P'$, relying on \thmref{progress-open}.  \qed
\end{proof}

\section{Direct GV semantics}

\newcommand{\rpar}[1]{\mathbin{{[}\:\!\!\rangle}_{\!{#1}}\!}
\newcommand{\lrpar}[1]{\mathbin{\langle\hspace{-.3ex}\rangle}_{\!{#1}}\!}
\newcommand{\lpar}[1]{\mathbin{\langle\:\!\!{]}}_{{#1}}\!}

\newcommand{\con}[3]{{#1} \rpar{#2} {#3}}

\[
\mkwd{connect} : (S \lto \outterm, \gvdual{S} \lto T) \lto T
\]

Syntactic sugar:
\begin{align*}
\con{M}{x}{N} &\defiff \mkwd{connect}(\lambda x.M, \lambda x.N) \\
\con{L}{x}{\con{M}{y}{N}} &\defiff \con{L}{x}{(\con{M}{y}{N})} \\
\end{align*}

Equivalences ($\equiv$ is the transitive, reflexive, symmetric closure of the following rules):
\begin{align*}
\mkwd{link}\,(x,y) &\equiv \mkwd{link}\,(y,x) \\
\con{L}{x}{\con{M}{y}{N}} &\equiv \con{M}{y}{\con{L}{x}{N}} \\
\con{L}{x}{\con{M}{y}{N}} &\equiv \con{(\con{L}{x}{M})}{y}{N} \\
%\con{L}{x}{\con{M}{y}{N}} &\equiv \con{(\con{M}{x}{L})}{y}{N} \\
\end{align*}

Interesting reductions
\begin{align*}
\con{E[\mkwd{send}\,(V,x)]}{x}{E'[\mkwd{receive}\,x]}
  &\rto \con{E[x]}{x}{E'[(V,x)]} \\
\con{E[\mkwd{receive}\,x]}{x}{E'[\mkwd{send}\,(V,x)]}
  &\rto \con{E[(V,x)]}{x}{E'[x]} \\[1ex]
\con{x}{x}{E[\mkwd{wait}\,x]}
  &\rto E[()] \\
\con{E[\mkwd{wait}\,x]}{x}{x}
  &\rto E[()] \\[1ex]
\con{E[\mkwd{link}\,(x,y)]}{x}{M}
  &\rto \con{E[x]}{x}{(\mkwd{wait}\,x; M[y/x])} \\
\con{M}{x}{E[\mkwd{link}\,(x,y)]}
  &\rto \con{(\mkwd{wait}\,x; M[y/x])}{x}{E[x]} \\[1ex]
\mkwd{link}\,(x,\mkwd{link}\,(y,z))
  &\rto \mkwd{wait}\,x; \mkwd{link}\,(y,z) \\
E[\con{M}{x}{N}]
  &\rto \con{M}{x}{E[N]} \\
\end{align*}

An alternative is to remove the final commuting conversion rule and augment the notion of value to
include a suitable representation of a collection of blocked communicating processes.

Preservation
\begin{theorem}
If $\Gamma \vdash M : T$ and $M \rto N$ then $\Gamma \vdash N : T$.
\end{theorem}
%
\begin{proof}
By induction on the structure of the derivation of $\Gamma \vdash M : T$ using a standard
substitution lemma for the case of $\beta$-reduction at function types. \qed
\end{proof}

Progress
\begin{theorem}
\label{thm:free-progress}
If $\Gamma$ is a session environment (all variables in $\Gamma$ have session type) such that $\Gamma
\vdash M : T$ then one of the following holds:
\begin{enumerate}
\item $M$ is a value; or
\item there exists $N = \blockedp'(y_1, M_1) \rpar{x_1} \dots \rpar{x_{n}} \blockedp'(y_{n}, M_{n})$
  such that $M \equiv N$ and $\Gamma \vdash N : T$; or
\item there exists $N$ such that $M \rto N$.
\end{enumerate}
\end{theorem}
%
\begin{proof}
By induction on the structure of the derivation of $\Gamma \vdash M : T$. \qed
\end{proof}
% In the second case each $y_i$ must be equal to either $x_i$ or some $x$ in $\Gamma$.

\begin{theorem}
If $\vdash M : T$ then one of the following holds:
\begin{enumerate}
\item $M$ is a value; or
\item there exists $N = \blockedp(x_1, M_1) \rpar{x_1} \dots \rpar{x_{n-1}} \blockedp(x_{n-1},
  M_{n-1}) \rpar{x_n} V$ such that $M \equiv N$ and $\Gamma \vdash N : T$; or
\item there exists $N$ such that $M \rto N$.
\end{enumerate}
\end{theorem}
%
\begin{proof}
By induction on the structure of the derivation of $\vdash M : T$ using
\thmref{free-progress}. \qed
\end{proof}

$\blockedp(x, M)$ means $M$ is blocked on a send or receive involving $x$.

$\blockedp'(x, M)$ means either $M = x$ or $M$ is blocked on a send, receive, link, or wait
involving $x$.

\section{CP Translation and Equivalence}


Correspondence between reduction in CP and reduction in GV. Do the following theorems actually hold,
or is the correspondence more subtle? (I'm pretty certain they don't.)

\begin{theorem}
If $P \vdash \Gamma$ and $P \rto Q$ then $\togv{P} \rto \togv{Q}$.
\end{theorem}

\begin{theorem}
If $M \rto N$ then $\tocp{M}z \rto \tocp{N}z$.
\end{theorem}

\section{Extending GV}

We define a language GVX, which, depending on your perspective, either extends GV with mix or
combines the types of closed sessions.  The syntax is largely as in GV; the meaningful changes are
the elimination of $\interm$ and $\outterm$ in favor of $\gvend$, and the use of \gvconst{close} instead
of \gvconst{wait}.
\begin{syntax}
  \text{Session types} & S & ::= & \gvout{T}{S} \mid \gvin{T}{S} \mid \gvend \mid \channel{S} \\
  \text{Constants} & K & ::= & \gvconst{send} \mid \gvconst{receive} \mid \gvconst{fork} \mid \gvconst{close} \mid \gvconst{link}\\
\end{syntax}
The remaining parts of the grammar are unchanged from GV.  The definition of duality is updated to
reflect that $\gvend$ is self-dual:
\[
  \gvdual \gvend = \gvend
\]
We provide new typing rules for some of the constants
\begin{mathpar}
\gvconst{fork} : (S \lto \one) \lto \gvdual S

\gvconst{close} : \gvend \lto \one

\gvconst{link} : S \times \gvdual S \lto \one
\end{mathpar}
but otherwise the type system is unchanged from that of GV.  We require an extension of the type
system for configurations, however:
\begin{mathpar}
\inferrule
  {\Gamma \vdash M: T}
  {\Gamma \vdash^\bcirc \distinguish M}

\inferrule
  {\Gamma \vdash M: \one}
  {\Gamma \vdash^\wcirc M}

\inferrule
  {\Gamma, x: \channel S \vdash^\phi P}
  {\Gamma \vdash^\phi (\nu x)P}

\inferrule
  {\Gamma, x: S \vdash^\phi P \\
   \Gamma', x: \gvdual S \vdash^{\phi'} P'}
  {\Gamma,\Gamma',x:\channel S \vdash^{\phi + \phi'} P \parallel P'}

\inferrule
  {\Gamma \vdash^\phi P \\
   \Gamma' \vdash^{\phi'} P'}
  {\Gamma,\Gamma' \vdash^{\phi + \phi'} P \parallel P'}
\end{mathpar}
Perhaps the latter two rules can be combined by defining a suitable operation on environments;
however, it seems simpler now to just provide two typing rules.  Rules \textsc{Send, Fork, Lift} and
\textsc{Lift2} apply to GVX unchanged; the remaining reduction rules are
\begin{mathpar}
\inferrule
  { }
  {(\nu x)(C[\gvconst{close} \app x] \parallel C'[\gvconst{close} \app x)] \ceval C[()] \parallel C'[()]}

\inferrule
  {x \in \fv(P)}
  {C[\gvconst{link} \app (x,y)] \parallel P \ceval C[()] \parallel P \{y/x\}}
\end{mathpar}
The equivalences are similarly extended by
\begin{mathpar}
P \parallel () \equiv P
\end{mathpar}
We have a slightly different result about channels shared between processes, to account for the
multiple forms of composition:
\begin{lemma}
  If $\Gamma \vdash P$ and $P = C[Q \parallel Q']$, then $\fv(Q) \cap \fv(Q')$ is either empty or
  the singleton set $\{x\}$ for some variable $x$.
\end{lemma}
The proof is again by induction on the derivation of $\Gamma \vdash P$.  However, note that this has
no consequence for the proof of deadlock freedom (which depended on their being two channels shared
among processes).  Thus we can conclude that
\begin{theorem}
  If $\Gamma \vdash M: T$ then $\distinguish M$ is deadlock free.
\end{theorem}

\section{Related Work}\label{sec:related}

\section{Conclusions and Future Work}\label{sec:conclusion}


\end{document}
