\documentclass[preprint,onecolumn]{sigplanconf}

% US Letter page size
\pdfpagewidth=8.5in
\pdfpageheight=11in

\usepackage{mathpartir}
\usepackage{amsmath}
\usepackage{mathtools}
\usepackage{stmaryrd}
\usepackage{xspace}
\usepackage{amsthm}
\usepackage{hyperref}
\usepackage{url}
\usepackage[table]{xcolor}
\usepackage{suffix}
\usepackage{graphicx}

%%% macros %%%

\newtheorem{theorem}{Theorem}
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{corollary}[theorem]{Corollary}
\newtheorem{proposition}[theorem]{Proposition}
\newtheorem{definition}[theorem]{Definition}

\newcommand{\ba}{\begin{array}}
\newcommand{\ea}{\end{array}}

\newcommand{\bl}{\ba{@{}c@{}}}
\newcommand{\el}{\ea}

\newenvironment{equations}{\[\ba{@{}r@{~}c@{~}l@{}}}{\ea\]}
\newenvironment{eqs}{\ba{@{}r@{~}c@{~}l@{}}}{\ea}



\newcommand{\key}{\mathsf}

\newcommand{\set}[1]{\{ #1 \}}


\newcommand{\gvtocp}[1]{\llbracket{#1}\rrbracket}
\newcommand{\cptogv}[1]{\llparenthesis{#1}\rrparenthesis}

\newcommand{\row}[2]{\set{#1}_{#2}}

\newcommand{\gvOutput}[2]{\mathord{!}{#1}.{#2}}
\newcommand{\gvInput}[2]{\mathord{?}{#1}.{#2}}
\newcommand{\gvEndOutput}{\key{end}_!}
\newcommand{\gvEndInput}{\key{end}_?}
\newcommand{\gvPlus}[2]{\oplus \row{#1}{#2}}
\newcommand{\gvChoice}[2]{\binampersand \row{#1}{#2}}
\newcommand{\gvServer}[1]{\flat {#1}}
\newcommand{\gvService}[1]{\sharp {#1}}
\newcommand{\gvDual}[1]{\overline{#1}}
\newcommand{\gvOutputType}[2]{![{#1}].{#2}}
\newcommand{\gvInputType}[2]{?[{#1}].{#2}}

\newcommand{\cpj}[2]{{#1} \vdash {#2}}
\newcommand{\gvj}[3]{{#1} \vdash {#2} : {#3}}

\newcommand{\la}{l}
\newcommand{\G}{\Gamma}
\newcommand{\D}{\Delta}

\newcommand{\lolli}{\multimap}

\newcommand{\gvLinFun}[2]{{#1} \lolli {#2}}
\newcommand{\gvUnFun}[2]{{#1} \to {#2}}
\newcommand{\gvTimes}[2]{{#1} \otimes {#2}}
\newcommand{\gvUnitType}{\key{Unit}}

\newcommand{\gvUnit}{\key{unit}}
\newcommand{\gvLink}[2]{\key{link}~{#1}~{#2}}
\newcommand{\gvLam}[2]{\lambda {#1}.{#2}}
\newcommand{\gvApp}[2]{{#1}~{#2}}
\newcommand{\gvPair}[2]{({#1},{#2})}
\newcommand{\gvLet}[3]{\key{let}~{#1}={#2}~\key{in}~{#3}}
\newcommand{\gvSend}[2]{\key{send}~{#1}~{#2}}
\newcommand{\gvReceive}[1]{\key{receive}~{#1}}
\newcommand{\gvSelect}[2]{\key{select}~{#1}~{#2}}
\newcommand{\gvCase}[2]{\key{case}~{#1}~\key{of}~{#2}}

\newcommand{\gvFork}[2]{\key{fork}~{#1}.{#2}}

\newcommand{\gvWith}[3]{\key{with}~{#1}~\key{connect}~{#2}~\key{to}~{#3}}
\newcommand{\gvTerminate}[1]{\key{terminate}~{#1}}


% receive with continuation
\newcommand{\gvReceiveK}[4]{\gvLet{\gvPair{#1}{#2}}{\gvReceive{#3}}{#4}}

\newcommand{\gvSendType}[2]{\key{sendType}~{#1}~{#2}}
\newcommand{\gvReceiveType}[2]{\key{receiveType}~{#1}~{#2}}


\newcommand{\gvServeOld}[3]{\key{defServer}~{#1}({#2})={#3}}

\newcommand{\gvServe}[2]{\key{serve}~{#1}.{#2}}
\newcommand{\gvRequest}[1]{\key{request}~{#1}}

\newcommand{\cpLink}[2]{{#1} \leftrightarrow {#2}}
\newcommand{\cpCut}[3]{\nu {#1} ({#2} \mid {#3})}
\newcommand{\cpOutput}[4]{{#1}[{#2}].({#3} \mid {#4})}
\newcommand{\cpInput}[3]{{#1}({#2}).{#3}}
\newcommand{\cpInject}[3]{{#1}[{#2}].{#3}}
\newcommand{\cpCase}[2]{{#1}.\key{case}~{#2}}
\newcommand{\cpServe}[3]{!{#1}({#2}).{#3}}
\newcommand{\cpRequest}[3]{?{#1}[{#2}].{#3}}
\newcommand{\cpEmptyOut}[1]{{#1}[].0}
\newcommand{\cpEmptyIn}[2]{{#1}().{#2}}
\newcommand{\cpSendType}[3]{{#1}[{#2}].{#3}}
\newcommand{\cpReceiveType}[3]{{#1}({#2}).{#3}}

\newcommand{\cpBicut}[4]{\cpCut{#1\,#2}{#3}{#4}}
\newcommand{\cpStop}{0}

\newcommand{\cpAcc}[3]{\key{acc}~{#1}({#2}).{#3}}
\newcommand{\cpReq}[3]{\key{req}~{#1}[{#2}].{#3}}

\newcommand{\cpAccess}[1]{\langle{#1}\rangle}
\newcommand{\cpAccessA}[1]{\cpAccess{#1}^\textrm{a}}
\newcommand{\cpAccessR}[1]{\cpAccess{#1}^\textrm{r}}

\newcommand{\cpTimes}[2]{{#1} \otimes {#2}}
\newcommand{\cpPar}[2]{{#1} \mathbin{\bindnasrepma} {#2}}
\newcommand{\cpPlus}[2]{\oplus \row{#1}{#2}}
\newcommand{\cpWith}[2]{\binampersand \row{#1}{#2}}
\newcommand{\cpOne}{1}
\newcommand{\cpBottom}{\bot}
\newcommand{\cpOfCourse}[1]{\mathord{!}{#1}}
\newcommand{\cpWhyNot}[1]{\mathord{?}{#1}}
\newcommand{\cpDual}[1]{{#1}^\bot}
\newcommand{\cpExists}[2]{\exists {#1}.{#2}}
\newcommand{\cpForall}[2]{\forall {#1}.{#2}}

\newcommand{\cpZero}{0}    % 0   == +{}
\newcommand{\cpTop}{\top}  % top == &{}

\newcommand{\un}[1]{\mathit{un}(#1)}
\newcommand{\lin}[1]{\mathit{lin}(#1)}

\newcommand{\FV}[1]{\mathit{FV}(#1)}
\newcommand{\subst}[3]{{#1}\{{#2}/{#3}\}}

\newcommand{\substN}[2]{{#1}\{{#2}\}}
\newcommand{\substIt}[2]{{#1}/{#2}}

\newcommand{\gvtocps}[1]{\gvtocp{#1}}
\newcommand{\gvtocpd}[1]{\gvtocp{#1}}

\newcommand{\cpMix}[2]{({#1} \parallel {#2})}
\newcommand{\cpCutOutput}[5]{{#2}[{#3}].\nu{#1}.\cpMix{#4}{#5}}

\newcommand{\last}{LAST\xspace}

\newcommand{\hgv}{HGV\xspace}
\newcommand{\hgvpi}{HGV$\pi$\xspace}

\newcommand{\lampi}[1]{({#1})^\star}
\newcommand{\hgvcp}[1]{\llbracket{#1}\rrbracket}

\newcommand{\hgvcpl}{\left\llbracket}
\newcommand{\hgvcpr}{\right\rrbracket}

\newcommand{\redto}{\longrightarrow}
\newcommand{\eqto}{\equiv}

\newcommand{\infr}[3][]{\inferrule*[right={#1}]{#2}{#3}}
%\newcommand{\infr}[3][]{\inferrule[#1]{#2}{#3}}
%\newcommand{\infr}[3][]{\inferrule{#2}{#3}} % save space by getting rid of labels

\newcommand{\todo}[1]{\textbf{\color{red}TODO: #1}}

\begin{document}


\conferenceinfo{CONF 'yy}{Month d--d, 20yy, City, ST, Country} 
\copyrightyear{20yy} 
\copyrightdata{978-1-nnnn-nnnn-n/yy/mm} 
\doi{nnnnnnn.nnnnnnn}

% Uncomment one of the following two, if you are not going for the 
% traditional copyright transfer agreement.

%\exclusivelicense                % ACM gets exclusive license to publish, 
                                  % you retain copyright

%\permissiontopublish             % ACM gets nonexclusive license to publish
                                  % (paid open-access papers, 
                                  % short abstracts)

%\titlebanner{banner above paper title}        % These are ignored unless
%\preprintfooter{short description of paper}   % 'preprint' option specified.

%\preprintfooter{draft}

\title{Access points for CP}
%\subtitle{Subtitle Text, if any}

\authorinfo{Sam Lindley}{}{}
%% \authorinfo{Name2\and Name3}
%%            {Affiliation2/3}
%%            {Email2/3}

\maketitle


\newcommand{\nMix}{\textsc{\textit{n}-Mix}\xspace}
\newcommand{\nCut}{\textsc{\textit{n}-Cut}\xspace}

\begin{mathpar}
\infr[0-Mix]
{ }
{\cpj{\cpStop}{\G,\D}}

\infr[1-Mix]
{\cpj{P}{\G}}
{\cpj{P}{\G}}

\infr[2-Mix]
{\cpj{P}{\G} \\ \cpj{Q}{\D}}
{\cpj{\cpMix{P}{Q}}{\G,\D}}

\infr[\textit{n}-Mix]
{\cpj{P_1}{\G_1} \dots \cpj{P_n}{\G_n}}
{\cpj{P_1 \parallel \dots \parallel P_n}{\G_1, \dots, \G_n}}
\end{mathpar}

\begin{mathpar}
\infr[0-Cut]
{\cpj{P}{\G} \\ \cpj{Q}{\D}}
{\cpj{\cpMix{P}{Q}}{\G,\D}}

\infr[1-Cut]
{\cpj{P}{\G, x:A} \\ \cpj{Q}{\D, x:\cpDual{A}}}
{\cpj{\cpCut{x}{P}{Q}}{\G,\D}}

\infr[2-Cut]
{\cpj{P}{\G, x:A, y:B} \\ \cpj{Q}{\D, x:\cpDual{A}, y:\cpDual{B}}}
{\cpj{\cpCut{x}{P}{Q}}{\G,\D}}

\infr[3-Cut]
{\cpj{P}{\G, x:A, y:B, z:C} \\ \cpj{Q}{\D, x:\cpDual{A}, y:\cpDual{B}, z:\cpDual{C}}}
{\cpj{\cpCut{x}{P}{Q}}{\G,\D}}

\infr[\textit{n}-Cut]
{\cpj{P}{\G, \overline{x:A}} \\ \cpj{Q}{\D, \overline{x:\cpDual{A}}}}
{\cpj{\cpCut{\overline{x}}{P}{Q}}{\G,\D}}
\end{mathpar}

\begin{mathpar}

\infr[Accept]
  {\cpj{P}{\G,x:\cpAccessA{A},y:A}}
  {\cpj{\cpAcc{x}{y}{P}}{\G,x:\cpAccessA{A}}}

\infr[Request]
  {\cpj{P}{\G,x:\cpAccessR{A},y:A}}
  {\cpj{\cpReq{x}{y}{P}}{\G,x:\cpAccessR{A}}}
\\
\infr[Weaken]
{\cpj{Q}{\D} \\ \theta \in \set{\textrm{a}, \textrm{r}}}
{\cpj{Q}{\D,x:\cpAccess{A}^\theta}}

\infr[Contract]
{\cpj{Q}{\D,x:\cpAccess{A}^\theta,x':\cpAccess{A}^\theta} \\  \theta \in \set{\textrm{a}, \textrm{r}}}
{\cpj{\subst{Q}{x}{x'}}{\D,x:\cpAccess{A}^\theta}}
\end{mathpar}

Notice that \textsc{2-mix} and \textsc{0-cut} are the same rule.

Rather than explicitly adding new cut rules for \nCut, we admit the
existing cut rules leaving the first $n-1$ variables in place, and we
allow the order of the variables to be arbitrarily permuted.
\begin{equations}
\nu x_1 \,\dots\, \nu x_n &\equiv& \nu (x_1 \,\dots\, x_n) \\
\nu x\,\nu y             &\equiv& \nu y\,\nu x \\
\end{equations}

It is straightforward to simulate \nMix using \textsc{0-mix} and
\textsc{2-mix}.
\[
P_1 \parallel \dots \parallel P_n \equiv 0 \parallel (P_1 \parallel (P_2 \parallel \dots P_n))
\]

We can simulate \textsc{2-mix} using access points:
\[
\cpMix{P}{Q} \equiv \cpCut{x^{\cpAccessA{0}}}{P}{Q}
\]
or directly as \textsc{0-cut}:
\[
\cpMix{P}{Q} \equiv \cpCut{}{P}{Q}
\]


It seems that \textsc{3-cut} \emph{cannot} be simulated by
\textsc{2-cut}. We can define:
\[
\cpCut{x^A\,y^B\,z^C}{P}{Q} \equiv
\cpBicut{x^A}{v^{\cpPar{B}{C}}}
        {\cpInput{v}{u}{\substN{P}{\substIt{u}{y},\substIt{v}{z}}}}
        {\cpBicut{y^B}{z^C}
                 {\cpOutput{v}{u}{\cpLink{y}{u}}{\cpLink{z}{v}}}
                 {Q}}
\]
but it cannot reduce.

We can garbage collect stopped processes:
\[
\cpMix{P}{\cpStop} \equiv P
\]


In order to be able to give an appropriate semantics for access points
we replace the structural cut equivalence \textsc{assoc} by a notion
of evaluation frame in the definition of the reduction relation.
\[
E ::= % \cpMix{[~]}{Q} \mid \cpMix{P}{[~]} \mid
  \cpCut{\overline{x}}{[~]}{Q} \mid \cpCut{\overline{x}}{P}{[~]}
\]

\begin{mathpar}
\infr
{P \redto Q}
{E[P] \redto E[Q]}
\end{mathpar}


\begin{equations}
\cpCut{x}{\cpAcc{x}{y}{P}}{\cpReq{x}{y}{Q}} &=& \cpBicut{x}{y}{P}{Q} \\
\end{equations}



If we assume fixed points on terms then we can write some somewhat
interesting examples of concurrency.

\newcommand{\yes}{\textrm{yes}}
\newcommand{\no}{\textrm{no}}

Book store with one book given to first customer:
\begin{equations}
x &:& \cpAccessA{\cpPlus{\yes:\cpBottom, \no:\cpBottom}{}}\\
S &=& \cpAcc{x}{y}{\cpInject{y}{\yes}{\cpEmptyIn{y}{T}}}\\
T &=& \cpAcc{x}{y}{\cpInject{y}{\no}{\cpEmptyIn{y}{T}}}\\
\\
R &=& \cpReq{x}{y}{\cpCase{y}{\set{\yes.P, \no.Q}}} \\
\\
\multicolumn{3}{l}{\cpCut{x}{S}{(R \parallel R \parallel R)}} \\
\end{equations}

Book store with one book given to an arbitrary customer:
\begin{equations}
x &:& \cpAccessA{\cpPlus{\yes:\cpBottom, \no:\cpBottom}{}}\\
S &=& \cpMix{\cpAcc{x}{y}{\cpInject{y}{\yes}{\cpEmptyIn{y}{\cpStop}}}}{T} \\
T &=& \cpMix{\cpAcc{x}{y}{\cpInject{y}{\no}{\cpEmptyIn{y}{\cpStop}}}}{T} \\
\end{equations}

\newcommand{\Get}{\textrm{get}}
\newcommand{\Put}{\textrm{put}}

Non-linear state:
\begin{equations}
x &:& \cpAccessA{\cpWith{\Get:\cpTimes{A}{\cpBottom}, \Put:\cpPar{A}{\cpBottom}}{}}\\
S(v) &=& \cpAcc{x}{y}{\cpCase{y}{\set{\Get.\cpOutput{y}{w}{\cpLink{v}{w}}{\cpEmptyIn{y}{S(v)}},
                                      \Put.\cpInput{y}{v}{\cpEmptyIn{y}{S(v)}}}}} \\
\end{equations}





%% \begin{abstract}
%% \end{abstract}

%% \category{CR-number}{subcategory}{third-level}


%% \keywords word1; word2; word3


\end{document}
