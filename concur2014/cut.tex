\documentclass{article}\begin{document}\end{document}

%% \inferrule{\gvtyp{x_i:T_i,f:\vec{T} \uto X \uto \outterm,c:G(X)}{M}{\outterm} \\
%%            \gvtyp{\Phi,f:\vec{T} \uto \nu G \uto \outterm}{N}{U}}
%%           {\gvtyp{\Phi}{\gvletrec{f\,x_1 \dots x_n\,c}{M}{N}}{U}}

%% \begin{mathpar}
%% %% \inferrule{un(\Psi) \\
%% %%            \gvtyp{\Psi,\vec{x}:\vec{T},f:\langle \vec{T}, X \rangle \uto \outterm, c:G(X)}{M}{\outterm} \\
%% %%            \gvtyp{\Phi,\Psi,f:\langle \vec{T}, \nu G \rangle \uto \outterm}{N}{U}}
%% %%           {\gvtyp{\Phi,\Psi}{\gvletrec{f\,\vec{x}\,c}{M}{N}}{U}}

%% \inferrule{\gvtyp{\vec{x}:\vec{T},f:\langle \vec{T}, X \rangle \uto \outterm, c:G(X)}{M}{\outterm} \\
%%            \gvtyp{\Phi,f:\langle \vec{T}, \nu G \rangle \uto \outterm}{N}{U}}
%%           {\gvtyp{\Phi}{\gvletrec{f\,\vec{x}\,c}{M}{N}}{U}}


%% %% \inferrule{\gvtyp{\vec{x}:\vec{T},f:\langle \vec{T}, X \rangle \uto \outterm, c:G(X)}{M}{\outterm} \\
%% %%            \gvtyp{\Phi,f:\langle \vec{T}, \nu G \rangle \uto \outterm}{N}{U}}
%% %%           {\gvtyp{\Phi}{\gvletrec{f\,\vec{x}\,c}{M}{N}}{U}}

%% %% \inferrule{\gvtyp{\vec{x}:\vec{T},p:\gvout{\langle \vec{T}, X \rangle}{\outterm}, c:G(X)}{M}{\outterm} \\
%% %%            \gvtyp{\Phi,p:\gvout{\langle \vec{T}, \nu G \rangle}{\outterm}}{N}{U}}
%% %%           {\gvtyp{\Phi}{\gvletrec{p\,\vec{x}\,c}{M}{N}}{U}}

%% %% \inferrule{\gvtyp{x:T, f:T \uto X \lto \outterm, c:G(X)}{M}{\outterm} \\
%% %%            \gvtyp{\Phi, f:T \uto \nu G \lto \outterm}{N}{U}}
%% %%           {\gvtyp{\Phi}{\gvletrec{f\,x\,c}{M}{N}}{U}}

%% %% \inferrule{\gvtyp{x:T, f:(T \otimes X) \uto \outterm, c:G(X)}{M}{\outterm} \\
%% %%            \gvtyp{\Phi, f:(T \otimes \nu G) \uto \outterm}{N}{U}}
%% %%           {\gvtyp{\Phi}{\gvletrec{f\,x\,c}{M}{N}}{U}}


%% \inferrule{\gvtyp{x:T,p:\gvservice{(\gvout{T}{\gvout{X}{\outterm}})}, c:G(X)}{M}{\outterm} \\
%%            \gvtyp{\Phi,p:\gvservice{(\gvout{T}{\gvout{\nu G}{\outterm}})}}{N}{U}}
%%           {\gvtyp{\Phi}{\gvletrec{p\,x\,c}{M}{N}}{U}}
%% \end{mathpar}


%% \newcommand{\replicate}[2]{{!#1(#2)}}
%% \newcommand{\derelict}[2]{{?#1[#2]}}

%% \[
%% \bl
%% \left\llbracket
%% \inferrule{\gvtyp{x:T,p:\gvservice{(\gvout{T}{\gvout{X}{\outterm}})},c:G(X)}{M}{\outterm} \\
%%            \gvtyp{\Phi,p:\gvservice{(\gvout{T}{\gvout{\nu G}{\outterm}})}}{N}{U}}
%%           {\gvtyp{\Phi}{\gvletrec{p\,x\,c}{M}{N}}{U}}
%% \right\rrbracket z = \\
%% \qquad \cut{p}{}{\replicate{p}{y}.y(x).y(c).y().\corec{c}{w}{}{w[x].w[].0}{P}}{\tocp{N}z} \\
%% %%\cut{p}{}{\replicate{p}{y}.y(x).y(c).y().\corec{c}{ci}{}{\tocp{init}^\star}{\tocp{M^\dagger}^\star}}{\tocp{N}z}
%% \qquad \qquad \text{where }
%% P = \cut{p}{}{\replicate{p}{y}.y(x).y(c).y().c[x].c[].0}{w(x).\tocp{M}w} \\
%% \el
%% \]


%% \[
%%   \tocp{M}^\star = \cut{z}{\bot}{\tocp{M}z}{z[].0}
%% \]

%% \[
%%  init = \gvsend{x}{ci}
%% \]

%% \[
%% M^\dagger =
%%   \bl
%%   \key{let}\,p=\,\gvfork{p}
%%                    {\bl
%%                     \key{let}\,(x,y) = \gvreceive{(\gvrequest{p})}\,\key{in} \\
%%                     \key{let}\,(c,y) = \gvreceive{y}\,\key{in} \\
%%                     \quad \gvsend{x}{c}\,\key{in}
%%                     \el} \\
%%   \gvlet{(x,ci)}{\gvreceive{ci}}{M} \\
%%   \el
%% \]

%% \begin{multline*}
%% \left\llbracket
%% \inferrule{\gvtyp{x_i:T_i,f:\vec{T} \uto Q \uto \outterm,c:G(Q)}{M}{\outterm} \\
%%            \gvtyp{\Phi,f:\vec{T} \uto \nu G \uto \outterm}{N}{U}}
%%           {\gvtyp{\Phi}{\gvletrec{f\,x_1 \dots x_n\,c}{M}{N}}{U}}
%% \right\rrbracket z = \\
%% \replicate{f}{f_1}.f_1(x_1)\dots.\replicate{f_{n-1}}{f_n}.f_n(x_n).\corec{c}{ci}{}{\tocp{init_{ci}}^\star}{\tocp{M^\dagger_{ci}}^\star}
%% \end{multline*}

%% where

%% \[
%%   \tocp{M}^\star = \cut{z}{\bot}{\tocp{M}z}{z[].0}
%% \]

%% \[
%%  init_{ci} = \gvsend{x_n}{(\dots(\gvsend{x_1}{ci}))}
%% \]

%% \[\begin{array}{rcl}
%% M^\dagger_{ci} &=& \gvlet{f}{\lambda x_1\dots\lambda x_n.\lambda c.\gvsend{x_n}{(\dots(\gvsend{x_1}{c})\dots)}}
%%                 {\\&&\gvlet{(x_1,ci)}{\gvreceive{ci}}
%%                 {\\&&\vdots\\&&\gvlet{(x_n,ci)}{\gvreceive{ci}}{M}}}
%% \end{array}\]
%% }

\subsection{Church Numerals}

Basic idea: can code a type $?A$ by a least fixed point, and its dual $!(\cpdual{A})$ by the dual
greatest fixed point.  Will replicate Phil's Church numeral example using this coding.  Begin with
type abbreviations:
%
{\small\begin{align*}
  Query(A) &= \mu X.\oplus\{\clabel{w}:\bot,\clabel{c}:X \parr X,\clabel{d}:A\}, \\
  Bang(A) &= \nu X.\with\{\clabel{w}:1,\clabel{c}:X \otimes X,\clabel{d}:A\}.
\end{align*}}
%
Can translate type of Church numerals:
{\small\[
  Church = \forall A. Query(A \otimes \cpdual{A}) \parr (\cpdual{A} \parr A).
\]}
\todo{This requires second-order quantification.  To me, this argues for its removal.}
Now, expressing numbers is sarcasm-quotes obvious:
{\small\begin{align*}
  Zero_x &= x(A).x(s).x(z).\rec{s}.\sel{s}{w}.s().\link{z}{x}, \\
  One_x &= x(A).x(s).x(z).\rec{s}.\sel{s}{d}.s[a].(\link{a}{z} \mid \link{s}{x}).
\end{align*}}
Note the two different uses of the value $s$ of type $Query(A)$.  In $Zero$, we have no use of $s$,
so we select weakening and discard the resulting value of type $\bot$.  In $One$, we make one use of
it, and so select dereliction instead.

Of course, we don't want to have to code all the numbers manually.  Instead, we can devise a general
pattern for incrementing a Church numeral:
{\small\begin{align*}
  Inc_{x,y} =\ &y(A).y(s).y(z).\rec{s}.\sel{s}{c}.s(f).\rec{f}.\sel{f}{d}. \\
             &f[a].(\link{a}{z} \mid x[A].x[w].(\link{w}{s} \mid x[v].(\link{v}{f} \mid \link{y}{x}))).
\end{align*}}
%
We have that $\cptyp{Inc_{x,y}}{x:\cpdual{Church},y:Church}$, confirming that $Inc_{x,y}$ has the
expected type.  Finally, we can confirm that $Inc$ behaves as expected by showing, for example, that
{\small\[
  \cut{x}{Church}{Zero_x}{Inc_{x,y}} \Longrightarrow^\star One_{y}.
\]}
\todo{Use of $\Longrightarrow^\star$ before definition.}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

In the \textrm{more} case, we rely on our earlier definition of $Zero$.  Building the stream of
naturals $0,1,2,\dots$ is more involved, but little more complicated. Note that we will need two
copies of each number in the stream: the one that appears in the stream itself, and the one used to
generate the remainder of the stream.  Therefore, we'll use a $Bang(Nat)$ as our coinvariant.  We
begin by lifting $Zero$ to type $Bang(Nat)$:
%
{\small\[\begin{array}{r@{\hspace{2mm}}c@{\hspace{2mm}}l@{\hspace{0mm}}l@{\:}l}
  LiftZero_z & = & \mcl{3}{\lrkwd \: z \langle a \rangle (a[].0,} \\
  & & \quad & a().\mkwd{case}\: z \: \{ &\clabel{w}: z[].0; \\
  & & & & \clabel{d}: Zero_z; \\
  & & & & \clabel{c}: z[w].(w[].0 \mid z[].0) \}).
\end{array}\]}
%
Again, we don't need a coinvariant, so we use 1.  The only interesting behavior is in the case of
dereliction, in which we rely (again) on our existing definition of $Zero$.  Next, we can lift the
$Inc$ definition above to operate on $Bang(Nat)$ processes:
%
{\small\[\begin{array}{r@{\hspace{2mm}}c@{\hspace{2mm}}l@{\hspace{0mm}}l@{\:}l}
  LiftInc_{x,y} & = & \mcl{3}{\lrkwd \: y \langle z \rangle (\link{x}{z},} \\
  & & \quad & \mkwd{case} \: y \: \{ & \clabel{w}: \rec{z}.\sel{z}{w}.y[].0; \\
  & & & & \clabel{d}: \rec{z}.\sel{z}{d}.Inc_{z,y}; \\
  & & & & \clabel{c}: \rec{z}.\sel{z}{c}.z(w).y[x].(\link{x}{w} \mid \link{y}{z}) \}).
\end{array}\]}
%
The invariant $z$ is of type $Bang(Nat)$.  In the case of dereliction, $LiftInc$ behaves as
$Inc$; the other cases are implemented in terms of the corresponding cases of the coinvariant.
Thus, we have that
\[
  \cptyp{LiftInc_{x,y}}{x:Query(\cpdual{Nat}),y:Bang(Nat)}.
\]
Finally, we can define a stream of naturals: the invariant is of type $Bang(Church)$, initialized by
$LiftZero$, and the \textrm{more} case relies on $LiftInc$:
%

%


%% \begin{align*}
%%   \togv{\corec{x}{y}{}{P}{Q}} &= \gvsend{(\gvfork{y}{P})}{(\gvrequest{(\gvfix{p}{y\,x}{Q^\dagger})})} \\
%%   \togv{\rec{x}.P} &= \togv{P} \\
%%   \togv{x[y].(P \mid Q)} &=
%%     \gvlet{x}{\gvsend{(\gvfork{y}{\togv{P}})}{x}}{\togv{Q}} \\
%%   \togv{x(y).P} &=
%%     \gvlet{(y,x)}{\gvreceive{x}}{\togv{P}} \\
%%   \togv{\sel{x}{\mathit{l}}.P} &=
%%     \gvlet{x}{\gvselect{l}{x}}{\togv{P}} \\
%%   \togv{\case{x}{l_i.P_i}} &=
%%     \gvcase{x}{l_i.\togv{P_i}} \\
%%   \togv{x[].0} &= x \\
%%   \togv{x().P} &= \togv{P} \\
%%   \togv{\cut{x}{}{P}{Q}} &=
%%     \gvlet{x}{\gvfork{x}{\togv{P}}}{\togv{Q}} \\
%%   \togv{\link{x}{y}} &= \gvlink{x}{y} \\
%%   \togv{\replicate{s}{x}{P}} &=
%%     \gvlink{s}{(\gvserve{x}{\togv{P}})} \\
%%   \togv{\derelict{s}{x}{P}} &=
%%     \gvlet{x}{\gvrequest{s}}{\togv{P}} \\
%% \end{align*}

\subsection{Peano Numerals}\label{sec:peano}

To demonstrate the use of fixed points in \mucp, we will begin with a simple example, demonstrating
Peano numbers.  The type of Peano numbers is natural:
\[
  Peano = \mu X.\oplus\{zero: 1, succ: X\}.
\]
Note that this is a least fixed point: any individual Peano numeral will have finite behavior.  The
encoding of numerals is quite natural in this framework.  For example, we have 0 and increment
encoded as follows:
\begin{align*}
  Zero_x &= \rec{x}.\sel{x}{zero}.x[].0 \\
  Inc_{x,y} &= \rec{y}.\sel{y}{succ}.\link{x}{y}
\end{align*}
As we would expect, we have that $\cptyp{Zero_x}{x:Peano}$ and
$\cptyp{Inc_{x,y}}{x:\cpdual{Peano},y:Peano}$.  We can also show that increment behaves as we
expect.  For example, we have that
\[
  \cut{x}{Peano}{Zero_x}{Inc_{x,y}} \Longrightarrow^\star \rec{y}.\sel{y}{succ}.\rec{y}.\sel{y}{zero}.y[].0.
\]
As a more interesting example, we present a term that adds two numbers:
\[\begin{array}{rcl@{\hspace{0mm}}ll}
  Add_{x,y,z} & = & \mcl{3}{\mkwd{corec}\:x\langle a \rangle} \\
  & & \quad (&\mcl{2}{a[y].\link{a}{z},} \\
  & & & a(b).\mkwd{case}\:x\:\{&\clabel{zero}: x().\link{a}{b}; \\
  & & & & \clabel{succ}: x[b'].(Inc_{b,b'} \mid  \link{a}{x}) \}).
\end{array}\]
The term is structured as a case over the input numeral $x$.  If $x$ is zero, then the result $a$
should be equal to the other input numeral $b$; we accomplish this using the axiom rule.  If $x$ is
a successor, then we must increment $b$ in the recursive call.  We can show that
$\cptyp{Add_{x,y,z}}{x:\cpdual{Peano}, y:\cpdual{Peano}, z:Peano}$ and, for instance, that if we
have defined
\begin{align*}
  One_x &= \cut{y}{}{Zero_y}{Inc_{y,x}} \\
  Two_x &= \cut{y}{}{One_y}{Inc_{y,x}}
\end{align*}
then $Add$ behaves as we would expect:
\[
  \cut{x}{Peano}{One_x}{\cut{y}{Peano}{One_y}{Add_{x,y,z}}} \Longrightarrow^\star Two_z.
\]


  % A Curry-Howard correspondence between session types and linear logic was first demonstrated by
  % Caires and Pfenning for intuitionistic linear logic, and later adapted to the classical setting by
  % Wadler. These correspondences give both a logical interpretation of session types and a
  % computational interpretation of linear logic proofs, and ensure race freedom, deadlock freedom,
  % and termination of well-typed processes. However, neither system accomodates recursive sessions,
  % as might be used to represent stateful servers or inductive data types.

  % We extend Wadler's correspondence to recursive processes and sessions using equirecursive session
  % types. We show that the resulting types and processes are in correspondence with the propositions
  % and proofs of Baelde's extension of linear logic with greatest and least fixed points. Unlike
  % prior accounts of recursive session typing, our system distinguishes recursive and corecursive
  % processes, and exploits their duality to maintain race freedom, deadlock freedom, and termination,
  % even in the presence of unbounded corecursive processes.


% Session types provide a type-based approach to structuring communication among concurrent or
% distributed processes.  In this approach, types are used to describe communication protocols, and
% type checking guarantees that processes observe these protocols.  Session types have been applied in
% a variety of languages, including process calculi~\citep{Honda93,Honda98} and functional
% languages~\citep{GayVasconcelos10}.

% \citet{CairesPfenning10} first demonstrated a Curry-Howard correspondence between session-typed
% process calculi and intuitionistic linear logic (ILL).  Their correspondence gives both an
% interpretation of session types as ILL propositions, and a computational interpretation of ILL
% proofs as $\pi$-calculus processes.  As a result, they are able to show that well-typed processes
% are terminating, race-free, and deadlock-free, by analogy with corresponding cut-elimination results
% for ILL.  \citet{Wadler12} adapted their approach to classical linear logic (CLL).  In doing so, he
% presented two languages, CP and GV.  CP is a process calculus-like term-assignment for the proof
% rules of CLL.  GV is a session-typed functional language, based on the language of
% \citet{GayVasconcelos10}.  He shows that all GV typing derivations correspond to well-typed CP
% terms; subsequently, \cite{LindleyM14} extended GV such that all CP derivations correspond to GV
% terms as well.

% Most work on session-typed systems permit recursive processes and recursive session types.  However,
% neither of the correspondences between session types and linear logic include recursive sessions.
% This work extends Wadler's approach to include recursive sessions.  We extend CP to include notions
% of greatest and least fixed point, drawing on Baelde's~\citeyearpar{Baelde12} proof-theoretic study of
% fixed points in linear logic.  Likewise, we extend GV with recursive and corecursive sessions,
% providing bounded and unbounded iteration respectively.  Finally, we show that the resulting
% languages are still interconvertible.  We preserve the significant results of the existing
% correspondence (race freedom, deadlock freedom, and termination).

% The paper proceeds as follows. We begin by presenting a simple, session-typed functional
% language~\secref{mugv}, which includes support for recursive session types.  We next extend Wadler's
% CP language to include terms corresponding to recursion and corecursion~\secref{mucp}, based on
% Baelde's proof rules for fixed points in linear logic, and demonstrate their use.  We show that the
% languages \mugv and \mucp are equally expressive, by showing that \mugv can be reduced to its
% session-typed features~\secref{gvtogvpi}, and that terms in that reduced language are
% interconvertible with terms in \mucp~(\S\S\ref{sec:gvpitocp},\ref{sec:cptogvpi}).  We conclude with
% surveys of related~\secref{related} and future~\secref{future} work.

%\todo{Full list of examples: \begin{enumerate}
%\item Stream of zeros (no use of coinvariant);
%\item Stream of naturals (simple coinvariant);
%\item Stream of Fibonacci numbers (slightly less simple coinvariant);
%\item Calculator (recursion and choice)
%\item Bit strings (correspondence to Toninho et al.)
%\item Church numerals
%\item Peano numerals
%\item Simulating exponentials with fixed points
%\end{enumerate}}


%% \[
%% \ba{@{}cc@{}}
%% \begin{eqs}
%% pos_X(!T.S) &=& neg_X(T) \wedge pos_X(S) \\
%% pos_X(?T.S) &=& pos_X(T) \wedge pos_X(S) \\
%% pos_X(+\{l_i:S_i\}_i) &=& \forall i.pos(S_i) \\
%% pos_X(\with\{l_i:S_i\}_i) &=& \forall i.pos(S_i) \\
%% pos_X(\outterm) \\
%% pos_X(\interm) \\
%% pos_X(X) \\
%% \neg pos_X(\gvdual{X}) \\
%% pos_X(\mu G) &=& pos_X(G) \\
%% pos_X(\nu G) &=& pos_X(G) \\
%% pos_X(X.S) \\
%% pos_X(Y.S) &=& pos_X(S), \text{ if }X \neq Y \\
%% pos_X(T \otimes  U) &=& pos_X(T) \wedge pos_X(U) \\
%% pos_X(T \lto U) &=& neg_X(T) \wedge pos_X(U) \\
%% pos_X(T \uto U) &=& neg_X(T) \wedge pos_X(U) \\
%% \end{eqs}
%% &
%% \begin{eqs}
%% neg_X(!T.S) &=& pos_X(T) \wedge neg_X(S) \\
%% neg_X(?T.S) &=& neg_X(T) \wedge neg_X(S) \\
%% neg_X(+\{l_i:S_i\}_i) &=& \forall i.neg(S_i) \\
%% neg_X(\with\{l_i:S_i\}_i) &=& \forall i.neg(S_i) \\
%% neg_X(\outterm) \\
%% neg_X(\interm) \\
%% \neg neg_X(X) \\
%% neg_X(\gvdual{X}) \\
%% neg_X(\mu G) &=& neg_X(G) \\
%% neg_X(\nu G) &=& neg_X(G) \\
%% neg_X(X.S) \\
%% neg_X(Y.S) &=& neg_X(S), \text{ if }X \neq Y \\
%% neg_X(T \otimes  U) &=& neg_X(T) \wedge neg_X(U) \\
%% neg_X(T \lto U) &=& pos_X(T) \wedge neg_X(U) \\
%% neg_X(T \uto U) &=& pos_X(T) \wedge neg_X(U) \\
%% \end{eqs}
%% \ea
%% \]

%% \todo{Formally define monotonicity of operators}

%% pos(X, !T.S) = neg(X, T) /\ pos(X, S)
%% pos(X, ?T.S) = pos(X, T) /\ pos(X, S)
%% pos(X, +{li:Si}i) = forall i.pos(Si)
%% pos(X, &{li:Si}i) = forall i.pos(Si)
%% pos(X, end!)
%% pos(X, end!)
%% pos(X, X)
%% ¬pos(X, ~X)
%% pos(X, mu G) = pos(X, G)
%% pos(X, nu G) = pos(X, G)
%% pos(X, X.S)
%% pos(X, Y.S) = pos(X, S), if X =/= Y
%% pos(X, T *  U) = pos(X, T) /\ pos(X, U)
%% pos(X, T -o U) = neg(X, T) /\ pos(X, U)
%% pos(X, T -> U) = neg(X, T) /\ pos(X, U)

%% neg(X, !T.S) = pos(X, T) /\ neg(X, S)
%% neg(X, ?T.S) = neg(X, T) /\ neg(X, S)
%% neg(X, +{li:Si}i) = forall i.neg(Si)
%% neg(X, &{li:Si}i) = forall i.neg(Si)
%% neg(X, end!)
%% neg(X, end!)
%% ¬neg(X, X)
%% neg(X, ~X)
%% neg(X, mu G) = neg(X, G)
%% neg(X, nu G) = neg(X, G)
%% neg(X, X.S)
%% neg(X, Y.S) = neg(X, S), if X =/= Y
%% neg(X, T *  U) = neg(X, T) /\ neg(X, U)
%% neg(X, T -o U) = pos(X, T) /\ neg(X, U)
%% neg(X, T -> U) = pos(X, T) /\ neg(X, U)

%\subsection{Bit Strings}
%%
%%\todo{Validating the translation requires extending the GV interpreter with Booleans, addition and
%%  multiplication.}
%
%We now adapt an example of \citet{Toninho13}, in which a string of bits (0 or 1) is represented by a
%chain of processes, each storing one bit. The chain supports operations to increment and retrieve
%the stored value as a natural encoded by the bit string. Each link in the chain functions as a
%one-bit adder.
%
%We begin with the type $Link$ of the links in the chain. Each is a recursive process supporting
%three operations: compute the natural value encoded by the chain, increment the chain, and dispose
%of the chain.
%%
%\[\small
% Link = \nu X. \with \{ \clabel{val}: \gvin{Nat}{\gvout{Nat}{X}},
%                        \clabel{inc}: \oplus \{ \clabel{carry}: X,
%                                                \clabel{done}: X \},
%                        \clabel{stop}: \outterm \}
%\]
%Choosing $\clabel{val}$ or $\clabel{inc}$ cascades down the chain from most- to least-significant
%bit. The former returns the computed value; the latter returns the carry bit.
%
%The simplest node is the terminator $Epsilon$. It adds nothing to the value, and cannot store a
%responds to increment requests with a carry.
%\[\small
%\bl
%Epsilon : Link \to \outterm \\
%Epsilon = \lrkwd\:c\:epsilon = \\
%\quad \mkwd{case}\:c\:\mkwd{of}\:\{
%  \bl
%  \clabel{val}\:c.
%    \bl
%    \gvlet{(n,c)}{\gvreceive{c}}{
%    \gvlet{c}{\gvsend{n}{c}}{
%    epsilon\:c}} \\
%    \el \\
%  \clabel{inc}\:c.
%    \bl
%    \gvlet{c}{\gvselect{\clabel{carry}}{c}}{
%    epsilon\:c} \\
%    \el \\
%  \clabel{stop}\:c. c\}  \\
%  \el \\
%\el
%\]
%
%We can now define internal nodes. In response to a value request, an internal node adds its value to
%the value accumulated so far, and passes the result to the next node in the chain; the response is
%passed up the chain unchanged. In response to an increment request, the bit flips, passing on a
%carry option if needed. Internal nodes require two state components: the represented bit ($b$) and
%the remainder of the chain ($d$).
%%
%\[\small
%\bl
%Node : Link \uto Bool \lto \gvdual{Link} \lto \outterm \\
%Node = \lrkwd\:node\:c\:b\:d = \\
%\quad
%  \bl
%  \mkwd{case}\:c\:\mkwd{of}\:\{
%      \bl
%      \clabel{val}\:c.
%        \bl
%        \gvlet{(m,c)}{\gvreceive{c}}{} \\
%        \gvlet{d}{\gvsend{(\gvifthen{b}{2 \times m + 1}{2 \times m})}{(\gvselect{\clabel{val}}{d})}}{} \\
%        \gvlet{(n,d)}{\gvreceive{d}}{
%        \gvlet{c}{\gvsend{n}{c}}{
%        node\:c\:b\:d}} \\
%        \el \\
%      \clabel{inc}\:c.
%        \bl
%        \mkwd{case}\:(\gvselect{\clabel{inc}}{d})\:\mkwd{of}\:\{ \\
%        \quad
%          \bl
%          \clabel{done}\:d. node\:(\gvselect{\clabel{done}}{c})\:b\:d \\
%          \clabel{carry}\:d.
%            \bl
%            \gvlet{c}{\gvifthen{b}{\gvselect{\clabel{carry}}{c}}{\gvselect{\clabel{done}}{c}}}{} \\
%            node\:c\:(not\:b)\:d \} \\
%            \el \\
%          \el \\
%        \el \\
%      \clabel{stop}\:c.\gvlet{d}{\gvselect{\clabel{stop}}{d}}{c} \} \\
%      \el \\
%  \el \\
%\el
%\]
%
%Now we can define the top level interface to a bit string. The interface supports the same three
%operations as the links---increment, retrieve value, and disposal---but with simpler behavior:
%\[\small
%  Count = \nu X. \with \{ \clabel{val}: \gvout{Nat}{X}, \clabel{inc}: X, \clabel{stop}: \outterm \}
%\]
%The implementation requires one state component, the first link of the chain (called $d$).
%\[\small
%\bl
%CounterImpl : Count \uto \gvdual{Link} \lto \outterm \\
%CounterImpl = \lrkwd\:counterImpl\:c\:d = \\
%\quad \mkwd{case}\:c\:\mkwd{of}\:\{
%  \bl
%  \clabel{val}\:c.
%     \bl
%     \gvlet{(n,d)}{\gvreceive{(\gvsend{0}{(\gvselect{\clabel{val}}{d})})}}
%     {counterImpl\:(\gvsend{n}{c})}\:d \\
%     \el \\
%  \clabel{inc}\:c.
%    \bl
%    \mkwd{case}\:\gvselect{\clabel{inc}}{d}\:\mkwd{of}\:\{ \\
%    \quad
%      \bl
%      \clabel{carry}\:d.
%         \bl
%         \gvlet{e}{\gvfork{e}{Node\:True\:d\:e}}{
%         counterImpl\:c\:e} \\
%         \el \\
%      \clabel{done}\:d.counterImpl\:c\:d\:\} \\
%      \el \\
%    \el \\
%  \clabel{stop}\:c.\gvlet{d}{\gvselect{\clabel{stop}}{d}}{c}\:\}
%  \el \\
%\el
%\]
%The value case uses the value behavior of the links, providing the initial value 0.  The increment
%option adds a new link to the chain if incrementing the existing chain requires
%carrying. $CounterImpl$ takes an initial chain as an argument. For a counter, we initialise this to
%the empty chain (encoding $0$):
%\[\small\bl
%  Counter : Count \uto \outterm \\
%  Counter = \lambda c.CounterImpl\:c\:(\gvfork{x}{Epsilon\:x}) \\
%\el\]
%Here is a simple example of using the counter:
%\[\small
%\bl
%\gvlet{c}{\gvfork{c}{Counter\:c}}{} \\
%\gvlet{(i,c)}{\gvreceive{(\gvselect{\clabel{val}}{c})}}{} \\
%\gvlet{(j,c)}{\gvreceive{(\gvselect{\clabel{val}}{(\gvselect{\clabel{inc}}{c})})}}{} \\
%\gvlet{(k,c)}{\gvreceive{(\gvselect{\clabel{val}}{(\gvselect{\clabel{inc}}{(\gvselect{\clabel{inc}}{c})})})}}{} \\
%\gvlet{c}{\gvselect{\clabel{stop}}{c}}{(i,j,k)}
%\el
%\]
%We begin by creating a new counter on channel $c$; we then perform a mixture of increment and value
%operations before closing the $c$ channel. The whole expression evaluates to $(0,1,3)$.
%


%% % \[
%% %   Q^\dagger =
%% %     \gvlet{c}
%% %           {\gvfork{x}{\togv{Q}}}
%% %           {\gvmap{\togv{F}}{x,c}{(\gvsend{c}{(\gvsend{x}{p})})}}
%% % \]%
%% % \[
%% %   Q^\dagger =
%% %     \gvlet{y'}
%% %           {\gvfork{y}{\togv{Q}}}
%% %           {\togv{\map{F}{x,c}{p[x].p[c].p[].0}}}
%% % \]%

%% The translation is the same as in our previous work~\cite{LindleyM14} except for recursion and
%% corecursion. Formally, it is a translation from judgements to terms (as we need to know the type
%% operator in the case of $\key{corec}$).

%
%% \[
%%   Q^\dagger = \gvlet{d}{\gvfork{x}{\togv{Q}}}{\gvmap{\togv{F}}{c,d}{(\gvsend{c}{(\gvsend{d}{p})})}}.
%% \]


%% We can transfer the functoriality result from \mucp to \mugv:

%% \begin{lemma}
%%   If $\cptyp{Q}{y:\cpdual{A},x:F(A)}$, then
%%   \[
%%     \gvtyp{x:\gvdual{\togv{A}},p:\gvservice{(\gvout{\gvdual{\togv{A}}}{\gvout{X}{\outterm}})},c:\togv{F}(X)}{Q^\dagger}{\outterm}
%%   \]
%% \end{lemma}

%% Since $\mapname$ is defined in \mucp by cases, we can get $\mapname$ in \mugv by applying our
%% existing translation to each case.  Define
%% \[
%%   Q^\dagger = \gvlet{d}{\gvfork{x}{\togv{Q}}}{\gvmap{\togv{F}}{c,d}{(\gvsend{c}{(\gvsend{d}{p})})}}.
%% \]

%% \begin{lemma}
%%   If $\cptyp{Q}{y:\cpdual{A},x:F(A)}$, then
%%   \[
%%     \gvtyp{x:\gvdual{\togv{A}},p:\gvservice{(\gvout{\gvdual{\togv{A}}}{\gvout{X}{\outterm}})},c:\togv{F}(X)}{Q^\dagger}{\outterm}
%%   \]
%% \end{lemma}

%% \begin{theorem}
%%   If $\cptyp{Q}{y:\cpdual{A},x:F(A)}$, then $\gvtyp{}{\gvfix{p}{y\,c}{Q^\dagger}}{\gvservice{(\gvout{\gvdual{\togv{A}}}{\gvout{\nu \togv{F}}{\outterm}})}}$.
%% \end{theorem}
