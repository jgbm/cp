% -*- fill-column: 100 -*-

\documentclass[orivec,envcountsame]{llncs}

\usepackage{amsmath,amssymb,mathwidth,stmaryrd,xcolor,xspace}
\addtolength{\jot}{-3px}

% Attempt to duplicate Springer's style of references
\usepackage[authoryear,compress,round]{natbib}
\renewcommand{\bibsection}{\section*{References}}
\renewcommand{\bibpreamble}{\small}

\usepackage{mathpartir}
\mprset{sep=1em}

\usepackage{float}
\floatstyle{boxed}
\restylefloat{figure}

\newcommand{\with}{\mathbin\binampersand}
\newcommand{\parr}{\mathbin\bindnasrepma}
\newcommand{\cpdual}[1]{#1^\perp}
\newcommand{\cpbang}[1]{{! #1}}
\newcommand{\cpquery}[1]{{? #1}}
\newcommand{\gvdual}[1]{\overline{#1}}
\newcommand{\gvout}[2]{{!#1.#2}}
\newcommand{\gvin}[2]{{?#1.#2}}
\newcommand{\lto}{\ensuremath{\multimap}}
\newcommand{\uto}{\ensuremath{\rightarrow}}
\newcommand{\outterm}{\mathrm{end}_!}
\newcommand{\interm}{\mathrm{end}_?}
\newcommand{\gvserver}[1]{\flat #1}
\newcommand{\gvservice}[1]{\sharp #1}
\newcommand{\trule}[1]{(\textit{#1})}
\newcommand{\cptyp}[2]{#1 \vdash #2}
\newcommand{\gvtyp}[3]{#1 \vdash #2 : #3}

\newcommand{\mapname}{\mathsf{map}}
\newcommand{\map}[3]{\mapname^{#1}_{#2}(#3)}
\newcommand{\gvmap}[3]{\mapname^{#1}_{#2}\:#3}

\newcommand{\mkwd}[1]{\mathsf{#1}}
\newcommand{\tkwd}[1]{\textsf{#1}}
\newcommand{\link}[2]{#1 \leftrightarrow #2}
\newcommand{\cut}[4]{\mkwd{new}\:#1 \: (#3 \mid #4)}
\newcommand{\replicate}[2]{{!#1(#2)}}
\newcommand{\derelict}[2]{{?#1[#2]}}
\newcommand{\rec}[1]{\mkwd{rec}\:#1}
\newcommand{\corec}[5]{\mkwd{corec}\:#1 \langle #2 \rangle (#4,#5)}
\newcommand{\clabel}[1]{\mathrm{#1}}
\renewcommand{\case}[2]{\mkwd{case}\:#1\:\{#2\}}
\newcommand{\sel}[2]{#1[\clabel{#2}]}
\newcommand{\gvsend}[2]{\mkwd{send}\:#1\:#2}
\newcommand{\gvreceive}[1]{\mkwd{receive}\:#1}
\newcommand{\gvlet}[3]{\mkwd{let}\;#1 = #2\;\mkwd{in}\;#3}
\newcommand{\gvselect}[2]{\mkwd{select}\:#1\:#2}
\newcommand{\gvcase}[2]{\mkwd{case}\:#1\:\{#2\}}
\newcommand{\gvlink}[2]{\mkwd{link}\:#1\:#2}
\newcommand{\gvfork}[2]{\mkwd{fork}\:#1.#2}
\newcommand{\lrkwd}{\mkwd{cofix}}
\newcommand{\gvfix}[3]{\lrkwd\:#1\:#2 = #3}
\newcommand{\gvletrec}[4]{\gvlet{#1}{\gvfix{#1}{#2}{#3}}{#4}}
\newcommand{\gvserve}[2]{\mkwd{serve}\:#1.#2}
\newcommand{\gvrequest}[1]{\mkwd{request}\:#1}

\newcommand{\gvifthen}[3]{\mkwd{if}\:#1\:\mkwd{then}\:#2\:\mkwd{else}\:#3}
\newcommand{\gvreceivek}[4]{\gvlet{({#1}, {#2})}{\gvreceive{#3}}{#4}}


\newcommand{\key}{\mkwd}
\newcommand{\cofix}{\lrkwd}

\newcommand{\tocpbig}[1]{\left\llbracket #1 \right\rrbracket}

\newcommand{\tocp}[1]{\llbracket #1 \rrbracket}
\newcommand{\togv}[1]{\llparenthesis #1 \rrparenthesis}
\newcommand{\De}{\mathcal{D}}

\newcommand{\topi}[1]{({#1})^\star}

\newcommand{\un}{un}
\newcommand{\lin}{lin}

\newcommand{\mucp}{$\mu\mathrm{CP}$\xspace}
\newcommand{\mugv}{$\mu\mathrm{GV}$\xspace}
\newcommand{\gvpi}{$\mu\mathrm{GV}\pi$\xspace}

\newcommand{\ba}{\begin{array}}
\newcommand{\ea}{\end{array}}

\newcommand{\bl}{\ba[t]{@{}l@{}}}
\newcommand{\el}{\ea}

\newenvironment{equations}{\[\ba{@{}r@{~}c@{~}l@{}}}{\ea\]}
\newenvironment{eqs}{\ba{@{}r@{~}c@{~}l@{}}}{\ea}

\newcommand{\mcl}[2]{\multicolumn{#1}{l}{#2}}

\newcommand{\secref}[1]{(\S\ref{sec:#1})}

\title{Recursive Session Types and Linear Logic}
\author{J. Garrett Morris \and Sam Lindley \and Philip Wadler}
\institute{University of Edinburgh \\
           \email{\{Garrett.Morris,Sam.Lindley\}@ed.ac.uk,wadler@inf.ed.ac.uk}}

\newcommand{\todo}[1]{{\noindent\small\color{red} \framebox{\parbox{\dimexpr\linewidth-2\fboxsep-2\fboxrule}{\textbf{TODO:} #1}}}}
%\newcommand{\todo}[1]{}

\begin{document}

\maketitle

\begin{abstract}
  We extend a propositions-as-types correspondence between linear logic and session types to include
  recursive sessions.  Our extension takes least and greatest fixpoints as dual, an idea well-known
  to theorists, but which has not previously appeared in the treatment of recursive sessions. As a
  result, some problems with recursion that appear in other systems do not arise in ours. Our
  extension also preserves the race-freedom and deadlock-freedom that are a hallmark of basing
  session types in a correspondence to linear logic. We treat two systems, one based on classical
  linear logic, derived from work of Caires and Pfenning and of Wadler, and one based on a
  linear functional language, derived from work of Gay and Vasconcelos. Our treatment of recursion
  is inspired by Baelde.

  % A Curry-Howard correspondence between session types and linear logic was first demonstrated by
  % Caires and Pfenning for intuitionistic linear logic, and later adapted to the classical setting by
  % Wadler. These correspondences give both a logical interpretation of session types and a
  % computational interpretation of linear logic proofs, and ensure race freedom, deadlock freedom,
  % and termination of well-typed processes. However, neither system accomodates recursive sessions,
  % as might be used to represent stateful servers or inductive data types.

  % We extend Wadler's correspondence to recursive processes and sessions using equirecursive session
  % types. We show that the resulting types and processes are in correspondence with the propositions
  % and proofs of Baelde's extension of linear logic with greatest and least fixed points. Unlike
  % prior accounts of recursive session typing, our system distinguishes recursive and corecursive
  % processes, and exploits their duality to maintain race freedom, deadlock freedom, and termination,
  % even in the presence of unbounded corecursive processes.
\end{abstract}

\section{Introduction}\label{sec:intro}

Session types provide a type-based approach to structuring communication among concurrent or
distributed processes.  In this approach, types are used to describe communication protocols, and
type checking guarantees that processes observe these protocols.  Session types have been applied in
a variety of languages, including process calculi~\citep{Honda93,Honda98} and functional
languages~\citep{GayVasconcelos10}.

\citet{CairesPfenning10} first demonstrated a Curry-Howard correspondence between
session-typed process calculi and intuitionistic linear logic (ILL).  Their correspondence gives
both an interpretation of session types as ILL propositions, and a computational interpretation of
ILL proofs as $\pi$-calculus processes.  As a result, they are able to show that well-typed
processes are terminating, race-free, and deadlock-free, by analogy with corresponding
cut-elimination results for ILL.  Wadler adapted their approach to classical linear logic (CLL).  In
doing so, he presented two languages, CP and GV.  CP is a process calculus-like term-assignment for
the proof rules of CLL.  GV is a session-typed functional language, based on the language of
\citet{GayVasconcelos10}.  He shows that all GV typing derivations correspond to
well-typed CP terms; subsequently, \cite{LindleyM14} extended GV such that all CP derivations
correspond to GV terms as well.

Most work on session-typed systems permit recursive processes and recursive session types.  However,
neither of the Curry-Howard treatments of session types include recursive sessions.  This work
extends Wadler's approach to include recursive sessions.  We extend CP to include notions of
greatest and least fixed point, drawing Baelde's proof-theoretic study of fixed points in linear
logic~\citep{Baelde12}.  Likewise, we extend GV with recursive and corecursive sessions, providing
bounded and unbounded iteration respectively.  Finally, we show that the resulting languages are
still interconvertible.  We preserve the significant results of the existing correspondence (race
freedom, deadlock freedom, and termination).

The paper proceeds as follows. We begin by presenting a simple, session-typed functional
language~\secref{mugv}, which includes support for recursive session types.  In contrast to existing
approaches to recursive session types, we distinguish between the greatest and least fixed points of
recursive equations.  We give several examples of recursive processes and their use.  We next review
Baelde's combinators for recursion in linear logic, and extend Wadler's CP language to include terms
corresponding to recursion and corecursion~\secref{mucp}.  We demonstrate the use of these
combinators both to code both recursive (Peano numerals) and corecursive (infinite streams)
types. Finally, we show that the languages \mugv and \mucp are equally expressive.  This has two
stages.  First, we show a translation of the functional features of \mugv into its process oriented
features~\secref{gvtogvpi}; we call the resulting restricted language \gvpi.  Second, we show that
programs in \gvpi can be translated to terms of \mucp~\secref{gvpitocp}, and that terms of \mucp can
be translated to terms of \gvpi~\secref{cptogvpi}.  We conclude with a survey of
related~\secref{related} and future~\secref{future} work.

%\todo{Full list of examples: \begin{enumerate}
%\item Stream of zeros (no use of coinvariant);
%\item Stream of naturals (simple coinvariant);
%\item Stream of Fibonacci numbers (slightly less simple coinvariant);
%\item Calculator (recursion and choice)
%\item Bit strings (correspondence to Toninho et al.)
%\item Church numerals
%\item Peano numerals
%\item Simulating exponentials with fixed points
%\end{enumerate}}

\section{A Session-Typed Functional Language}
\label{sec:mugv}

In this section, we present \mugv, a simple functional language with session types patterned on the
language of Gay and Vasconcelos~\cite{GayVasconcelos10} (which we call LAST) and Wadler's language
GV.

\subsection{Types}
\label{sec:mugv-types}

Types, session types, and type operators in \mugv are given by the following grammar:
\[
\small
\begin{array}{l@{\hspace{1mm}}r@{\hspace{2mm}}c@{\hspace{2mm}}l}
  \text{Types}         & T,U,V & ::= & S \mid T \otimes U \mid T \lto U \mid T \uto U \\
  \text{Session Types} & S     & ::= & \gvout{T}{S} \mid \gvin{T}{S}
                                \mid   \oplus \{ l_i : S_i \} \mid \with \{ l_i : S_i \}
                                \mid   \outterm \mid \interm \\
                            & & \mid & X \mid \gvdual{X}
                                \mid   \mu G \mid \nu G
                                \mid   \gvservice{S} \mid \gvserver{S} \\
  \text{Type Operators} & G    & ::= & X.S % \\
\end{array}
\]%
%
The types comprise session types, linear pairs ($T \otimes U$), and both linear ($T \lto U$) and
unlimited ($T \uto U$) functions.
%
Session types include input ($\gvin{T}{S}$), output ($\gvout{T}{S}$), selection ($\oplus\{ l_i:S_i
\}$) and choice ($\with\{l_i:S_i\}$). There are two variations on the closed channel ($\interm$) and
($\outterm$), which arise from our interpretation of session types in classical linear logic, where
there is no self-dual proposition to implement closed channels. We include a notion of replicated
sessions, corresponding to exponentials in linear logic: a channel of type $\gvservice{S}$ is a
``service'', providing any number of channels of type $S$; a channel of type $\gvserver{S}$ is the
``server'' providing such a service. Finally, we include session variables and their duals
($X,\gvdual{X}$), and two forms of recursive session types, corresponding to least ($\mu X.S$) and
greatest ($\nu X.S$) fixed points. If $G$ is an operator $X.S$, we write $G(S')$ for the
substitution instance $S[S'/X]$.

Each type $T$ is either linear ($\lin(T)$) or unlimited ($\un(T)$). The linearity of $T$ is
determined entirely by its top level type constructor.
%
All types are linear except unlimited functions $T \uto U$, replicated channels $\gvservice{S}$, and
closed input channels $\interm$.

Duality on non-recursive session types is standard.
\[
\small
\ba{@{}c@{\quad}c@{\quad}c@{\quad}c@{\quad}c@{\quad}@{}}
\begin{eqs}
\gvdual{\gvout{T}{S}} &=& \gvin{T}{\gvdual{S}} \\
\gvdual{\gvin{T}{S}} &=& \gvout{T}{\gvdual{S}} \\
\end{eqs}
&
\begin{eqs}
  \gvdual{\oplus \{ l_i: S_i \}} &=& \with \{ l_i : \gvdual{S_i} \} \\
  \gvdual{\with \{ l_i: S_i \}} &=& \oplus \{ l_i : \gvdual{S_i} \} \\
\end{eqs}
&
\begin{eqs}
  \gvdual{\interm} &=& \outterm \\
  \gvdual{\outterm} &=& \interm \\
\end{eqs}
&
\begin{eqs}
  \gvdual{\gvserver{S}} &=& \gvservice{\gvdual{S}} \\
  \gvdual{\gvservice{S}} &=& \gvserver{\gvdual{S}} \\
\end{eqs}
&
\begin{eqs}
  \gvdual{X} &=& \gvdual{X} \\
  \gvdual{\gvdual{X}} &=& X
\end{eqs} \\
\ea
\]
Duality on recursive session types is defined as follows:
\[
\small
\gvdual{\mu G} = \nu \gvdual{G} \qquad \gvdual{\nu G} = \mu \gvdual{G} \
\]%
where we define the dual of an operator $G = X.S$ as:
\[
\small
\gvdual{G} = X.\gvdual{G(\gvdual{X})}
\]%
%
Observe that $\gvdual{G}(\gvdual{S}) = \gvdual{G(S)}$, which allows us to
give a natural definition of duality for fixed points:
%
Unlike many notions of duality for session types, our definition preserves duality when recursive
session types are unfolded, even when the recursion occurs in messages.  For example, consider the
operator $G = X.\gvin{X}{\interm}$, its dual $\gvdual{G} = X.\gvout{\gvdual{X}}{\outterm}$, and the
session types $\mu G$ and $\nu \gvdual{G}$.  Unfolding the first type yields $G(\mu G)$, or
$\gvin{\mu G}{\interm}$; unfolding the second yields
\[
\small
  \gvdual{G}(\nu \gvdual{G}) = \gvout{\gvdual{\nu \gvdual{G}}}{\outterm} = \gvout{\mu G}{\outterm},
\]
which is the dual of $\gvin{\mu G}{\interm}$.

To ensure that fixed points exist, we require that all operators $X.S$ be monotonic, that is,
variables may appear only as positive subformulas of $S$, and negated variables only as negative
subformulas. As usual, the subformula $T$ in types $T \lto U$ and $T \uto U$ is
negative. Futhermore, the argument $T$ in the session type $\gvout{T}{S}$ is negative. All other
subformulas are positive. Thus, the operator $X.\gvout{X}{\outterm}$ is not monotonic, but the
operator $X.\gvout{(X \uto \outterm)}{\outterm}$ is.
%
Formally, $X.S$ is monotonic iff the predicate $pos_{X,S}$ holds, where $pos$ and $neg$ are the
predicates defined by the homomorphic extensions of the following equations:
\[
\small
\ba{@{}c@{\qquad}c@{}}
\begin{eqs}
pos_{X,X} \\
\neg pos_{X,\gvdual{X}} \\
pos_{X,!T.S} &=& neg_{X,T} \wedge pos_{X,S} \\
pos_{X,T \lto U} &=& neg_{X,T} \wedge pos_{X,U} \\
pos_{X,T \uto U} &=& neg_{X,T} \wedge pos_{X,U} \\
\end{eqs}
&
\begin{eqs}
\neg neg_{X,X} \\
neg_{X,\gvdual{X}} \\
neg_{X,!T.S} &=& pos_{X,T} \wedge neg_{X,S} \\
neg_{X,T \lto U} &=& pos_{X,T} \wedge neg_{X,U} \\
neg_{X,T \uto U} &=& pos_{X,T} \wedge neg_{X,U} \\
\end{eqs}
\ea
\]

%% \[
%% \ba{@{}cc@{}}
%% \begin{eqs}
%% pos_X(!T.S) &=& neg_X(T) \wedge pos_X(S) \\
%% pos_X(?T.S) &=& pos_X(T) \wedge pos_X(S) \\
%% pos_X(+\{l_i:S_i\}_i) &=& \forall i.pos(S_i) \\
%% pos_X(\with\{l_i:S_i\}_i) &=& \forall i.pos(S_i) \\
%% pos_X(\outterm) \\
%% pos_X(\interm) \\
%% pos_X(X) \\
%% \neg pos_X(\gvdual{X}) \\
%% pos_X(\mu G) &=& pos_X(G) \\
%% pos_X(\nu G) &=& pos_X(G) \\
%% pos_X(X.S) \\
%% pos_X(Y.S) &=& pos_X(S), \text{ if }X \neq Y \\
%% pos_X(T \otimes  U) &=& pos_X(T) \wedge pos_X(U) \\
%% pos_X(T \lto U) &=& neg_X(T) \wedge pos_X(U) \\
%% pos_X(T \uto U) &=& neg_X(T) \wedge pos_X(U) \\
%% \end{eqs}
%% &
%% \begin{eqs}
%% neg_X(!T.S) &=& pos_X(T) \wedge neg_X(S) \\
%% neg_X(?T.S) &=& neg_X(T) \wedge neg_X(S) \\
%% neg_X(+\{l_i:S_i\}_i) &=& \forall i.neg(S_i) \\
%% neg_X(\with\{l_i:S_i\}_i) &=& \forall i.neg(S_i) \\
%% neg_X(\outterm) \\
%% neg_X(\interm) \\
%% \neg neg_X(X) \\
%% neg_X(\gvdual{X}) \\
%% neg_X(\mu G) &=& neg_X(G) \\
%% neg_X(\nu G) &=& neg_X(G) \\
%% neg_X(X.S) \\
%% neg_X(Y.S) &=& neg_X(S), \text{ if }X \neq Y \\
%% neg_X(T \otimes  U) &=& neg_X(T) \wedge neg_X(U) \\
%% neg_X(T \lto U) &=& pos_X(T) \wedge neg_X(U) \\
%% neg_X(T \uto U) &=& pos_X(T) \wedge neg_X(U) \\
%% \end{eqs}
%% \ea
%% \]

%% \todo{Formally define monotonicity of operators}

%% pos(X, !T.S) = neg(X, T) /\ pos(X, S)
%% pos(X, ?T.S) = pos(X, T) /\ pos(X, S)
%% pos(X, +{li:Si}i) = forall i.pos(Si)
%% pos(X, &{li:Si}i) = forall i.pos(Si)
%% pos(X, end!)
%% pos(X, end!)
%% pos(X, X)
%% ¬pos(X, ~X)
%% pos(X, mu G) = pos(X, G)
%% pos(X, nu G) = pos(X, G)
%% pos(X, X.S)
%% pos(X, Y.S) = pos(X, S), if X =/= Y
%% pos(X, T *  U) = pos(X, T) /\ pos(X, U)
%% pos(X, T -o U) = neg(X, T) /\ pos(X, U)
%% pos(X, T -> U) = neg(X, T) /\ pos(X, U)

%% neg(X, !T.S) = pos(X, T) /\ neg(X, S)
%% neg(X, ?T.S) = neg(X, T) /\ neg(X, S)
%% neg(X, +{li:Si}i) = forall i.neg(Si)
%% neg(X, &{li:Si}i) = forall i.neg(Si)
%% neg(X, end!)
%% neg(X, end!)
%% ¬neg(X, X)
%% neg(X, ~X)
%% neg(X, mu G) = neg(X, G)
%% neg(X, nu G) = neg(X, G)
%% neg(X, X.S)
%% neg(X, Y.S) = neg(X, S), if X =/= Y
%% neg(X, T *  U) = neg(X, T) /\ neg(X, U)
%% neg(X, T -o U) = pos(X, T) /\ neg(X, U)
%% neg(X, T -> U) = pos(X, T) /\ neg(X, U)


\subsection{Typing Rules}
\label{sec:mugv-typing}

\begin{figure}[t]
\scriptsize
Structural rules
\begin{mathpar}
\inferrule{ }{\gvtyp{x:T}{x}{T}}

\inferrule{\gvtyp{\Phi}{M}{U} \\
           un(T)}
          {\gvtyp{\Phi,x:T}{M}{U}}

\inferrule{\gvtyp{\Phi,x:T,x':T}{M}{U} \\
           un(T)}
          {\gvtyp{\Phi,x:T}{M[x/x']}{U}}
\end{mathpar}
Lambda rules
\begin{mathpar}
\inferrule{\gvtyp{\Phi,x:T}{M}{U}}
          {\gvtyp{\Phi}{\lambda x.M}{T \lto U}}

\inferrule{\gvtyp{\Phi}{M}{T \lto U} \\
           \gvtyp{\Psi}{N}{T}}
          {\gvtyp{\Phi,\Psi}{M\,N}{U}}

\inferrule{\gvtyp{\Phi}{M}{T \lto U} \\
           un(\Phi)}
          {\gvtyp{\Phi}{M}{T \uto U}}

\inferrule{\gvtyp{\Phi}{M}{T \uto U}}
          {\gvtyp{\Phi}{M}{T \lto U}}

\inferrule{\gvtyp{\Phi}{M}{T} \\
           \gvtyp{\Psi}{N}{U}}
          {\gvtyp{\Phi,\Psi}{(M,N)}{T \otimes U}}

\inferrule{\gvtyp{\Phi}{M}{T \otimes U} \\
           \gvtyp{\Psi,x:T,y:U}{N}{V}}
          {\gvtyp{\Phi,\Psi}{\gvlet{(x,y)}{M}{N}}{V}}
\end{mathpar}
Session rules
\begin{mathpar}
\inferrule{\gvtyp{\Phi}{M}{S} \\
           \gvtyp{\Psi}{N}{\gvdual{S}}}
          {\gvtyp{\Phi,\Psi}{\gvlink{M}{N}}{\outterm}}

\inferrule{\gvtyp{\Phi}{M}{T} \\
           \gvtyp{\Psi}{N}{\gvout{T}{S}}}
          {\gvtyp{\Phi,\Psi}{\gvsend{M}{N}}{S}}

\inferrule{\gvtyp{\Phi}{M}{\gvin{T}{S}}}
          {\gvtyp{\Phi}{\gvreceive{M}}{T \otimes S}}

\inferrule{\gvtyp{\Phi,x:\gvdual{S}}{M}{\outterm}}
          {\gvtyp{\Phi}{\gvfork{x}{M}}{ S}}

\inferrule{\gvtyp{\Phi}{M}{\oplus \{ l_i:S_i \}}}
          {\gvtyp{\Phi}{\gvselect{l_i}{M}}{S_i}}

\inferrule{\gvtyp{\Phi}{M}{\with \{ l_i:S_i \}} \\
           \gvtyp{\Psi,x:S_i}{N_i}{T}}
          {\gvtyp{\Phi,\Psi}{\gvcase{M}{l_i\,x.N_i}}{T}}

%% \end{mathpar}
%% Replicated session rules
%% \begin{mathpar}
\inferrule{\gvtyp{\Phi,x:\gvdual{S}}{M}{\outterm} \\
           un(\Phi)}
          {\gvtyp{\Phi}{\gvserve{x}{M}}{\gvservice{S}}}

\inferrule{\gvtyp{\Phi}{M}{\gvservice{S}}}
          {\gvtyp{\Phi}{\gvrequest{M}}{S}}
\end{mathpar}
Recursive session rules
\begin{mathpar}
\inferrule{\gvtyp{\Phi}{M}{G(\mu G)}}
          {\gvtyp{\Phi}{M}{\mu G}}

\inferrule{\gvtyp{\Phi}{M}{\mu G}}
          {\gvtyp{\Phi}{M}{G (\mu G)}}

%% \inferrule{\gvtyp{\Phi}{M}{G(\nu G)}}
%%           {\gvtyp{\Phi}{M}{\nu G}}
%%
%% \inferrule{\gvtyp{\Phi}{M}{\nu G}}
%%           {\gvtyp{\Phi}{M}{G(\nu G)}}
%%
\inferrule{\gvtyp{f:X \uto \vec{T} \lto \outterm, c:G(X), \vec{x}:\vec{T}}{M}{\outterm}}
          {\gvtyp{}{\gvfix{f}{c\:\vec{x}}{M}}{\nu G \uto \vec{T} \lto \outterm}}
\end{mathpar}

%% \todo{add definition of $un$ to this figure?}

\caption{Typing Rules for \mugv}\label{fig:gv-typing}
\end{figure}

Figure~\ref{fig:gv-typing} gives the typing rules of \mugv. The structural rules account for
variables, and for weakening and contraction on variables of unlimited type. The rules for the
functional terms are standard; note that, to account for linearity, the context is split in the
rules for application and pair introduction and elimination, and is limited to unlimited types in
the introduction of unlimited arrows.

The session rules for input, output, choice and selection are standard. Following our earlier
work~\citep{LindleyM14}, we provide a term $\gvlink{M}{N}$ to implement channel forwarding; while a
version of \tkwd{link} exists for any session type $S$, it has no generic implementation in terms of
other constructs of \mugv. The \tkwd{fork} construct provides session initiation; like Wadler's GV,
but unlike LAST (and much other work on process calculi), our system is deterministic.

Channels of type $\gvservice{S}$ offer arbitrarily many sessions of type $S$; correspondingly,
channels of type $\gvserver{S}$ must consume arbitrarily many $S$ sessions. (These types correspond
to the exponential propositions in linear logic; we have chosen the syntax $\gvserver{S}$ and
$\gvservice{S}$ as $?!$ are already used for input and output.)  The rule for $\gvserve{x}{M}$
parallels that for $\tkwd{fork}$: it defines the server (which replicates $M$) and returns the
channel by which it may be used (of type $\gvdual{\gvserver{S}} = \gvservice{\gvdual{S}}$).

The novelty of \mugv is in its recursive and corecursive channels. The first four typing rules allow
recursive and corecursive session types to be used as their unfoldings, and vice versa. Previous
work on recursive sessions has typically included an equivalence relation on types, taking unfolding
into account, and interpretting typing rules up to equivalence. We present explicit rules in order
to simplify the translation into \mucp, where these rules correspond to explicit terms implementing
the equivalences.
%
The fixed point construct $\gvfix{f}{c\,\vec{x}}{M}$ is used to define corecursive sessions. We
illustrate its use in the rest of this section through a selection of basic examples.

\paragraph{Syntactic Sugar.}

For multi-argument functions, we write:
\[
\small
  \bl
  (T_1, \dots, T_n) \lto U \equiv T_1 \lto \dots \lto T_n \lto U \\
  \langle T_1, T_2, \dots, T_n \rangle \uto U \equiv T_1 \uto T_2 \lto \dots \lto T_n \lto U \\
  \el
\]
Note that the right-hand side of the second equation is isomorphic to $(T_1 \otimes \dots \otimes
T_n) \uto U$.
%
For let binding, we write:
\[
\small
\key{let}\:x=M\:\key{in}\:N \equiv (\lambda x.M)\:N
\]

\paragraph{Base Types.}

For the purposes of our examples, we assume our term language has been extended with natural number
($Nat$) and Boolean ($Bool$) base types along with constants ($0,1,\dots$),
addition ($+$) and multiplication ($\times$), boolean constants ($True, False$), and conditionals
($\gvifthen{M}{N}{N'}$).
%
%% This does not change the expressivity of \mugv---we could encode each of these constructs using
%% processes, along the lines illustrated later for \mucp~\secref{peano}---but does significantly
%% streamline the presentation.

\subsection{Streams}

A canonical example of a corecursive data type is a stream. Let us consider a session type for
producing a stream of naturals.
%
\[\small
Source = \nu X.\with \{\clabel{next}: !Nat.X, \clabel{stop}: \outterm \}
\]
%
A channel of type $Source$ can either produce the next number or stop. The dual of a source is a
sink.
\[\small
Sink = \mu X.\oplus \{\clabel{next}: ?Nat.X, \clabel{stop}: \interm \}
\]

Let us define a helper macro for generating the next value in a stream:
\[\small
\bl
SendNext : \langle \with \{\clabel{next}: !Nat.X, \clabel{stop}: \outterm \}, Nat \rangle \uto \outterm \\
SendNext\:c\:v = \gvcase{c}{\clabel{next}\,c.\gvlet{c}{\gvsend{v}{c}}{f\:c};
                            \clabel{stop}\,c.c}
\el
\]
%
Using $\cofix$ we can define a function that outputs a stream of zeros along a corecursive
channel:
\[\small
  \bl
  MakeZeros : Source \uto \outterm \\
  MakeZeros = \cofix\:f\:c = SendNext\:c\:0
  \el
\]
If the next number is chosen, then a zero is sent along the channel and we recurse. Otherwise we
stop.
%
To read from a source, we can use $\key{fork}$ to create a sink:
\[\small
\gvfork{c}{MakeZeros\:c}
\]
%
First we define a helper macro:
\[\small
\bl
GetNext : Sink \uto Nat \otimes Sink \\
GetNext\:c = \gvreceive{(\gvselect{\clabel{next}}{c})} \\
\el
\]
and now:
\[\small
\bl
\key{let}\:c = \gvfork{c}{MakeZeros\:c}\:\key{in} \\
\key{let}\:(x, c) = GetNext\:c\:\key{in}\:
\key{let}\:(y, c) = GetNext\:c\:\key{in}\:
\key{let}\:(z, c) = GetNext\:c\:\key{in} \\
\key{let}\:c = \gvselect{\clabel{stop}}{c}\:\key{in}\:(x, (y, z)) \\
\el
\]
returns $(0, (0, 0))$.

\paragraph{Simulating Weakening.}
We might expect to be able to use the session type $\nu X.!Nat.X$ for streams. This does not work in
a linear setting because in order to read from the stream we would need to use the dual session type
$\mu X.?Nat.X$. We cannot write a program that uses this session type because it would have to
consume an infinite amount of data in order to satisfy linearity. In essence, the $\clabel{stop}$
case allows us to simulate weakening on such a channel.

\paragraph{Productivity.}
We might expect to assign $c$ the type $\with \{\clabel{next}: !Nat.Source, \clabel{stop}: \outterm
\}$ in the body of $MakeZeros$, but then productivity would not be assured. For example, under the
same typing assumptions for $f$ and $c$ we could write:
\[\small
\cofix\:f\:c = f\:c
\]
%
We restrict the typing rule for $\cofix$ in order to guarantee productivity. We use a fresh type
variable $X$ to abstract the recursive behavior, so the channel $c$ has type $G(X)$ (in our example
$\with \{\clabel{next}: !Nat.X, \clabel{stop}: \outterm \}$) instead of $G(\nu G)$, and $f$ has type
$X \uto \outterm$ instead of $\nu G \uto \outterm$. The body of $\cofix$ is thus required to provide
precisely one iteration of the recursive behavior.

\paragraph{Coinvariants.}

We allow recursive sessions to maintain internal state (a \emph{coinvariant}). In the $\cofix$
typing rule, this is captured by the additional arguments $\vec{x}$. For example, we can construct a
stream of consecutive naturals:
\[\small
\bl
  MakeNats : Source \uto \outterm \\
  MakeNats = \gvfix{nats}{c\:x}{SendNext\:c\:(x + 1)} \\
\el
\]
The variable $x$ tracks the next value to send to the stream, and is accordingly incremented in the
recursive call. Now, the following:
\[\small
\bl
\key{let}\:c = \gvfork{c}{MakeNats\:c\:0\:1}\:\key{in} \\
\key{let}\:(x, c) = GetNext\:c\:\key{in}\:
\key{let}\:(y, c) = GetNext\:c\:\key{in}\:
\key{let}\:(z, c) = GetNext\:c\:\key{in} \\
\key{let}\:c = \gvselect{\clabel{stop}}{c}\:\key{in}\:(x,(y,z)) \\
\el
\]
returns $(0, (1, 2))$.
%
We can maintain coinvariants of arbitrary complexity; for example, we can define a
stream of the Fibonacci numbers as follows:
\[\small
\bl
  MakeFibs : Source \uto \outterm \\
  MakeFibs = \gvfix{fibs}{c\:m\:n}{SendNext\:c\:(m + n)} \\
\el
\]

\subsection{Multi-function calculator}

Our next example is a simple multi-function calculator. Our goal is to provide a session that
accepts an arbitrary stream of addition and multiplication requests, and can at any time provide the
accumulated result.  We can implement the provider of this session as follows:

\[\small
\bl
MakeCalc : \langle Nat, Calc \rangle \uto \outterm \\
MakeCalc = \lrkwd\:calc\:accum\:c = \\
\quad
  \bl
  \mkwd{case}\:c\;\mkwd{of}\:\{
    \bl
    \clabel{add}\:c.
      \bl
      \mkwd{let}\:(x,c) = \gvreceive{c} \: \mkwd{in}\:
      calc\:(accum + x)\:c \\
      \el \\
    \clabel{mul}\:c.
      \bl
      \mkwd{let}\:(x,c) = \gvreceive{c}\:\mkwd{in}\:
      calc\:(accum \times x)\:c \\
      \el \\
    \clabel{result}\:c.
      \bl
      \mkwd{let}\:c = \gvsend{accum}{c}\:\mkwd{in}\:
      calc\:accum\:c \\
      \el \\
    \clabel{stop}\:c.c \; \}
    \el \\
  \el \\
\el
\]
In this case, the type of the recursive channel is
\[\small
 Calc = \nu X. \with \{ \clabel{add}: \gvin{Nat}{X},
                        \clabel{mul}: \gvin{Nat}{X},
                        \clabel{result}: \gvout{Nat}{X},
                        \clabel{stop}: \outterm \}.
\]%
Here is a consumer of the service:
\[\small
\bl
  \gvlet{c}{\gvfork{c}{MakeCalc\:0\:c}}{} \\
  \gvlet{c}{\gvsend{6}{(\gvselect{\clabel{add}}{c})}}{
  \gvlet{c}{\gvsend{7}{(\gvselect{\clabel{mul}}{c})}}{}} \\
  \gvlet{(x,c)}{\gvreceive{(\gvselect{\clabel{result}}{c})}}{
  \gvlet{c}{\gvselect{\clabel{stop}}{c}}{x}}
\el
\]
We begin by constructing an instance of the calculator with the accumulator starting at 0; in the
body of \tkwd{fork}, $c$ has the $\nu$-type given above, so the result of \tkwd{fork} (called
$c$), has type:
\[\small
\mu X. \oplus \{ \clabel{add}: \gvout{Nat}{X}, \clabel{mul}: \gvout{Nat}{X}, \clabel{result}: \gvin{Nat}{X}, \clabel{stop}: \interm \}.
\]
We perform several calculations, adding 6 to the accumulator and multiplying by 7.  Finally, we
obtain the result (42) and close the channel.

\subsection{Bit Strings}
%
%\todo{Validating the translation requires extending the GV interpreter with Booleans, addition and
%  multiplication.}

We now adapt an example of \citet{Toninho13}, in which a string of bits (0 or 1) is represented by a
chain of processes, each storing one bit. The chain supports operations to increment and retrieve
the stored value as a natural encoded by the bit string. Each link in the chain functions as a
one-bit adder.

We begin with the type $Link$ of the links in the chain. Each is a recursive process supporting
three operations: compute the natural value encoded by the chain, increment the chain, and dispose
of the chain.
%
\[\small
 Link = \nu X. \with \{ \clabel{val}: \gvin{Nat}{\gvout{Nat}{X}},
                        \clabel{inc}: \oplus \{ \clabel{carry}: X,
                                                \clabel{done}: X \},
                        \clabel{stop}: \outterm \}
\]
Choosing $\clabel{val}$ or $\clabel{inc}$ cascades down the chain from most- to least-significant
bit. The former returns the computed value; the latter returns the carry bit.

The simplest node is the terminator $Epsilon$. It adds nothing to the value, and cannot store a
responds to increment requests with a carry.
\[\small
\bl
Epsilon : Link \to \outterm \\
Epsilon = \lrkwd\:epsilon\:c = \\
\quad \mkwd{case}\:c\:\mkwd{of}\:\{
  \bl
  \clabel{val}\:c.
    \bl
    \gvlet{(n,c)}{\gvreceive{c}}{
    \gvlet{c}{\gvsend{n}{c}}{
    epsilon\:c}} \\
    \el \\
  \clabel{inc}\:c.
    \bl
    \gvlet{c}{\gvselect{\clabel{carry}}{c}}{
    epsilon\:c} \\
    \el \\
  \clabel{stop}\:c. c\}  \\
  \el \\
\el
\]

We can now define internal nodes. In response to a value request, an internal node adds its value to
the value accumulated so far, and passes the result to the next node in the chain; the response is
passed up the chain unchanged. In response to an increment request, the bit flips, passing on a
carry option if needed. Internal nodes require two state components: the represented bit ($b$) and
the remainder of the chain ($d$).
%
\[\small
\bl
Node : \langle Bool, \gvdual{Link}, Link \rangle \uto \outterm \\
Node = \lrkwd\:node\:b\:d\:c = \\
\quad
  \bl
  \mkwd{case}\:c\:\mkwd{of}\:\{
      \bl
      \clabel{val}\:c.
        \bl
        \gvlet{(m,c)}{\gvreceive{c}}{} \\
        \gvlet{d}{\gvsend{(\gvifthen{b}{2 \times m + 1}{2 \times m})}{(\gvselect{\clabel{val}}{d})}}{} \\
        \gvlet{(n,d)}{\gvreceive{d}}{
        \gvlet{c}{\gvsend{n}{c}}{
        node\:b\:d\:c}} \\
        \el \\
      \clabel{inc}\:c.
        \bl
        \mkwd{case}\:(\gvselect{\clabel{inc}}{d})\:\mkwd{of}\:\{ \\
        \quad
          \bl
          \clabel{done}\:d. node\:b\:d\:(\gvselect{\clabel{done}}{c}) \\
          \clabel{carry}\:d.
            \bl
            \gvlet{c}{\gvifthen{b}{\gvselect{\clabel{carry}}{c}}{\gvselect{\clabel{done}}{c}}}{} \\
            node\:(not\:b)\:d\:c \} \\
            \el \\
          \el \\
        \el \\
      \clabel{stop}\:c. \gvlet{d}{\gvselect{\clabel{stop}}{d}}{c} \} \\
      \el \\
  \el \\
\el
\]

Now we can define the top level interface to a bit string. The interface supports the same three
operations as the links---increment, retrieve value, and disposal---but with simpler behavior:
\[\small
  Count = \nu X. \with \{ \clabel{val}: \gvout{Nat}{X}, \clabel{inc}: X, \clabel{stop}: \outterm \}
\]
Value retrieval outputs the value of the string, increment increases the stored value by one, and
stopping closes the channel. The implementation requires one state component, the first link of the
chain (called $d$).
\[\small
\bl
CounterImpl : \langle \gvdual{Link}, Count \rangle \uto \outterm \\
CounterImpl = \lrkwd\:counterImpl\:d\:c = \\
\quad \mkwd{case}\:c\:\mkwd{of}\:\{
  \bl
  \clabel{val}\:c.
     \bl
     \gvlet{(n,d)}{\gvreceive{(\gvsend{0}{(\gvselect{\clabel{val}}{d})})}}
     {counterImpl\:d\:(\gvsend{n}{c})} \\
     \el \\
  \clabel{inc}\:c.
    \bl
    \mkwd{case}\:\gvselect{\clabel{inc}}{d}\:\mkwd{of}\:\{ \\
    \quad
      \bl
      \clabel{carry}\:d.
         \bl
         \gvlet{e}{\gvfork{e}{Node\:True\:d\:e}}{
         counterImpl\:e\:c} \\
         \el \\
      \clabel{done}\:d.counterImpl\:d\:c\:\} \\
      \el \\
    \el \\
  \clabel{stop}\:c.\gvlet{d}{\gvselect{\clabel{stop}}{d}}{c}\:\}
  \el \\
\el
\]
The value case uses the value behavior of the links, providing the initial value 0.  The increment
option adds a new link to the chain if incrementing the existing chain requires
carrying. $CounterImpl$ takes an initial chain as an argument. For a counter, we initialise this to
the empty chain encoding $0$:
\[\small\bl
  Counter : Count \uto \outterm \\
  Counter = \lambda c.CounterImpl\:(\gvfork{x}{Epsilon\:x})\:c \\
\el\]
Here is a simple example of using the counter:
\[\small
\bl
\gvlet{ctr}{\gvfork{c}{Counter\:c}}{} \\
\gvlet{(i,ctr)}{\gvreceive{(\gvselect{\clabel{val}}{ctr})}}{} \\
\gvlet{(j,ctr)}{\gvreceive{(\gvselect{\clabel{val}}{(\gvselect{\clabel{inc}}{ctr})})}}{} \\
\gvlet{(k,ctr)}{\gvreceive{(\gvselect{\clabel{val}}{(\gvselect{\clabel{inc}}{(\gvselect{\clabel{inc}}{ctr})})})}}{} \\
\gvlet{ctr}{\gvselect{\clabel{stop}}{ctr}}{(i,j,k)}
\el
\]
We begin by creating a new counter on channel $ctr$; we then perform a mixture of increment and
value operations before closing the $ctr$ channel.  The whole expression evaluates to $(0,1,3)$.


\section{A Linear Logic-Based Process Calculus}\label{sec:mucp}

\subsection{Types and Terms}

The types of \mucp are the propositions of CLL, extended with type operators $F$ and fixed points
$\mu F,\nu F$.
\[\small\begin{array}{l@{\hspace{2mm}}r@{\hspace{2mm}}c@{\hspace{2mm}}l}
  \text{Types} & A,B & ::= & A \otimes B \mid A \parr B \mid \bot \mid 1 \mid A \oplus B \mid A \with B \mid 0 \mid \top \\
   & & \mid & \cpbang{A} \mid \cpquery{A} \mid X \mid \cpdual{X} \mid \mu F \mid \nu F \\
   \text{Type operators} & F & ::= & X.A %\\
\end{array}\]
If $F = X.A$, define $F(B) = A[B/X]$.  The standard notion of CLL duality is extended to fixed
points in the expected fashion:
\begin{align*}
  \cpdual{(A \otimes B)} &= \cpdual{A} \parr \cpdual{B} & \cpdual{1} &= \bot &
    \cpdual{(A \oplus B)} &= \cpdual{A} \with \cpdual{B} & \cpdual{\top} &= 0 \\
  \cpdual{(A \parr B)} &= \cpdual{A} \otimes \cpdual{B} & \cpdual{\bot} &= 1 &
    \cpdual{(A \with B)} &= \cpdual{A} \oplus \cpdual{B} & \cpdual{0} &= \top \\
  \cpdual{(\cpbang{A})} &= \cpquery{\cpdual{A}} & \cpdual{(\cpquery{A})} &= \cpbang{\cpdual{A}} &
     \cpdual{(\nu F)} &= \mu \cpdual{F} & \cpdual{(\mu F)} &= \nu \cpdual{F}
\end{align*}
where $X^{\perp\perp}  = X$, and we define the dual of a type operator by $\cpdual{F} =
X.\cpdual{(F(\cpdual{X}))}.$ Note that, as for type operators in \mugv, $\cpdual{F(A)} =
\cpdual{F}(\cpdual{A})$.

\begin{figure}[t]
\scriptsize
\begin{mathpar}
\inferrule{ }{\cptyp{\link{x}{y}}{x:A,y:\cpdual{A}}}

\inferrule{\cptyp{P}{\Gamma,x:A} \\
           \cptyp{Q}{x:\cpdual{A},\Delta}}
          {\cptyp{\cut{x}{A}{P}{Q}}{\Gamma,\Delta}}

\inferrule{ }{\cptyp{x[].0}{x:1}}

\inferrule{\cptyp{P}{y:A,x:B,\Gamma}}
          {\cptyp{x(y).P}{x:A \parr B,\Gamma}}

\inferrule{\cptyp{P}{y:A,\Gamma} \\
           \cptyp{Q}{x:B,\Delta}}
          {\cptyp{x[y].(P \mid Q)}{x:A \otimes B,\Gamma,\Delta}}

\inferrule{\cptyp{P}{\Gamma}}
          {\cptyp{x().P}{x:\bot,\Gamma}}

\inferrule{\cptyp{P}{x:A,\Gamma}}
          {\cptyp{\sel{x}{inl}.P}{x:A \oplus B,\Gamma}}

\inferrule{\cptyp{P}{x:A,\Gamma} \\
           \cptyp{Q}{x:B,\Gamma}}
          {\cptyp{\case{x}{P;Q}}{x:A \with B,\Gamma}}

\inferrule{ }{\cptyp{\case{x}{}}{x:\top,\Gamma}}

\inferrule{\cptyp{P}{\Gamma}}{\cptyp{P}{x:\cpquery{A},\Gamma}}

\inferrule{\cptyp{P}{y:A,\Gamma}}{\cptyp{\derelict{x}{y}.P}{x:\cpquery{A},\Gamma}}

\inferrule{\cptyp{P}{x:\cpquery{A},x':\cpquery{A},\Gamma}}{\cptyp{P[x/x']}{x:\cpquery{A},\Gamma}}

\inferrule{\cptyp{P}{y:A,\cpquery{\Gamma}}}{\cptyp{\replicate{x}{y}.P}{x:\cpbang{A}, \Gamma}}


\inferrule{\cptyp{P}{x:F(\mu F), \Gamma}}
          {\cptyp{\rec{x}.P}{x:\mu F,\Gamma}}

\inferrule{\cptyp{P}{y:A,\Gamma} \\
           \cptyp{Q}{y:\cpdual{A},x:F(A)}}
          {\cptyp{\corec{x}{y}{A}{P}{Q}}{x:\nu F,\Gamma}}
\end{mathpar}
\caption{Typing Rules for \mucp}\label{fig:cp-typing}
\end{figure}

\paragraph{Structural Rules.}

\mucp has two structural rules, axiom and cut.  We interpret the axiom $\link{x}{y}$ as channel
forwarding: actions on channel $x$ are mirrored on $y$, and vice versa.  Thus, $x$ and $y$ must have
dual type.  Cut $\cut{x}{A}{P}{Q}$ is interpreted as commuication between processes $P$ and $Q$ on
channel $x$; the duality of the typing of $x$ assures that the uses of the $x$ in $P$ and $Q$ are
compatible.  Figure~\ref{fig:equivalences} gives the structural equivalences of \mucp terms.  The
first two capture that cut is commutative and associative, while the last captures that a cut
against a use of the axiom rule provides channel substitution (we write $P[x/y]$ for the substution
of channel $y$ for channel $x$ in process $P$).

\begin{figure}
\scriptsize
\begin{equations}
  \cut{x}{A}{P}{Q} &\equiv& \cut{x}{\cpdual{A}}{Q}{P} \\
  \cut{x}{A}{P}{\cut{y}{B}{Q}{R}} &\equiv& \cut{y}{B}{\cut{x}{A}{P}{Q}}{R}, \quad \text{if $x \not\in fn(R)$} \\
  \cut{x}{A}{P}{\link{x}{y}} &\equiv& P[y/x] \\
\end{equations}
\caption{Structural Equivalences}\label{fig:equivalences}
\end{figure}

\paragraph{Input and Output.}

The multiplicative connectives $\otimes$ and $\parr$ are interpreted as input and output. The
process $x(y).P$ inputs channel $y$ on channel $x$, and continues as $P$. The process $x[y].(P \mid
Q)$ is interpreted as bound output: it outputs a fresh channel $y$ along $x$, spawns a process $P$
in which $y$ is used, and continues as process $Q$ in which $x$ is used. In $\pi$-calculus it
amounts to $\nu y.\overline{x}(y).(P \mid Q)$. The units of $\otimes$ and $\parr$, $1$ and $\bot$
are interpreted as nullary output and nullary input, respectively.

\paragraph{Selection and Choice.}

The additive connectives $\oplus$ and $\with$ are interpreted as selection and choice. The process
$\case{x}{P;Q}$ offers a choice of processes $P$ and $Q$; dually, the process $\sel{x}{inl}.P$
chooses the left alternative, and the process $\sel{x}{inr}.P$ chooses the right.  The unit for
choice is $0$, indicating absurdity. Note that there is no term proving $0$.  The dual of absurdity
is $\top$, and provides arbitrary behavior; as there is no term proving $0$, no term relying on
$\top$ can reduce.

\paragraph{Replication and Dereliction.}

The exponential connectives $!$ and $?$ in linear logic provide limited access to the classical
rules of weakening and contraction.  We interpret them as providing replicated processes: a process
with type $\cpbang{A}$ provides arbitrarily copies of a process providing behavior $A$, while a
process of type $\cpquery{A}$ can choose to use one, many, or none of those copies.  There are three
rules for types $\cpquery{A}$; note that, in contrast to the other typing rules of \mucp, we leave
uses of weakening and contraction implicit.  Finally, since the process proving $\cpbang{A}$ may be
replicated arbitrarily, each channel that process uses must be replicatable as well.  This is
captured by requiring that each be of type $\cpquery{B}$ for some $B$.

\paragraph{Recursion and Corecursion.}

We introduce least fixed points $\mu F$ and greatest fixed points $\mu F$ to CP, following Baelde's
proof theoretic treatment of fixed points in linear logic~\citep{Baelde12}.  The proof rules can be
understood from traditional two-sided rules for least and greated fixed points, combined with the
duality between the fixed points.  We begin with a two-sided presentation:
\begin{mathpar}
\inferrule{F(A) \vdash A \\ \Gamma, A \vdash B}{\Gamma, \mu F \vdash B}

\inferrule{\Gamma \vdash F (\mu F)}{\Gamma \vdash \mu F}

\inferrule{\Gamma, F (\nu F) \vdash B}{\Gamma, \nu F \vdash B}

\inferrule{A \vdash F(A) \\ \Gamma \vdash A}{\Gamma \vdash \nu F}
\end{mathpar}
Functional programmers may recognize the first as the typing rule of a fold, and the fourth as the
typing rule of an unfold. We can translate this to a one sided presentation, as follows.  (As
$\Gamma$ denotes any context, we write $\Gamma$ instead of $\cpdual{\Gamma}$).
\begin{mathpar}
\inferrule{\vdash \cpdual{F}(\cpdual{A}),A \\ \vdash \Gamma,\cpdual{A},B}{\vdash \Gamma,\nu \cpdual{F},B}

\inferrule{\vdash \Gamma, F (\mu F)}{\vdash \Gamma, \mu F}
\\
\inferrule{\vdash \Gamma, \cpdual{F}(\mu \cpdual{F}), B}{\vdash \Gamma, \mu \cpdual{F}, B}

\inferrule{\vdash \cpdual{A}, F(A) \\ \vdash \Gamma, A}{\vdash \Gamma, \nu F}
\end{mathpar}
However, now we can observe that $\Gamma,B$ is itself an instance of a context, and $\cpdual{F}$ a
type operator, and so the four rules above are just two instances each of the two rules below.
\begin{mathpar}
\inferrule{\vdash \Gamma, F (\mu F)}{\vdash \Gamma, \mu F}

\inferrule{\vdash \cpdual{A}, F(A) \\ \vdash \Gamma, A}{\vdash \Gamma, \nu F}
\end{mathpar}
These are the typing rules for the \mucp terms $\rec{x}.P$ and $\corec{x}{y}{}{P}{Q}$.  As in \mugv,
\tkwd{corec} terms maintain a coinvariant of type $A$.

\subsection{Cut Elimination}

\begin{figure}
\tiny
\begin{multline*}
\inferrule
  {\inferrule*
     {\cptyp{P}{y:A,\Gamma} \\
      \cptyp{Q}{x:B,\Gamma'}}
     {\cptyp{x[y].(P \mid Q)}{x: A \otimes B,\Gamma,\Gamma'}} \\
   \inferrule*
     {\cptyp{R}{x:\cpdual{B},y:\cpdual{A},\Delta}}
     {\cptyp{x(y).R}{x:\cpdual{A} \parr \cpdual{B},\Delta}}}
  {\cptyp{\cut{x}{A \otimes B}{x[y].(P \mid Q)}{x(y).R}}{\Gamma,\Gamma',\Delta}}
\Longrightarrow \\
\inferrule
  {\cptyp{Q}{y:A,\Gamma} \\
   \inferrule*
     {\cptyp{P}{x:B,\Gamma'} \\
      \cptyp{R}{x:\cpdual{B},y:\cpdual{A},\Delta}}
     {{\cptyp{\cut{x}{B}{P}{R}}{y:\cpdual{A},\Gamma',\Delta}}}}
  {\cptyp{\cut{y}{A}{Q}{\cut{x}{B}{P}{R}}}{\Gamma,\Gamma',\Delta}}
\end{multline*}
\[
\inferrule
  {\inferrule*
     { }{\cptyp{x[].0}{x:1}} \\
   \inferrule*
     {\cptyp{P}{\Gamma}}
     {\cptyp{x().P}{x:\bot,\Gamma}}}
  {\cptyp{\cut{x}{1}{x[].0}{x().P}}{\Gamma}}
\Longrightarrow
\cptyp{P}{\Gamma}
\]
\begin{multline*}
\inferrule
  {\inferrule*
     {\cptyp{P}{x:A,\Gamma}}
     {\cptyp{\sel{x}{inl}.P}{x:A \oplus B, \Gamma}} \\
   \inferrule*
     {\cptyp{Q}{x:\cpdual{A},\Delta} \\
      \cptyp{R}{x:\cpdual{B},\Delta}}
     {\cptyp{\case{x}{Q;R}}{x:\cpdual{A} \with \cpdual{B},\Delta}}}
  {\cptyp{\cut{x}{A \oplus B}{\sel{x}{inl}.P}{\case{x}{Q;R}}}{\Gamma,\Delta}}
\Longrightarrow \\
\inferrule
  {\cptyp{P}{x:A,\Gamma} \\
   \cptyp{Q}{x:\cpdual{A},\Delta}}
  {\cptyp{\cut{x}{A}{P}{Q}}{\Gamma,\Delta}}
\end{multline*}
\[
\inferrule
  {\inferrule*
     {\cptyp{P}{y:A,\cpquery{\Gamma}}}
     {\cptyp{\replicate{x}{y}.P}{x:\cpbang{A},\Gamma}} \\
   \inferrule*
     {\cptyp{Q}{y:\cpdual{A},\Delta}}
     {\cptyp{\derelict{x}{y}.Q}{x:\cpquery{\cpdual{A}},\Delta}}}
  {\cptyp{\cut{x}{\cpbang{A}}{\replicate{x}{y}.P}{\derelict{x}{y}.Q}}{\Gamma,\Delta}}
\Longrightarrow
\inferrule
  {\cptyp{P}{x:A,\Gamma} \\
   \cptyp{Q}{y:\cpdual{A},\Delta}}
  {\cptyp{\cut{y}{A}{P}{Q}}{\Gamma,\Delta}}
\]
\[
\inferrule
  {\inferrule*
     {\cptyp{P}{y:A,?\Gamma}}
     {\cptyp{\replicate{x}{y}.P}{x:\cpbang{A},\Gamma}} \\
   \inferrule*
     {\cptyp{Q}{\Delta} \\ un(\cpquery{\cpdual{A}})}
     {\cptyp{Q}{y:\cpquery{\cpdual{A}}}}}
  {\cptyp{\cut{y}{\cpbang{A}}{\replicate{x}{y}.P}{Q}}{\Gamma,\Delta}}
\Longrightarrow
\inferrule
  {\cptyp{Q}{\Delta}}
  {\cptyp{Q}{\Gamma,\Delta}}
\]
\begin{multline*}
\inferrule
  {\inferrule*
     {\cptyp{P}{y:A,\cpquery{\Gamma}}}
     {\cptyp{\replicate{x}{y}.P}{x:\cpbang{A},\Gamma}} \\
   \inferrule*
     {\cptyp{Q}{x:\cpquery{\cpdual{A}},x':\cpquery{\cpdual{A}},\Delta}}
     {\cptyp{Q[x/x']}{x:\cpquery{\cpdual{A}},\Delta}}}
  {\cptyp{\cut{x}{\cpbang{A}}{\replicate{x}{y}.P}{Q[x/x']}}{\Gamma,\Delta}}
\Longrightarrow \\
\inferrule
  {\inferrule*
     {\cptyp{P}{y:A,\cpquery{\Gamma}}}
     {\cptyp{\replicate{x}{y}.P}{x:\cpbang{A},\Gamma}} \\
   \inferrule*
     {\inferrule*
         {\cptyp{P}{y:A,\cpquery{\Gamma}}}
         {\cptyp{\replicate{x'}{y}.P}{x':\cpbang{A},\Gamma}} \\
      \cptyp{Q}{x:\cpquery{\cpdual{A}},x':\cpquery{\cpdual{A}},\Delta}}
     {\cptyp{\cut{x'}{\cpbang{A}}{\replicate{x'}{y}.P}{Q}}{\Gamma,\Delta}}}
  {\cptyp{\cut{x}{\cpbang{A}}{\replicate{x}{y}.P}{\cut{x'}{\cpbang{A}}{\replicate{x'}{y}.P}{Q}}}{\Gamma,\Delta}}
\end{multline*}
\[
\bl
\inferrule
  {\inferrule*
     {\cptyp{P}{y:B,\Gamma} \\
      \cptyp{Q}{y:\cpdual{B},x:F(B)}}
     {\cptyp{\corec{x}{y}{B}{P}{Q}}{x:\nu F,\Gamma}} \\
   \inferrule*
     {\cptyp{R}{x:\cpdual{F}(\mu (\cpdual{F})),\Delta}}
     {\cptyp{\rec{x}.R}{x:\mu (\cpdual{F}),\Delta}}}
  {\cptyp{\cut{x}{\nu F}{\corec{x}{y}{B}{P}{Q}}{\rec{x}.R}}{\Gamma,\Delta}}
\Longrightarrow \\
\inferrule
  {\cptyp{P}{y:B,\Gamma} \\
   \inferrule*
     {\cptyp{Q}{y:\cpdual{B},x:F(B)} \\
      \inferrule*
          {\cptyp{E}{x:\cpdual{F}(\cpdual{B}),z:F(\nu F)} \\\\
         \cptyp{R[z/x]}{z:\cpdual{F}(\mu \cpdual{F}),\Delta}}
        {\cptyp{\cut{z}{F(\nu F)}{E}{R[z/x]}}{x:\cpdual{F}(\cpdual{B}),\Delta}}}
     {\cptyp{\cut{x}{F(B)}{Q}{\cut{z}{F(\nu F)}{E}{R[z/x]}}}{y:\cpdual{B},\Delta}}}
  {\cptyp{\cut{y}{B}{P}{\cut{x}{F(B)}{Q}{\cut{z}{F(\nu F)}{E}{R[z/x]}}}}{\Gamma,\Delta}}
\el
\]
where $E = \map{F}{z,x}{\corec{z}{y}{B}{\link{x}{y}}{Q[z/x]}}$.

\caption{Principal cut elimination rules}\label{fig:beta-reduction}
\end{figure}

\begin{figure}\scriptsize
\begin{equations}
  \map{X.C}{x,w}{Q} &=& \link{x}{w} \\
  \map{X.X}{x,w}{Q} &=& Q \\
  \map{X.C_1 \otimes C_2}{x,w}{Q} &=& w(z).x[y].(\map{X.C_1}{y,z}{Q[y/x,z/w]} \mid \map{X.C_2}{x,w}{Q}) \\
  \map{X.C_1 \oplus C_2}{x,w}{Q} &=& \case{w}{\sel{x}{inl}.\map{X.C_1}{x,w}{Q}; \sel{x}{inr}.\map{X.C_2}{x,w}{Q}} \\
  \map{X.\cpquery{C}}{x,w}{Q} &=& \replicate{w}{w'}.\derelict{x}{x'}.Q[x'/x,w'/x] \\
  \map{X.\mu F'}{x,w}{Q} &=& \corec{w}{y}{\nu(\cpdual{C}(A))}{\link{x}{y}}{\rec{y}.\map{X.F' (\mu F')}{y,w}{Q[y/x]}}
\end{equations}
\caption{Definition of $\mapname$ for Positive Combinators.}\label{fig:map}
\end{figure}

Cut elimination corresponds to process reduction.  The principal cut reductions are given in
Fig.~\ref{fig:beta-reduction}. The majority of these are standard; for instance, cut reduction of
$\with$ against $\oplus$ corresponds to picking one of the offered alternatives.  Cut reduction for
fixed points corresponds to unrolling one iteration from the \tkwd{corec} term, directed by the type
of the fixed point operator $F$.  It depends on a proof construction known as functoriality, which
derives the following proof rule for any type operator $F$:
\[\small
\inferrule{\vdash A,B}{\vdash F(A),\cpdual{F}(B)}
\]
We call the term implementing this construction $\mapname$ by analogy with a similar construct in
functional programming: taking $C = \cpdual{B}$, the above proof rule gives a transformation from a
proof of $C \lto A$ to one of $F(C) \lto F(A)$.  The positive cases of $\mapname$ are given in
Fig.~\ref{fig:map}; the remaining cases can be obtained by exchanging channels $x$ and $w$.

\begin{lemma}
  If $\cptyp{Q}{x:A,w:B}$ then \(\cptyp{\map{F}{x,w}{Q}}{x:F(A), w:\cpdual{F}(B)}.\)
\end{lemma}

\begin{figure}
\scriptsize
\begin{equations}
  \cut{x}{A}{z(y).P}{Q} &\Longrightarrow& z(y).\cut{x}{A}{P}{Q} \\
  \cut{x}{A}{z[y].(P \mid Q)}{R} &\Longrightarrow& z[y].(\cut{x}{A}{P}{R} \mid Q) \text{\quad \quad if $x \not\in fn(Q)$} \\
  \cut{x}{A}{z[y].(P \mid Q)}{R} &\Longrightarrow& z[y].(P \mid \cut{x}{A}{Q}{R}) \text{\quad \quad if $x \not\in fn(P)$} \\
  \cut{x}{A}{\sel{z}{inl}.P}{Q} &\Longrightarrow& \sel{z}{inl}.\cut{x}{A}{P}{Q} \\
  \cut{x}{A}{\case{z}{P;Q}}{R} &\Longrightarrow& \case{z}{\cut{x}{A}{P}{R}; \cut{x}{A}{Q}{R}} \\
  \cut{x}{A}{\rec{z}.P}{Q} &\Longrightarrow& \rec{z}.\cut{x}{A}{P}{Q} \\
  \cut{x}{A}{\corec{z}{y}{B}{P}{Q}}{R} &\Longrightarrow& \corec{z}{y}{B}{\cut{x}{A}{P}{R}}{Q}
\end{equations}
\caption{Commuting Conversions}\label{fig:commuting}
\end{figure}

The commuting conversions push communication under process prefixes, and are given in
Fig.~\ref{fig:commuting}.  We can show that cut reduction preserves typing.

\begin{theorem}
  If $\cptyp{P}{\Gamma}$ and $P \Longrightarrow Q$, then $\cptyp{Q}{\Gamma}.$
\end{theorem}

Define $\Longrightarrow^\star$ to be the reflexive, transitive closure of $\equiv\Longrightarrow\equiv$.

\begin{theorem}\label{thm:cut-reduction}
  If $\cptyp{P}{\Gamma}$, then there is a $Q$ such that $P \Longrightarrow^\star Q$ and the bottom
  rule of $Q$ is not a cut.
\end{theorem}

Note that while we commute cuts under prefixes, we do not perform cut reduction under prefixes.
This corresponds to the usual notions of process communication.  Were we to extend our reduction
rules with congruences for each operator, we could then extend Theorem~\ref{thm:cut-reduction} to
show elimination of all cuts in a well-typed \mucp term.

\subsection{Streams}

We can use \mucp fixed points to encode streams of naturals, paralleling our similar development in
\mugv~\secref{mugv-types}: %. The encoding of the stream type is quite intuitive:
\begin{equations}
  Sink &=& \mu X. \oplus \{ \clabel{next}: Nat \parr X, \clabel{stop}: \bot \}, \\
  Source &=& \nu X. \with \{ \clabel{next}: Nat \otimes X, \clabel{stop}: 1 \} \\
\end{equations}%
where, as in \mugv, we assume that our language is extended with constants implementing unlimited
natural numbers. In particular, we will assume there is some proposition $Nat$ and terms:
\[\small\begin{eqs}
Zero_x &\vdash& x:\cpquery{Nat} \\
Inc_{y,x} &\vdash& y:\cpbang{\cpdual{Nat}},x:\cpquery{Nat}.
\end{eqs}\]
providing zero and successor.

%% Note that, following the typical treatment of duality in linear logic, we have that
%% $\cpdual{(Source(A))} = Sink(\cpdual{A})$.

We can define a process which generates a stream of zeros.  In this example, we make no use of the
coinvariant, and so choose the trivial proposition 1:
\[\small\begin{eqs}
  Zeros_y &\vdash& y:Stream(\cpquery{Nat}) \\
  Zeros_y &=& \corec{y}{z}{1}{z[].0}{z().\case{y}{\clabel{next}: y[x].(Zero_x | y[].0); \clabel{stop}: y[].0}}.
\end{eqs}\]
Next, we extend this example to a stream of naturals.  As in the corresponding \mugv example, we use
the coinvariant to track the next number to appear in the stream.
\[\small\begin{array}{r@{\hspace{2mm}}c@{\hspace{2mm}}l@{\hspace{0mm}}l@{\:}l}
  Nats_y & \vdash & \mcl{3}{y:Stream(\cpquery{Nat})} \\
  Nats_y & = & \mcl{3}{\lrkwd \: y \langle z \rangle (Zero_z,} \\
  & & \quad & \mkwd{case}\:y \:\{ & \clabel{next}: y[x].(\link{z}{x} \mid \cut{w}{}{Inc_{z,w}}{\link{w}{y}}); \\
  & & & & \clabel{stop}: y[].0\})
\end{array}\]
In the $\clabel{next}$ case, we rely on contraction to copy the coinvariant $z$. In the
$\clabel{stop}$ case, we rely on weakening for $\cpquery{Nat}$ to dispose of the coinvariant. We
then send one copy along the channel $y$, increment the other giving $w$, and re-establish the
coinvariant using $w$.

\section{Relating \mugv and \mucp}\label{sec:translation}

In our previous work~\citep{LindleyM14} we give translations back and forth between CP and HGV, an
extension of GV, corresponding to \mucp without recursive session types. In this section, we extend
these translations to incorporate recursive session types.

\subsection{Translation from \mugv to \gvpi}\label{sec:gvtogvpi}

Following our previous work~\citep{LindleyM14} we factor the
translation of \mugv into \mucp through an intermediate
translation. The language \gvpi is the restriction of \mugv to session
types, that is, \mugv without $\lto$, $\uto$, or $\otimes$. In order
to avoid $\otimes$, we disallow plain $\gvreceive{M}$, but do permit
it to be fused with a pair elimination $\gvlet{(x,
  y)}{\gvreceive{M}}{N}$. We can simulate all non-session types as
session types via a translation from \mugv to \gvpi.  The translation
on types is exactly as in our previous work. It is given by the
homomorphic extension of the following equations:
%\[
%\ba{@{}rclcl@{}}
%\topi{T \lto U}    &=& \gvdual{\gvin{\gvdual{\topi{T}}}{\topi{U}}}
%                   &=& \gvout{\topi{T}}{\gvdual{\topi{U}}} \\
%\topi{T \uto U}    &=& \gvdual{\gvserver{(\gvin{\topi{\gvdual{T}}}{\topi{U}})}}
%                   &=& \gvservice{(\gvout{\topi{T}}{\gvdual{\topi{U}}})} \\
%\topi{T \otimes U} &=& \gvdual{\gvout{\gvdual{T}}{\topi{U}}}
%                   &=& \gvin{\gvdual{\topi{T}}}{\gvdual{\topi{U}}} \\
%\ea
%\]
\[\small
\ba{@{}c@{}}
\topi{T \lto U} = \gvout{\topi{T}}{\topi{U}} \qquad
\topi{T \uto U} = \gvservice{(\gvout{\topi{T}}{\topi{U}})} \\
\topi{T \otimes U} = \gvin{\topi{T}}{\topi{U}} \\
\ea
\]
Each target type is the interface to the simulated source type. A
linear function is simulated by input on a channel; its interface is
output on the other end of the channel. An unlimited function is
simulated by a server; its interface is the service on the other end
of that channel. A tensor is simulated by output on a channel; its
interface is input on the other end of that channel. This duality
between implementation and interface explains the flipping of types in
Wadler's original CPS translation from GV to CP.

In order to translate away the arrows in the $\key{corec}$ rule, we
adopt a simplified session-oriented variant of the $\key{corec}$ rule
for \gvpi.
%
\begin{mathpar}
\inferrule{\gvtyp{p:\gvservice{(\gvout{X}{\gvout{T}{\outterm}})}, c:G(X), x:T}{M}{\outterm}}
          {\gvtyp{\Phi}{\gvfix{p}{c\,x}{M}}{\gvservice{(\gvout{T}{\gvout{\nu G}{\outterm}})}}}
\end{mathpar}
%
This rule takes advantage of the fact that we can always translate
away functions using the $\topi{-}$ translation, and we can simulate
multiple arguments using a tensor.

The full translation on terms is as follows.
\begin{equations}
\topi{\lambda x.M} &=& \gvfork{z}{\gvlet{(x, z)}{\gvreceive{z}}{\gvlink{\topi{M}}{z}}} \\
\topi{L\,M} &=& \gvsend{\topi{M}}{\topi{L}} \\
\topi{M, N} &=&
  \gvfork{z}
    {\gvlink{(\gvsend{\topi{M}}{z})}{\topi{N}}} \\
\topi{\gvlet{(x, y)}{M}{N}} &=&
    \gvlet{(x, y)}{\gvreceive{\topi{M}}}{\topi{N}} \\
\topi{L : T \uto U} &=&
  \gvserve{z}{\gvlink{\topi{L}}{z}} \\
\topi{L : T \lto U} &=& \gvrequest{\topi{L}} \\
\topi{\gvreceive{M}} &=& \topi{M}
\\[1ex]
\topi{\gvfix{f}{c\,\vec{x}}{M}} &=&
  \gvfix{p}{z\,c}{\gvlet{\vec{x}}{z}{\topi{M[L/f]}}} \\
&& \text{where }L = \lambda\,c\,\vec{x}.\gvsend{\vec{x}}{(\gvsend{c}{(\gvrequest{p})})} \\
\end{equations}%
Formally, this is a translation from derivations to terms. We write type annotations to indicate
$\to$ introduction and elimination. For all other cases, it is unambiguous to give the translation
on plain term syntax. Each introduction form translates to an interface $\gvfork{z}{M}$ of type
$\gvdual{S}$, where $M : \outterm$ provides the implementation, with $z : S$ bound in $M$.
%
The only new case is that for $\key{corec}$. We package up all of the arguments into a tuple, and
simulate the interface to the arrows using session operations in the obvious way dictated by the
rest of the $\topi{-}$ translation.

We can extend the translation on types to a translation on contexts:
\begin{equations}
\topi{x_1:T_1, \dots, x_n:T_n} &=& x_1:\topi{T_1}, \dots, x_n:\topi{T_n} \\
\end{equations}%
It is straightforward to verify that our translation preserves typing.
\begin{theorem}
If $\gvtyp{\Phi}{M}{T}$ then $\gvtyp{\topi{\Phi}}{\topi{M}}{\topi{T}}$.
\end{theorem}

\subsection{Translation from \gvpi to \mucp}\label{sec:gvpitocp}

We now give a translation from \gvpi to CP. Post composing this with the embedding of \mugv in \gvpi
yields a semantics for \mugv. The translation on session types is as follows:
\[\small
\ba{@{}c@{\qquad}c@{\qquad}c@{}}
\begin{eqs}
\tocp{\gvout{T}{S}}        &=& \cpdual{\tocp{T}} \otimes \tocp{S} \\
\tocp{\gvin{T}{S}}         &=& \tocp{T} \parr \tocp{S} \\
\tocp{\gvservice{S}}       &=& \cpquery{\tocp{S}} \\
\tocp{\gvserver{S}}        &=& \cpbang{\tocp{S}} \\
\end{eqs}
&
\begin{eqs}
\tocp{\oplus \{l_i:S_i \}} &=& \oplus \{l_i:\tocp{S_i}\} \\
\tocp{\with \{l_i:S_i \}}  &=& \with \{l_i:\tocp{S_i}\} \\
\tocp{\nu G}               &=& \nu\tocp{G} \\
\tocp{\mu G}               &=& \mu\tocp{G} \\
\end{eqs}
&
\begin{eqs}
\tocp{\outterm}            &=& 1 \\
\tocp{\interm}             &=& \bot \\
\tocp{X}                   &=& X \\
\tocp{\gvdual{X}}          &=& \cpdual{X} \\
\end{eqs}\\
& \tocp{X.S} = X.\tocp{S} & \\
\ea
\]
The translation is homomorphic except for output, where the output type is dualised. This accounts
for the discrepancy between $\gvdual{\gvout{T}{S}} = \gvin{T}{\gvdual{S}}$ and $\cpdual{(A \otimes
  B)} = \cpdual{A} \parr \cpdual{B}.$

The translation on terms is formally specified as a CPS translation on derivations as in Wadler's
presentation. We provide the full translations of weakening and contraction for $\interm$, and for
rolling and unrolling of recursive session types $\nu G$ and $\mu G$, as these steps are implicit in
the syntax of \mugv terms. The other constructs depend only on the immediate syntactic structure, so
we abbreviate their translations as mappings on plain terms. The majority of translations are as in
our previous work:

\begin{equations}
\small
\left\llbracket \inferrule{\gvtyp{\Phi}{N}{S}}{\gvtyp{\Phi,x:\interm}{N}{S}} \right\rrbracket\!\!z &=&
  \inferrule
    {\cptyp{\tocp{N}z}{\tocp{\Phi},z:\cpdual{\tocp{S}}}}
    {\cptyp{x().\tocp{N}z}{\tocp{\Phi},x:\bot,z:\cpdual{\tocp{S}}}}
\\[3ex]
\left\llbracket \inferrule{\gvtyp{\Phi,x:\interm,x':\interm}{N}{S}}
                          {\gvtyp{\Phi,x:\interm}{N[x/x']}{S}} \right\rrbracket \!\!z &=&
  \inferrule
    {\cptyp{\tocp{N}z}{\tocp{\Phi},x:\bot,x':\bot,z:\cpdual{\tocp{S}}}}
    {\cptyp{\cut{x'}{}{\tocp{N}z}{x'[].0}}{\tocp{\Phi},x:\bot,z:\cpdual{\tocp{S}}}}
\\[3ex]
\tocp{x}z &=& \link{x}{z} \\
\tocp{\gvsend{M}{N}}z &=& \cut{x}{}{x[y].(\tocp{M}y \mid \link{x}{z})}{\tocp{N}x} \\
\tocp{\gvlet{(x,y)}{\gvreceive{M}}{M}}z &=& \cut{y}{}{\tocp{M}y}{y(x).\tocp{N}z} \\
\tocp{\gvselect{l}{M}}z &=& \cut{x}{}{\tocp{M}x}{x[l].\link{x}{z}} \\
\tocp{\gvcase{M}{l_n\,x.N_i}}z &=&  \cut{x}{}{\tocp{M}x}{\case{x}{l_i.\tocp{N_i}z}} \\
\tocp{\gvfork{x}{M}}z &=& \cut{x}{}{\cut{y}{}{\tocp{M}y}{y[].0}}{\link{x}{z}} \\
\tocp{\gvlink{M}{N}}z &=& z().\cut{x}{}{\tocp{M}x}{\tocp{N}x} \\
\tocp{\gvserve{y}{M}}z &=& \replicate{z}{y}.\cut{x}{}{\tocp{M}x}{x[].0} \\
\tocp{\gvrequest{M}}z &=& \cut{x}{}{\tocp{M}x}{\derelict{x}{y}.\link{y}{z}} \\[3ex]
\end{equations}%
The folding and unfolding of least fixed points in GV can be translated to cuts against the CP
proofs of the corresponding equivalences; for example, unfolding the GV session type $\mu G$ to $G
(\mu G)$ corresponds to the CP proof that $\nu F \lto F(\mu F)$.
\begin{equations}
\small
\tocpbig{\inferrule{\gvtyp{\Phi}{M}{\mu G}}{\gvtyp{\Phi}{M}{G (\mu G)}}} z &=&
  \cut{y}{\nu \tocp{G}}{\tocp{\gvtyp{\Phi}{M}{\mu G}}y}{\rec{y}.\link{y}{z}} \\[3ex]
\tocpbig{\inferrule{\gvtyp{\Phi}{M}{G(\mu G)}}{\gvtyp{\Phi}{M}{\mu G}}} z &=&
\cut{y}{\tocp{G}(\mu \tocp{G})}{\tocp{\gvtyp{\Phi}{M}{G (\mu G)}}}
       {\corec{z}{x}{\tocp{G}(\mu \tocp{G})}
              {\link{y}{x}}
              {\map{G}{x,z}{\rec{x}.\link{x}{z}}}}
\end{equations}

%% The folding and unfolding of recursive session types in GV can be translated to cuts against the CP
%% proofs of the corresponding equivalences; for example, unfolding the GV session type $\mu G$ to $G
%% (\mu G)$ corresponds to the CP proof that $\nu F \lto F(\mu F)$. Note the parallels between the
%% first two and last two cases: this aligns with the derivation of the rules for $\mu$ and $\nu$ in
%% \mucp.
%% \begin{gather*}
%% \tocpbig{\inferrule{\gvtyp{\Phi}{M}{\mu G}}{\gvtyp{\Phi}{M}{G (\mu G)}}} z =
%%   \cut{y}{\nu \tocp{G}}{\tocp{\gvtyp{\Phi}{M}{\mu G}}y}{\rec{y}.\link{y}{z}} \\[3ex]
%% \tocpbig{\inferrule{\gvtyp{\Phi}{M}{G(\nu G)}}{\gvtyp{\Phi}{M}{\nu G}}} z =
%%   \cut{y}{\nu \tocp{G}}{\tocp{\gvtyp{\Phi}{M}{G(\nu G)}}y}{\rec{z}.\link{y}{z}} \\[3ex]
%% \tocpbig{\inferrule{\gvtyp{\Phi}{M}{G(\mu G)}}{\gvtyp{\Phi}{M}{\mu G}}} z =
%% \cut{y}{\tocp{G}(\mu \tocp{G})}{\tocp{\gvtyp{\Phi}{M}{G (\mu G)}}}
%%        {\corec{z}{x}{\tocp{G}(\mu \tocp{G})}
%%               {\link{y}{x}}
%%               {\map{G}{x,z}{\rec{x}.\link{x}{z}}}}
%% \\[3ex]
%% \tocpbig{\inferrule{\gvtyp{\Phi}{M}{\nu G}}{\gvtyp{\Phi}{M}{G (\nu G)}}} z =
%% \cut{y}{\mu \tocp{G}}{\tocp{\gvtyp{\Phi}{M}{\nu G}}}
%%        {\corec{y}{x}{\cpdual{\tocp{G}}(\nu \cpdual{\tocp{G}})}
%%               {\link{z}{x}}
%%               {\map{G}{x,y}{\rec{x}.\link{x}{y}}}}
%% \end{gather*}


The translation of $\cofix$ is a corecursive process in which the \mugv coinvariant of type $T$ is
represented as a \mucp coinvariant of type $\tocp{T} \otimes \outterm$.
\[\small
\bl
\left\llbracket
\inferrule{\gvtyp{p:\gvservice{(\gvout{T}{\gvout{X}{\outterm}})},c:G(X),x:T}{M}{\outterm}}
          {\gvtyp{}{\gvfix{p}{c\,x}{M}}{\gvservice{(\gvout{\nu G}{\gvout{T}{\outterm}})}}}
\right\rrbracket z = \\
\replicate{z}{y}.y(c).y(x).y(). \\
\quad \corec{c}{w}{}{w[x].w[].0}{\cut{p}{}{\replicate{p}{y}.y(c).y(x).y().c[x].c[].0}{w(x).\tocp{M}w}} \\
\el
\]
where we have used the following syntactic sugar for output along a channel:
\[
x[y].P \equiv x[y'].(\link{y}{y'} \mid P)
\]



\begin{theorem}
  If $\gvtyp{\Phi}{M}{T}$, then $\cptyp{\tocp{M}z}{\tocp{\Phi},z:\cpdual{\tocp{T}}}$.
\end{theorem}

\subsection{Translating from \mucp to \gvpi}\label{sec:cptogvpi}

We now present the translation $\togv{-}$ from CP to \gvpi. The translation on types is as follows:
\[\small
\ba{@{}c@{\qquad}c@{\qquad}c@{}}
\begin{eqs}
\togv{A \otimes B} &=& \gvout{\gvdual{\togv{A}}}{\togv{B}} \\
\togv{A \parr B}   &=& \gvin{\togv{A}}{\togv{B}} \\
\togv{\cpbang{A}}   &=& \gvservice{\togv{A}} \\
\togv{\cpquery{A}}  &=& \gvserver{\togv{A}} \\
\end{eqs}
&
\begin{eqs}
\togv{+\{l_i:A_i\}_i}     &=& +\{l_i:\togv{A_i}\}_i  \\
\togv{\with\{l_i:A_i\}_i} &=& \with\{l_i:\togv{A_i}\}_i \\
\togv{\nu F} &=& \nu \togv{F} \\
\togv{\mu F} &=& \mu \togv{F} \\
\togv{X.A} &=& X.\togv{A} \\
\end{eqs}
&
\begin{eqs}
\togv{1}           &=& \outterm \\
\togv{\bot}              &=& \interm \\
\togv{X}            &=& X \\
\togv{\cpdual{X}}   &=& \gvdual{X} \\
\end{eqs}
\ea
\]
The translation on terms makes use of $\key{let}$ expressions to simplify the presentation; these
are expanded to \gvpi as follows:
\[\small
\gvlet{x}{M}{N} \equiv
  \topi{(\lambda x.N) M} \equiv
  \gvsend{M}{(\gvfork{z}{\gvreceivek{x}{z}{z}{\gvlink{N}{z}}})}
\]%
and the translation on terms is as follows:
\begin{equations}
\small
  \togv{x[y].(P \mid Q)} &=&
    \gvlet{x}{\gvsend{(\gvfork{y}{\togv{P}})}{x}}{\togv{Q}} \\
  \togv{x(y).P} &=&
    \gvlet{(y,x)}{\gvreceive{x}}{\togv{P}} \\
  \togv{\sel{x}{\mathit{l}}.P} &=&
    \gvlet{x}{\gvselect{l}{x}}{\togv{P}} \\
  \togv{\case{x}{l_i.P_i}} &=&
    \gvcase{x}{l_i.\togv{P_i}} \\
  \togv{x[].0} &=& x \\
  \togv{x().P} &=& \togv{P} \\
  \togv{\cut{x}{}{P}{Q}} &=&
    \gvlet{x}{\gvfork{x}{\togv{P}}}{\togv{Q}} \\
  \togv{\link{x}{y}} &=& \gvlink{x}{y} \\
  \togv{\replicate{s}{x}.P} &=&
    \gvlink{s}{(\gvserve{x}{\togv{P}})} \\
  \togv{\derelict{s}{x}.P} &=&
    \gvlet{x}{\gvrequest{s}}{\togv{P}} \\
  \togv{\cptyp{\corec{c}{x}{}{P}{Q}}{\Gamma, c:\nu F}} &=&
    \gvsend{c}{(\gvsend{(\gvfork{x}{\togv{P}})}{(\gvrequest{(\gvfix{p}{c\,x}{Q_{F,p,c,x}})})})} \\
  \togv{\rec{x}.P} &=& \togv{P} \\
\end{equations}%
where:
%
%% \[\small
%%   Q_{F,p,x,c} =
%%     \gvlet{c'}{\gvfork{c}{\togv{Q}}}
%%               {\gvmap{\togv{F}}{c,c'}{(\gvsend{c\,c'}{(\gvrequest{p})})}}
%% \]%
\[\small
  Q_{F,p,c,x} =
    \gvlet{c'}{\gvfork{c}{\togv{Q}}}
          {\togv{\map{F}{c,c'}{\derelict{p}{z}.z[c].z[c'].z[].0}}}
\]%
Formally, the translation is from judgements to terms. The interesting case, which is the only one
to use the type environment, is $\key{corec}$. Crucially, it is type-directed, and depends on the
translation of functoriality from \mucp to \mugv.


%% % \[
%% %   Q^\dagger =
%% %     \gvlet{c}
%% %           {\gvfork{x}{\togv{Q}}}
%% %           {\gvmap{\togv{F}}{x,c}{(\gvsend{c}{(\gvsend{x}{p})})}}
%% % \]%
%% % \[
%% %   Q^\dagger =
%% %     \gvlet{y'}
%% %           {\gvfork{y}{\togv{Q}}}
%% %           {\togv{\map{F}{x,c}{p[x].p[c].p[].0}}}
%% % \]%

%% The translation is the same as in our previous work~\cite{LindleyM14} except for recursion and
%% corecursion. Formally, it is a translation from judgements to terms (as we need to know the type
%% operator in the case of $\key{corec}$).

%
%% \[
%%   Q^\dagger = \gvlet{d}{\gvfork{x}{\togv{Q}}}{\gvmap{\togv{F}}{c,d}{(\gvsend{c}{(\gvsend{d}{p})})}}.
%% \]


%% We can transfer the functoriality result from \mucp to \mugv:

%% \begin{lemma}
%%   If $\cptyp{Q}{y:\cpdual{A},x:F(A)}$, then
%%   \[
%%     \gvtyp{x:\gvdual{\togv{A}},p:\gvservice{(\gvout{\gvdual{\togv{A}}}{\gvout{X}{\outterm}})},c:\togv{F}(X)}{Q^\dagger}{\outterm}
%%   \]
%% \end{lemma}

%% Since $\mapname$ is defined in \mucp by cases, we can get $\mapname$ in \mugv by applying our
%% existing translation to each case.  Define
%% \[
%%   Q^\dagger = \gvlet{d}{\gvfork{x}{\togv{Q}}}{\gvmap{\togv{F}}{c,d}{(\gvsend{c}{(\gvsend{d}{p})})}}.
%% \]

%% \begin{lemma}
%%   If $\cptyp{Q}{y:\cpdual{A},x:F(A)}$, then
%%   \[
%%     \gvtyp{x:\gvdual{\togv{A}},p:\gvservice{(\gvout{\gvdual{\togv{A}}}{\gvout{X}{\outterm}})},c:\togv{F}(X)}{Q^\dagger}{\outterm}
%%   \]
%% \end{lemma}

%% \begin{theorem}
%%   If $\cptyp{Q}{y:\cpdual{A},x:F(A)}$, then $\gvtyp{}{\gvfix{p}{y\,c}{Q^\dagger}}{\gvservice{(\gvout{\gvdual{\togv{A}}}{\gvout{\nu \togv{F}}{\outterm}})}}$.
%% \end{theorem}

\begin{theorem}
  If $\cptyp{P}{\Gamma}$, then $\gvtyp{\togv{\Gamma}}{\togv{P}}{\outterm}$.
\end{theorem}

\section{Related Work}\label{sec:related}

Session types were originally introduced by \citet{Honda93}, and were further extended by
\citet{Takeuchi94}, \citet{Honda98}, and \citet{Yoshida07}.  The systems of \citet{Honda98} and
\citet{Yoshida07} include recursive session types.  They do not distinguish between recursion and
corecursion, and do not claim to show deadlock freedom.  \citet{Bernardi13} demonstrated that the
definition of duality for recursive sessions did not commute with unfolding recursive types.  He
proposes a different solution than ours, however, and we hope to investigate the consequences of
these different approaches in future work.

\citet{CairesPfenning10} showed the first complete propositions-as-types correspondence between
intuitionistic linear logic (ILL) and session types.  Their work shows both an interpretation of
session types as ILL propositions, and a computational interpretation of ILL proofs as
$\pi$-calculus processes.  As a result, they are able to show that well-typed processes are
terminating, race-free, and deadlock-free, by analogy with corresponding cut-elimination results for
ILL.  \citet{Toninho13} demonstrate an embedding of their calculus within a functional language; the
resulting system admits unrestricted recursion in the functional setting, and can thus provide
recursive communication behavior, but without guaranteeing that the evaluation of function terms
terminates.

\citet{Girard87} speculated that linear logic would be well-suited to reasoning about concurrency.
\citet{Abramsky92} and \citet{BellinScott94} explored the interpretation of linear logic proofs as
concurrent programs.  \citet{Kobayashi96} introduced the use of linear typing to the $\pi$-calculus,
and demonstrated a form of linear channels similar in usage to session-typed channels;
\citet{Dardha12} extend this approach to full session types.

\section{Conclusion and Future Work}\label{sec:future}

We have demonstrated a propositions-as-types correspondence linking recursive session types and
fixed points in linear logic.  Unlike previous work on recursive session types, our presentation
distinguishes between (bounded) recursive processes and (unbounded) corecursive processes.  As a
consequence of cut elimination in linear logic, we have that well-typed processes are terminating
and deadlock-free.  We conclude by identifying several areas of future work.  First, we would like
to give an asynchronous semantics to \mugv, following the original presentation of LAST by
\citet{GayVasconcelos10}, and show that it is equivalent to the synchronous semantics provided by
cut elimination in \mucp.  Second, we would like to extend our treatment of recursive sessions to
encode arbitrary recursive types in \mugv, similarly to our encoding of function and pair types in
terms of input and output on channels.  Finally, we would like to explore further extensions of
\mucp and their consequences for \mugv; in particular, the addition of the MIX$_0$ and MIX$_2$ rules
would provide additional notions of parallel composition, and could provide a way of unifying the
types $\outterm$ and $\interm$.

\label{sect:bib}
\bibliographystyle{abbrvnat}
\bibliography{main}

\end{document}
