\documentclass[orivec,envcountsame]{llncs}

\usepackage{amsmath,amssymb,mathwidth,stmaryrd,xcolor}

\usepackage{mathpartir}
\mprset{sep=1em}

\newcommand{\with}{\mathbin\binampersand}
\newcommand{\parr}{\mathbin\bindnasrepma}
\newcommand{\cpdual}[1]{#1^\perp}
\newcommand{\cpbang}[1]{{! #1}}
\newcommand{\cpquery}[1]{{? #1}}
\newcommand{\gvdual}[1]{\overline{#1}}
\newcommand{\gvout}[2]{{!#1.#2}}
\newcommand{\gvin}[2]{{?#1.#2}}
\newcommand{\lto}{\ensuremath{\multimap}}
\newcommand{\uto}{\ensuremath{\rightarrow}}
\newcommand{\outterm}{\mathrm{end}_!}
\newcommand{\interm}{\mathrm{end}_?}
\newcommand{\gvserver}[1]{\flat #1}
\newcommand{\gvservice}[1]{\sharp #1}
\newcommand{\trule}[1]{(\textit{#1})}
\newcommand{\cptyp}[2]{#1 \vdash #2}
\newcommand{\gvtyp}[3]{#1 \vdash #2 : #3}

\newcommand{\expand}[3]{\mathbf{map}^{#1}_{#2}(#3)}

\newcommand{\mkwd}[1]{\mathsf{#1}}
\newcommand{\tkwd}[1]{\textsf{#1}}
\newcommand{\link}[2]{#1 \leftrightarrow #2}
\newcommand{\cut}[4]{\mkwd{new}\:#1 \: (#3 \mid #4)}
\newcommand{\rec}[1]{\mkwd{rec}\:#1}
\newcommand{\corec}[5]{\mkwd{corec}\:#1 \langle #2 \rangle (#4,#5)}
\newcommand{\clabel}[1]{\mathrm{#1}}
\renewcommand{\case}[2]{\mkwd{case}\:#1\:\{#2\}}
\newcommand{\sel}[2]{#1[\clabel{#2}]}
\newcommand{\gvsend}[2]{\mkwd{send}\:#1\:#2}
\newcommand{\gvreceive}[1]{\mkwd{receive}\:#1}
\newcommand{\gvlet}[3]{\mkwd{let}\;#1 = #2\;\mkwd{in}\;#3}
\newcommand{\gvselect}[2]{\mkwd{select}\:#1\:#2}
\newcommand{\gvcase}[2]{\mkwd{case}\:#1\:\{#2\}}
\newcommand{\gvlink}[2]{\mkwd{link}\:#1\:#2}
\newcommand{\gvfork}[2]{\mkwd{fork}\:#1.#2}
\newcommand{\gvletrec}[3]{\mkwd{let}\:\mkwd{rec}\:#1 = #2\:\mkwd{in}\:#3}
\newcommand{\gvserve}[2]{\mkwd{serve}\:#1.#2}
\newcommand{\gvrequest}[1]{\mkwd{request}\:#1}

\newcommand{\tocp}[1]{\llbracket #1 \rrbracket}
\newcommand{\De}{\mathcal{D}}

\newcommand{\mucp}{$\mu\mathrm{CP}$}
\newcommand{\mugv}{$\mu\mathrm{GV}$}

\newcommand{\isp}{\quad}

\title{Recursive Sessions and Linear Logic}
\author{J. Garrett Morris \and Sam Lindley \and Philip Wadler}
\institute{University of Edinburgh \\
           \email{Garrett.Morris@ed.ac.uk,\{slindley,wadler\}@inf.ed.ac.uk}}

\newcommand{\todo}[1]{{\noindent\small\color{red} \framebox{\parbox{\dimexpr\linewidth-2\fboxsep-2\fboxrule}{\textbf{TODO:} #1}}}}

\begin{document}

\maketitle

\begin{abstract}
  Pants!
\end{abstract}

\section{Introduction}

\section{\mugv{} Syntax}

{\small
\[\begin{array}{l@{\hspace{7mm}}r@{\hspace{2mm}}c@{\hspace{2mm}}l}
  \text{Types} & T,U,V & ::= & S \mid T \otimes U \mid T \lto U \mid T \uto U \\
  \text{Session types} & S & ::= & \gvout{T}{S} \mid \gvin{T}{S} \mid \oplus \{ l_i : S_i \} \mid \with \{ l_i : S_i \} \mid \outterm \mid \interm \\
   & & \mid & X \mid \gvdual{X} \mid \mu G \mid \nu G \\
   & G & ::= & X.S \\
  \text{Terms} & M,N & ::= & x \mid \lambda x.N \mid M\,N \mid (M,N) \mid \gvlet{(x,y)}{M}{N} \\
   & & \mid & \gvsend{M}{N} \mid \gvreceive{M} \mid \gvselect{l_i}{M} \mid \gvcase{M}{l_i : N_i} \\
   & & \mid & \gvlink{M}{N} \mid \gvfork{x}{M} \mid \gvletrec{x}{M}{N}
\end{array}\]}

\section{\mugv{} Typing}

{\small
Structural rules
\begin{mathpar}
\inferrule{ }{\gvtyp{x:T}{x}{T}}

\inferrule{\gvtyp{\Phi}{M}{U} \\
           un(T)}
          {\gvtyp{\Phi,x:T}{M}{U}}

\inferrule{\gvtyp{\Phi,x:T,x':T}{M}{U} \\
           un(T)}
          {\gvtyp{\Phi,x:T}{M[x/x']}{U}}
\end{mathpar}
Lambda rules
\begin{mathpar}
\inferrule{\gvtyp{\Phi,x:T}{M}{U}}
          {\gvtyp{\Phi}{\lambda x.M}{T \lto U}}

\inferrule{\gvtyp{\Phi}{M}{T \lto U} \\
           \gvtyp{\Psi}{N}{T}}
          {\gvtyp{\Phi,\Psi}{M\,N}{U}}

\inferrule{\gvtyp{\Phi}{M}{T \lto U} \\
           un(\Phi)}
          {\gvtyp{\Phi}{M}{T \uto U}}

\inferrule{\gvtyp{\Phi}{M}{T \uto U}}
          {\gvtyp{\Phi}{M}{T \lto U}}

\inferrule{\gvtyp{\Phi}{M}{T} \\
           \gvtyp{\Psi}{N}{U}}
          {\gvtyp{\Phi,\Psi}{(M,N)}{T \otimes U}}

\inferrule{\gvtyp{\Phi}{M}{T \otimes U} \\
           \gvtyp{\Psi,x:T,y:U}{N}{V}}
          {\gvtyp{\Phi,\Psi}{\gvlet{(x,y)}{M}{N}}{V}}
\end{mathpar}
Session rules
\begin{mathpar}
\inferrule{\gvtyp{\Phi}{M}{S} \\
           \gvtyp{\Psi}{N}{\gvdual{S}}}
          {\gvtyp{\Phi,\Psi}{\gvlink{M}{N}}{\outterm}}

\inferrule{\gvtyp{\Phi}{M}{T} \\
           \gvtyp{\Psi}{N}{\gvout{T}{S}}}
          {\gvtyp{\Phi,\Psi}{\gvsend{M}{N}}{S}}

\inferrule{\gvtyp{\Phi}{M}{\gvin{T}{S}}}
          {\gvtyp{\Phi}{\gvreceive{M}}{T \otimes S}}

\inferrule{\gvtyp{\Phi,x:\gvdual{S}}{M}{\outterm}}
          {\gvtyp{\Phi}{\gvfork{x}{M}}{ S}}

\inferrule{\gvtyp{\Phi}{M}{\oplus \{ l_i:S_i \}}}
          {\gvtyp{\Phi}{\gvselect{l_i}{M}}{S_i}}

\inferrule{\gvtyp{\Phi}{M}{\with \{ l_i:S_i \}} \\
           \gvtyp{\Psi,x:S_i}{N_i}{T}}
          {\gvtyp{\Phi,\Psi}{\gvcase{M}{l_i\,x.N_i}}{T}}
\end{mathpar}
Replicated session rules
\begin{mathpar}
\inferrule{\gvtyp{\Phi,x:\gvdual{S}}{M}{\outterm} \\
           un(\Phi)}
          {\gvtyp{\Phi}{\gvserve{x}{M}}{\gvservice{S}}}

\inferrule{\gvtyp{\Phi}{M}{\gvservice{S}}}
          {\gvtyp{\Phi}{\gvrequest{M}}{S}}
\end{mathpar}
Recursive session rules
\begin{mathpar}
\inferrule{\gvtyp{\Phi}{M}{G(\mu G)}}
          {\gvtyp{\Phi}{M}{\mu G}}

\inferrule{\gvtyp{\Phi}{M}{\mu G}}
          {\gvtyp{\Phi}{M}{G (\mu G)}}

\inferrule{\gvtyp{\Phi}{M}{G(\nu G)}}
          {\gvtyp{\Phi}{M}{\nu G}}

\inferrule{\gvtyp{\Phi}{M}{\nu G}}
          {\gvtyp{\Phi}{M}{G(\nu G)}}

\inferrule{\gvtyp{x_i:T_i,f:\vec{T} \uto Q \uto \outterm,c:G(Q)}{M}{\outterm} \\
           \gvtyp{\Phi,f:\vec{T} \uto \nu G \uto \outterm}{N}{U}}
          {\gvtyp{\Phi}{\gvletrec{f\,x_1 \dots x_n\,c}{M}{N}}{U}}
\end{mathpar}}

\section{\mugv{} Examples}

\subsection{Multi-function calculator}

\begin{verbatim}
|- let rec f (accum:Int) c =
               case c of {
                 add c => let (x, c) = receive c in
                          f (accum + x) c;
                 mul c => let (x, c) = receive c in
                          f (accum * x) c
                 result c => let c = send accum c in
                             f accum c;
                 done c => c } in
   let d = fork c => f 0 c in
   let d = send 4 (select add d) in
   let d = send 8 (select mul d) in
   let (x, d) = receive (select result d) in
   let d = select d done in
   x : Int.
\end{verbatim}

\subsection{Bit Strings of DOOM!}

\todo{Translate to \mugv{}. Note that validating the translation would require extending the GV
  interpreter with Booleans, addition and multiplication.}

Introducing some more syntactic sugar: the restriction of output to bound output is tedious in
practice.  For example, to read a value from channel $m$, send it on $n$, and continue as process
$P$ requires an unintuitive use of link: $m(x).n[x'].(\link{x}{x'} \mid P)$.  In this section, I'll
write $x[y].P$ as syntactic sugar for $x[x'].(\link{x'}{y} \mid P)$.  I'll assume that we have a
collection of mathematical operations on naturals built up, and apply similar syntactic sugar, so I
can write $x[m + 1].P$, for instance, instead of $x[x'].(Inc_{m,x'} \mid P)$.

We begin with the type of intermediate nodes in the chain.  Each supports three operations: one to
compute the value of the string, one to increment the string, and one to dispose of the bit string:
%
{\small\[\begin{array}{l@{\hspace{1mm}}l}
 NodeT = \nu X. \with \{ &\clabel{val}: \cpdual{Nat} \parr (Nat \otimes X), \\
 & \clabel{inc}: \oplus \{ \clabel{carry}: X, \clabel{done}: X \}, \\
 & \clabel{halt}: 1 \}.
\end{array}\]}

\begin{verbatim}
NodeT = nu X. &{ val: ?Nat.!Nat.X,
                 inc: +{carry: X, done:X},
                 halt: end!}
\end{verbatim}

The simplest node is the terminator $Epsilon$: it adds nothing to the value of the string, and
cannot store a value so it must respond to increment requests with carry.
%
{\small\[\begin{array}{rcll}
  Epsilon_x & = & \multicolumn{2}{l}{\mkwd{corec}\:x\langle y \rangle ( y[].0,} \\
  & & \quad \mkwd{case}\:x\: \{ &\clabel{val}: x(n).x[n].\link{y}{x}; \\
  & & &\clabel{inc}:\sel{x}{carry}.\link{y}{x}; \\
  & & &\clabel{halt}: \link{y}{x} \}).
\end{array}\]}

\begin{verbatim}
let rec Epsilon c =
   case c of {
     val c => let (n, c) = receive c in
              let c = send n c in
              Epsilon c;
     inc c => let c = select carry c in
              Epsilon c;
     halt c => c }
\end{verbatim}

To give internal nodes in the string, we need some representation of the bit each stores.  Let's use
Booleans!
%
{\small\begin{align*}
Bool &= \oplus \{ \clabel{t}:1, \clabel{f}:1 \}. \\
True_x &= \sel{x}{t}.x[].0. \\
False_x &= \sel{x}{f}.x[].0.
\end{align*}}
%
As for numeric operations, I'll write $x[True].P$ for $x[b].(True_b \mid P)$.
\\\todo{Add more syntactic sugar?  How about:
{\small\begin{align*}
  \mkwd{if}\:x\:\mkwd{then}\:M\:\mkwd{else}\:N &= \case{x}{\clabel{t}:x().M; \clabel{f}:x().N} \\
  \mkwd{drop}\:x.M &= \mkwd{if}\:x\:\mkwd{then}\:M\:\mkwd{else}\:M
\end{align*}}}

We're now set to define internal nodes.  Again, the intuition is relatively simple.  In response to
an increment request, the bit flips, passing on a carry option if needed.  In response to a value
request, it adds its value to the value so far and passes the result down the string.  The syntax is
complicated by several side concerns: in particular, since our Booleans are linear, we have to use
the stored Boolean in all cases (even, like halt, when it is not strictly speaking needed).  Note
that the coinvariant $x$ is of type $Bool \otimes NodeT$: it contains both the stored bit and the
remainder of the string.
%
{\small\[\begin{array}{rcllll}
  Node_{i,y,n} & = & \multicolumn{4}{l}{\mkwd{corec}\:n \langle x \rangle (x[j].(\link{j}{i} \mid \link{x}{y}),} \\
  & & \quad x(b).\mkwd{case}\:n\: \{ &\multicolumn{3}{l}{\clabel{val}: \rec{x}.\sel{x}{val}.n(m).} \\
  & & & \quad \mkwd{case}\:b\: \{ &\multicolumn{2}{l}{\clabel{t}: b().x[2m + 1].x(m).} \\
  & & & & \multicolumn{2}{l}{\quad n[m].n[True].\link{x}{n};} \\
  & & & & \multicolumn{2}{l}{\clabel{f}: b().x[2m].x(m).} \\
  & & & & \multicolumn{2}{l}{\quad n[m].n[False].\link{x}{n} \};} \\
  & & & \multicolumn{3}{l}{\clabel{inc}: \rec{x}.\sel{x}{inc}.} \\
  & & & \quad \mkwd{case}\:x\:\{ &\multicolumn{2}{l}{\clabel{done}: \sel{n}{done}.n[b].\link{x}{n}} \\
  & & & &\clabel{carry}: \mkwd{case}\:b\: \{ &\clabel{t}: b().\sel{n}{carry}.n[False].\link{x}{n} \\
  & & & & &\clabel{f}: b().\sel{n}{done}.n[True].\link{x}{n} \} \}; \\
  & & &\clabel{halt}: \\
  & & &\quad \mkwd{case}\:b\:\{ &\multicolumn{2}{l}{\clabel{t}: b().\rec{x}.\sel{x}{halt}.x().n[].0;} \\
  & & & &\multicolumn{2}{l}{\clabel{f}: b().\rec{x}.\sel{x}{halt}.x().n[].0 \} \})}.
\end{array}\]}
We have that
{\small\[
  \cptyp{Node_{i,y,n}}{i:\cpdual{Bool},y:\cpdual{NodeT},n:NodeT}
\]}

\begin{verbatim}
let rec Node b d c =
   case c of {
     val c => let m = receive c in
              let d = send (if b then 2*m + 1 else 2*m) (select val d) in
              let (n, d) = receive d in
              let c = send n c in
              Node b d c;
     inc c => case (select inc d) of {
                done d => Node b d (select done c);
                carry d => let c = if b then select carry c else select done c in
                           Node (not b) d c };
     halt c => let d = select halt d in c }
\end{verbatim}

Now, we define a top level interface to bit strings.  We support three operations: one to compute
the value of the string, one to increment the string, and one to dispose of the string.
%
{\small\[
 CounterT = \nu X. \with \{ \clabel{val}: Nat \otimes X, \clabel{inc}:X, \clabel{halt}:1 \}.
\]}

\begin{verbatim}
CounterT = nu X. &{ val: !Nat.X, inc: X, halt: end! }
\end{verbatim}

The implementation of the top-level interface is less complex than that for the internal nodes; the
only complication arises when an increment results in a carry, and so a new node needs to be added
to the string.  The coinvariant $x$ stores the first internal node in the string, and is of type
$NodeT$.
%
{\small\[\begin{array}{rclll}
  Counter_z & = & \multicolumn{3}{l}{\mkwd{corec}\:z \langle x \rangle (Epsilon_x,} \\
  & & \quad \mkwd{case}\:z\:\{ &\multicolumn{2}{l}{\clabel{val}: \rec{x}.\sel{x}{val}.x[Zero].x(n).z[n].\link{z}{x};} \\
  & & &  \multicolumn{2}{l}{\clabel{inc}: \rec{x}.\sel{x}{inc}.} \\
  & & & \quad \mkwd{case}\:x\:\{ &\clabel{carry}: \cut{n}{CImp}{\cut{i}{Bool}{True_i}{Node_{i,x,n}}}{\link{z}{n}}; \\
  & & & &\clabel{done}: \link{z}{x} \} \\
  & & &\multicolumn{2}{l}{\clabel{halt}:\rec{x}.\sel{x}{halt}.x().z[].0 \}).}
\end{array}\]}

\begin{verbatim}
let rec CounterImpl d c =
  case c of {
    val c => let (n, d) = receive (send 0 (select val d)) in
             CounterImpl d (send n c);
    inc c => case (select inc d) of {
               carry d => let e = fork e => Node True d e in
                          CounterImpl e c
               done d => CounterImpl d c };
    halt c => let d = select halt d in c } in
let Counter z = CounterImpl (fork c => Epsilon c) z
\end{verbatim}

Here's the example from the source file.  I don't think it's necessarily the best thing, so I can't
be bothered to typeset it right now.
\begin{verbatim}
new [z:Counter]
  (Counter(z) |
   rec z.z[val].z(i).
   rec z.z[inc].
   rec z.z[val].z(j).
   rec z.z[inc].rec z.z[inc].
   rec z.z[val].z(k).
   rec z.z[halt].z().a[i].a[j].a[k].a[].0)
 |- a:int * (int * (int * 1)).
\end{verbatim}

\begin{verbatim}
let d = fork c => Counter c in
let (i, d) = select val d in
let (j, d) = select val (select inc d) in
let (k, d) = select val (select inc (select inc d)) in
let d = select halt d in
(i,j,k)
\end{verbatim}

\section{\mucp{} Syntax and Semantics}

\todo{
\begin{itemize}
\item There are a couple of changes from previous presentations of CP.  First, I've changed the
  scoping operator from $\nu$ to \tkwd{new} to avoid confusion with fixed points.  Second, I've
  attempted to make $.$ mean sequencing, as it does in $\pi$-calculus; this meant changing the
  syntax of \tkwd{new} and \tkwd{case} to eliminate extra $.$'s.
\item I'm unsure on whether to prefer a minimal presentation, to simplify the later technical
  development, or a full presentation, to make it look most like a complete language.  For example,
  as it is, I've left out second-order quantification; this isn't because there's any particular
  problem with it, but because I haven't used it in any of the examples and it doesn't interact
  surprisingly with any of the new features.  Some places the paper is schizophrenic: the syntax and
  cut rules use binary sums, but the examples assume $n$-ary sums.
\end{itemize}\vspace{-2mm}}

Types and terms:

{\small
\[\begin{array}{l@{\hspace{7mm}}r@{\hspace{2mm}}c@{\hspace{2mm}}l}
  \text{Types} & A,B & ::= & A \otimes B \mid A \parr B \mid \bot \mid 1 \mid A \oplus B \mid A \with B \mid 0 \mid \top \\
   & & \mid & X \mid \cpdual{X} \mid \mu F \mid \nu F \\
   & F & ::= & X.A \\
  \text{Terms} & P,Q & ::= & \link{x}{y} \mid x(y).P \mid x[y].(P \mid Q) \mid x().P \mid x[].0 \\
   & & \mid & \sel{x}{inl}.P \mid \sel{x}{inr}.Q \mid \case{x}{P;Q} \mid \case{x}{} \\
   & & \mid & \cut{x}{A}{P}{Q} \mid \rec{x}.P \mid \corec{x}{y}{A}{P}{Q}
\end{array}\]}

If $F = X.A$, define $F(B) = A[B/X]$.  Definition of duality is standard:

{\small\begin{gather*}
\begin{aligned}
  \cpdual{(A \otimes B)} &= \cpdual{A} \parr \cpdual{B} & \cpdual{1} &= \bot &
    \cpdual{(A \oplus B)} &= \cpdual{A} \with \cpdual{B} & \cpdual{\top} &= 0 \\
  \cpdual{(A \parr B)} &= \cpdual{A} \otimes \cpdual{B} & \cpdual{\bot} &= 1 &
    \cpdual{(A \with B)} &= \cpdual{A} \oplus \cpdual{B} & \cpdual{0} &= \top
\end{aligned}\\
\begin{aligned}
\cpdual{F} &= X.\cpdual{(F(\cpdual{X}))} & \cpdual{(\nu F)} &= \mu \cpdual{F} & \cpdual{(\mu F)} &= \nu \cpdual{F}
\end{aligned}
\end{gather*}}

\begin{lemma}
  $\cpdual{(F(A))} = \cpdual{F}(\cpdual{A})$.
\end{lemma}

\subsection{Axiom and Composition}

This seems like an odd section.

{\small\begin{mathpar}
\inferrule{ }{\cptyp{\link{x}{y}}{x:A,y:\cpdual{A}}}

\inferrule{\cptyp{P}{\Gamma,x:A} \\
           \cptyp{Q}{x:\cpdual{A},\Delta}}
          {\cptyp{\cut{x}{A}{P}{Q}}{\Gamma,\Delta}}
\end{mathpar}}

However, it does serve as a place to introduce the equivalences, which I'd forgotten otherwise.

{\small
\begin{align*}
  \cut{x}{A}{P}{\link{x}{y}} &\equiv P[y/x] \\
  \cut{x}{A}{P}{Q} &\equiv \cut{x}{\cpdual{A}}{Q}{P} \\
  \cut{x}{A}{P}{\cut{y}{B}{Q}{R}} &\equiv \cut{y}{B}{Q}{\cut{x}{A}{P}{R}} &&\text{if $x \not\in fn(Q)$}
\end{align*}}

\subsection{Input and Output}

Binary...

{\small\begin{mathpar}
\inferrule{\cptyp{P}{y:A,\Gamma} \\
           \cptyp{Q}{x:B,\Delta}}
          {\cptyp{x[y].(P \mid Q)}{x:A \otimes B,\Gamma,\Delta}}

\inferrule{\cptyp{P}{y:A,x:B,\Gamma}}
          {\cptyp{x(y).P}{x:A \parr B,\Gamma}}
\end{mathpar}}

{\small\begin{multline*}
\inferrule
  {\inferrule*
     {\cptyp{P}{y:A,\Gamma} \\
      \cptyp{Q}{x:B,\Gamma'}}
     {\cptyp{x[y].(P \mid Q)}{x: A \otimes B,\Gamma,\Gamma'}} \\
   \inferrule*
     {\cptyp{R}{x:\cpdual{B},y:\cpdual{A},\Delta}}
     {\cptyp{x(y).R}{x:\cpdual{A} \parr \cpdual{B},\Delta}}}
  {\cptyp{\cut{x}{A \otimes B}{x[y].(P \mid Q)}{x(y).R}{\Gamma,\Gamma',\Delta}}}
\Longrightarrow \\
\inferrule
  {\cptyp{Q}{y:A,\Gamma} \\
   \inferrule*
     {\cptyp{P}{x:B,\Gamma'} \\
      \cptyp{R}{x:\cpdual{B},y:\cpdual{A},\Delta}}
     {{\cptyp{\cut{x}{B}{P}{R}}{y:\cpdual{A},\Gamma',\Delta}}}}
  {\cptyp{\cut{y}{A}{Q}{\cut{x}{B}{P}{R}}}{\Gamma,\Gamma',\Delta}}
\end{multline*}}

And nullary...

{\small\begin{mathpar}
\inferrule{ }{\cptyp{x[].0}{x:1}}

\inferrule{\cptyp{P}{\Gamma}}
          {\cptyp{x().P}{x:\bot,\Gamma}}
\end{mathpar}}

{\small\[
\inferrule
  {\inferrule*
     { }{\cptyp{x[].0}{x:1}} \\
   \inferrule*
     {\cptyp{P}{\Gamma}}
     {\cptyp{x().P}{x:\bot,\Gamma}}}
  {\cptyp{\cut{x}{1}{x[].0}{x().P}}{\Gamma}}
\Longrightarrow
\cptyp{P}{\Gamma}
\]}

\subsection{Selection and Choice}

{\small\begin{mathpar}
\inferrule{\cptyp{P}{x:A,\Gamma}}
          {\cptyp{\sel{x}{inl}.P}{x:A \oplus B,\Gamma}}

\inferrule{\cptyp{P}{x:A,\Gamma} \\
           \cptyp{Q}{x:B,\Gamma}}
          {\cptyp{\case{x}{P;Q}}{x:A \with B,\Gamma}}

\inferrule{ }{\cptyp{\case{x}{}}{x:\top,\Gamma}}
\end{mathpar}}

{\small\begin{multline*}
\inferrule
  {\inferrule*
     {\cptyp{P}{x:A,\Gamma}}
     {\cptyp{\sel{x}{inl}.P}{x:A \oplus B, \Gamma}} \\
   \inferrule*
     {\cptyp{Q}{x:\cpdual{A},\Delta} \\
      \cptyp{R}{x:\cpdual{B},\Delta}}
     {\cptyp{\case{x}{Q;R}}{x:\cpdual{A} \with \cpdual{B},\Delta}}}
  {\cptyp{\cut{x}{A \oplus B}{\sel{x}{inl}.P}{\case{x}{Q;R}}}{\Gamma,\Delta}}
\Longrightarrow \\
\inferrule
  {\cptyp{P}{x:A,\Gamma} \\
   \cptyp{Q}{x:\cpdual{A},\Delta}}
  {\cptyp{\cut{x}{A}{P}{Q}}{\Gamma,\Delta}}
\end{multline*}}

No term to prove 0, and so no cut reduction for $\top$.

\subsection{Recursion and Corecursion}

{\small\begin{mathpar}
\inferrule{\cptyp{P}{x:F(\mu F), \Gamma}}
          {\cptyp{\rec{x}.P}{x:\mu F,\Gamma}}

\inferrule{\cptyp{P}{y:A,\Gamma} \\
           \cptyp{Q}{y:\cpdual{A},x:F(A)}}
          {\cptyp{\corec{x}{y}{A}{P}{Q}}{x:\nu F,\Gamma}}
\end{mathpar}}

\todo{Show that rules for introduction and elimination of $\mu$ and $\nu$ collapse?}

The new bits are to do with $\mu,\nu$.  The rule for $\mu$ is straightforward---given a process of
type $\mu F$, it unfolds the recursive type once giving a process of type $F(\mu F)$.  The rule for
$\nu$ is less obvious: it implements one expansion of the recursive type, along with an initial
coinvariant.  As a simple example, consider a Haskell definition of the stream of Fibonacci numbers:
\begin{verbatim}
fibs = iter (0,1)
  where iter (m,n) = m : iter (n, m+n)
\end{verbatim}
In this case, the pair \texttt{(m,n)} is the coinvariant, and the \texttt{iter} function behaves
like the step function (albeit with the recursion inlined).
%
\\\todo{That example is miserable, and assumes familiarity with Haskell.  In Glasgow, Phil wanted to
  see the unfoldr equivalent, which is $$unfoldr (\lambda (m,n) \to Just(m, (n,m+n))) (0,1).$$}

Cut reduction for fixed points corresponds to one step of unrolling, and depends on a subsidiary
function $\mathbf{map}$, defined below:

\todo{\begin{itemize}
  \item Can we fix inference lines extending to the edge of the page?
  \item Requires more page width than we have.
\end{itemize}
We could fix both of these problems by not including the derivations...}

\parbox{1.2\textwidth}
{\small\begin{multline*}
\inferrule
  {\inferrule*
     {\cptyp{P}{y:B,\Gamma} \\
      \cptyp{Q}{y:\cpdual{B},x:F(B)}}
     {\cptyp{\corec{x}{y}{B}{P}{Q}}{x:\nu F,\Gamma}} \\
   \inferrule*
     {\cptyp{R}{x:\cpdual{F}(\mu (\cpdual{F})),\Delta}}
     {\cptyp{\rec{x}.R}{x:\mu (\cpdual{F}),\Delta}}}
  {\cptyp{\cut{x}{\nu F}{\corec{x}{y}{B}{P}{Q}}{\rec{x}.R}}{\Gamma,\Delta}}
\Longrightarrow \\
\inferrule
  {\cptyp{P}{y:B,\Gamma} \\
   \inferrule*
     {\cptyp{Q}{y:\cpdual{B},x:F(B)} \\
      \inferrule*
        {\cptyp{E}{x:\cpdual{F}(\cpdual{B}),z:F(\nu F)} \\
         \cptyp{R[z/x]}{z:\cpdual{F}(\mu \cpdual{F}),\Delta}}
        {\cptyp{\cut{z}{F(\nu F)}{E}{R[z/x]}}{x:\cpdual{F}(\cpdual{B}),\Delta}}}
     {\cptyp{\cut{x}{F(B)}{Q}{\cut{z}{F(\nu F)}{E}{R[z/x]}}}{y:\cpdual{B},\Delta}}}
  {\cptyp{\cut{y}{B}{P}{\cut{x}{F(B)}{Q}{\cut{z}{F(\nu F)}{E}{R[z/x]}}}}{\Gamma,\Delta}}
\end{multline*}}

where $E = \expand{F}{z,x}{\corec{z}{y}{B}{\link{x}{y}}{Q[z/x]}}$.

The cases of $\mathbf{map}$ for the positive combinators are as follow:
{\small\begin{align*}
  \expand{X.C}{x,w}{Q} &= \link{x}{w} \\
  \expand{X.X}{x,w}{Q} &= Q \\
  \expand{X.C_1 \otimes C_2}{x,w}{Q} &= w(z).x[y].(\expand{X.C_1}{y,z}{Q[y/x,z/w]} \mid \expand{X.C_2}{x,w}{Q}) \\
  \expand{X.C_1 \oplus C_2}{x,w}{Q} &= \case{w}{\sel{x}{inl}.\expand{X.C_1}{x,w}{Q}; \sel{x}{inr}.\expand{X.C_2}{x,w}{Q}} \\
  \expand{X.\mu F'}{x,w}{Q} &= \corec{w}{y}{\nu(\cpdual{C}(A))}{\link{x}{y}}{\rec{y}.\expand{X.F' (\mu F')}{y,w}{Q[y/x]}}
\end{align*}}
The remaining cases can be obtained by exchanging channels $x$ and $w$.


\begin{lemma}
  If $\cptyp{Q}{x:A,w:B}$ then \(\cptyp{\expand{F}{x,w}{Q}}{x:F(A), w:\cpdual{F}(B)}.\)
\end{lemma}

\subsection{Commuting Conversions}

Commuting conversions are unsurprising:
{\small\begin{align*}
  \cut{x}{A}{z(y).P}{Q} &\Longrightarrow z(y).\cut{x}{A}{P}{Q} \\
  \cut{x}{A}{z[y].(P \mid Q)}{R} &\Longrightarrow z[y].(\cut{x}{A}{P}{R} \mid Q) &&\text{if $x \not\in fn(Q)$} \\
  \cut{x}{A}{z[y].(P \mid Q)}{R} &\Longrightarrow z[y].(P \mid \cut{x}{A}{Q}{R}) &&\text{if $x \not\in fn(P)$} \\
  \cut{x}{A}{\sel{z}{inl}.P}{Q} &\Longrightarrow \sel{z}{inl}.\cut{x}{A}{P}{Q} \\
  \cut{x}{A}{\case{z}{P;Q}}{R} &\Longrightarrow \case{z}{\cut{x}{A}{P}{R}; \cut{x}{A}{Q}{R}} \\
  \cut{x}{A}{\rec{z}.P}{Q} &\Longrightarrow \rec{z}.\cut{x}{A}{P}{Q} \\
  \cut{x}{A}{\corec{z}{y}{B}{P}{Q}}{R} &\Longrightarrow \corec{z}{y}{B}{\cut{x}{A}{P}{R}}{Q}
\end{align*}}

\subsection{Cut Elimination}

\begin{theorem}
  If $\cptyp{P}{\Gamma}$ and $P \Longrightarrow Q$, then $\cptyp{Q}{\Gamma}.$
\end{theorem}

Define $\Longrightarrow^\star$ to be the reflexive, transitive closure of $\equiv\Longrightarrow\equiv$.

\begin{theorem}
  If $\cptyp{P}{\Gamma}$, then there is a $Q$ such that $P \Longrightarrow^\star Q$ and $Q$ is cut-free.
\end{theorem}

\section{\mucp{} Examples}

We will use $n$-ary sums $\oplus\{\overline{l:A}\}$,$\with\{\overline{l:A}\}$ with correspondingly
generalized \tkwd{case} and selection expressions.

\subsection{Church Numerals}

\todo{Leave this section out entirely and introduce replication when introducing streams?}

Basic idea: can code a type $?A$ by a least fixed point, and its dual $!(\cpdual{A})$ by the dual
greatest fixed point.  Will replicate Phil's Church numeral example using this coding.  Begin with
type abbreviations:
%
{\small\begin{align*}
  Query(A) &= \mu X.\oplus\{\clabel{w}:\bot,\clabel{c}:X \parr X,\clabel{d}:A\}, \\
  Bang(A) &= \nu X.\with\{\clabel{w}:1,\clabel{c}:X \otimes X,\clabel{d}:A\}.
\end{align*}}
%
Can translate type of Church numerals:
{\small\[
  Church = \forall A. Query(A \otimes \cpdual{A}) \parr (\cpdual{A} \parr A).
\]}
\todo{This requires second-order quantification.  To me, this argues for its removal.}
Now, expressing numbers is sarcasm-quotes obvious:
{\small\begin{align*}
  Zero_x &= x(A).x(s).x(z).\rec{s}.\sel{s}{w}.s().\link{z}{x}, \\
  One_x &= x(A).x(s).x(z).\rec{s}.\sel{s}{d}.s[a].(\link{a}{z} \mid \link{s}{x}).
\end{align*}}
Note the two different uses of the value $s$ of type $Query(A)$.  In $Zero$, we have no use of $s$,
so we select weakening and discard the resulting value of type $\bot$.  In $One$, we make one use of
it, and so select dereliction instead.

Of course, we don't want to have to code all the numbers manually.  Instead, we can devise a general
pattern for incrementing a Church numeral:
{\small\begin{align*}
  Inc_{x,y} =\ &y(A).y(s).y(z).\rec{s}.\sel{s}{c}.s(f).\rec{f}.\sel{f}{d}. \\
             &f[a].(\link{a}{z} \mid x[A].x[w].(\link{w}{s} \mid x[v].(\link{v}{f} \mid \link{y}{x}))).
\end{align*}}
%
We have that $\cptyp{Inc_{x,y}}{x:\cpdual{Church},y:Church}$, confirming that $Inc_{x,y}$ has the
expected type.  Finally, we can confirm that $Inc$ behaves as expected by showing, for example, that
{\small\[
  \cut{x}{Church}{Zero_x}{Inc_{x,y}} \Longrightarrow^\star One_{y}.
\]}
\todo{Use of $\Longrightarrow^\star$ before definition.}

\subsection{Peano Numerals}

As an alternative to the Church encodings in the previous section, we could use recursive types
directly to express Peano encodings of the naturals.  The type is natural:
%
{\small\[
  Peano = \mu X.\oplus\{zero: 1, succ: X\}.
\]}
%
The representation of values is more natural in this encoding, however.  For example, we have 0 and
increment encoded as follows:
%
{\small\begin{align*}
  Zero_x &= \rec{x}.\sel{x}{zero}.x[].0 \\
  Inc_{x,y} &= \rec{y}.\sel{y}{succ}.\link{x}{y}
\end{align*}}
Again, we can show that increment behaves as we expect; for example, we have that
%
{\small\[
  \cut{x}{Peano}{Zero_x}{Inc_{x,y}} \Longrightarrow^\star \rec{y}.\sel{y}{succ}.\rec{y}.\sel{y}{zero}.y[].0.
\]}

{\small\[\begin{array}{rcl@{\hspace{0mm}}ll}
  Add_{x,y,z} & = & \multicolumn{3}{l}{\mkwd{corec}\:x\langle a \rangle} \\
  & & \quad (&\multicolumn{2}{l}{a[y].\link{a}{z},} \\
  & & & a(b).\mkwd{case}\:x\:\{&\clabel{zero}: x().\link{a}{b}; \\
  & & & & \clabel{succ}: x[b'].(Inc_{b,b'} \mid  \link{a}{x}) \}).
\end{array}\]}
We can show that $\cptyp{Add_{x,y,z}}{x:\cpdual{Peano}, y:\cpdual{Peano}, z:Peano}$ and, for instance,
that
%
{\small\[
  \cut{x}{Peano}{One_x}{\cut{y}{Peano}{One_y}{Add_{x,y,z}}} \Longrightarrow^\star Two_z.
\]}

\subsection{Streams}

Another obvious thing to do with a recursion is streams.  The types are again quite intuitive:
{\small\begin{align*}
  Sink(A) &= \mu X. \oplus \{ \clabel{end}: \bot, \clabel{more}: \cpdual{A} \parr X \}, \\
  Source(A) &= \nu X. \with \{ \clabel{end}: 1, \clabel{more}: A \otimes X \}.
\end{align*}}
Note the use of the dual in $Sink$; as a result, we have that $\cpdual{(Sink(A))} = Source(A)$ (and
not $Source(\cpdual{A})$: would the other formulation make more sense, tho).

Now, let's define some streams of naturals!  Let $Nat$ stand in for either of the encodings of
naturals.  We'll start with a stream of zeros.  Our form for defining greatest fixed points, called
\tkwd{corec}, allows an arbitrary coinvariant; in this case, we don't need one, so we'll just use 1:
%
{\small\begin{align*}
  Zeros_y =\ &\corec{y}{z}{1}{z[].0}{z().\case{y}{\clabel{end}: y[].0; \clabel{more}: y[x].(Zero_x | y[].0)}}.
\end{align*}}
%
In the \textrm{more} case, we rely on our earier definition of $Zero$.  Building the stream of
naturals $0,1,2,\dots$ is more involved, but little more complicated. Note that we will need two
copies of each number in the stream: the one that appears in the stream itself, and the one used to
generate the remainder of the stream.  Therefore, we'll use a $Bang(Nat)$ as our coinvariant.  We
begin by lifting $Zero$ to type $Bang(Nat)$:
%
{\small\[\begin{array}{r@{\hspace{2mm}}c@{\hspace{2mm}}l@{\hspace{0mm}}l@{\:}l}
  LiftZero_z & = & \multicolumn{3}{l}{\mkwd{corec} \: z \langle a \rangle (a[].0,} \\
  & & \quad & a().\mkwd{case}\: z \: \{ &\clabel{w}: z[].0; \\
  & & & & \clabel{d}: Zero_z; \\
  & & & & \clabel{c}: z[w].(w[].0 \mid z[].0) \}).
\end{array}\]}
%
Again, we don't need a coinvariant, so we use 1.  The only interesting behavior is in the case of
dereliction, in which we rely (again) on our existing definition of $Zero$.  Next, we can lift the
$Inc$ definition above to operate on $Bang(Nat)$ processes:
%
{\small\[\begin{array}{r@{\hspace{2mm}}c@{\hspace{2mm}}l@{\hspace{0mm}}l@{\:}l}
  LiftInc_{x,y} & = & \multicolumn{3}{l}{\mkwd{corec} \: y \langle z \rangle (\link{x}{z},} \\
  & & \quad & \mkwd{case} \: y \: \{ & \clabel{w}: \rec{z}.\sel{z}{w}.y[].0; \\
  & & & & \clabel{d}: \rec{z}.\sel{z}{d}.Inc_{z,y}; \\
  & & & & \clabel{c}: \rec{z}.\sel{z}{c}.z(w).y[x].(\link{x}{w} \mid \link{y}{z}) \}).
\end{array}\]}
%
The invariant $z$ is of type $Bang(Nat)$.  In the case of dereliction, $LiftInc$ behaves as
$Inc$; the other cases are implemented in terms of the corresponding cases of the coinvariant.
Thus, we have that
\[
  \cptyp{LiftInc_{x,y}}{x:Query(\cpdual{Nat}),y:Bang(Nat)}.
\]
Finally, we can define a stream of naturals: the invariant is of type $Bang(Church)$, initialized by
$LiftZero$, and the \textrm{more} case relies on $LiftInc$:
%
{\small\[\begin{array}{r@{\hspace{2mm}}c@{\hspace{2mm}}l@{\hspace{0mm}}l@{\:}l}
  CNats_y & = & \multicolumn{3}{l}{\mkwd{corec} \: y \langle z \rangle (Zero_z,} \\
  & & \quad & \mkwd{case}\:y \{ & \clabel{end}: \rec{z}.\sel{z}{w}.z().y[].0; \\
  & & & & \clabel{more}: \rec{z}.\sel{z}{c}.z(w).y[x].\\
  & & & & \quad (\rec{w}.\sel{w}{d}.\link{x}{w} \mid LiftInc_{z,y}) \}).
\end{array}\]}
%
As we expect, we have that $\cptyp{CNats_y}{y:Stream(Nat)}$.
\\\todo{Example of using streams?  They're not terribly surprising.}

\section{\mugv{} Translation}

\todo{\begin{itemize}
  \item Translating unlimited GV terms (at the moment, this is only unlimited lambdas) requires
    exponentials, either directly or encoded, in CP.  Adding exponentials to CP requires a
    significant expansion of the existing typing and cut reduction rules (not technically difficult,
    but increasingly overwhelming the actual point of the paper).  Using coding would not require
    extension of the CP rules, but differs from the existing GV $\to$ CP translations.
  \item This translation doesn't take advantage of the previous GV $\to$ GV$\pi$ translation.  Doing
    so would require a ``modified'' form of $\mkwd{let\:rec}$, analogous to the modified form of
    $\mkwd{receive}$, which replaced the unlimited arrows with servers.
\end{itemize}}

{\small
\[
\left\llbracket
\inferrule{\gvtyp{\Phi}{M}{\mu G}}{\gvtyp{\Phi}{M}{G (\mu G)}}
\right\rrbracket z =
\cut{y}{\nu \tocp{G}}{\tocp{\gvtyp{\Phi}{M}{\mu G}}y}{\rec{y}.\link{y}{z}}
\]

\[
\left\llbracket
\inferrule{\gvtyp{\Phi}{M}{G(\nu G)}}{\gvtyp{\Phi}{M}{\nu G}}
\right\rrbracket z =
\cut{y}{\nu \tocp{G}}{\tocp{\gvtyp{\Phi}{M}{G(\nu G)}}y}{\rec{z}.\link{y}{z}}
\]

\[
\left\llbracket
\inferrule{\gvtyp{\Phi}{M}{G(\mu G)}}{\gvtyp{\Phi}{M}{\mu G}}
\right\rrbracket z =
\cut{y}{\tocp{G}(\mu \tocp{G})}{P}
       {\corec{z}{x}{\tocp{G}(\mu \tocp{G})}
              {\link{y}{x}}
              {\expand{G}{x,z}{\rec{x}.\link{x}{z}}}}
\]

\[
\left\llbracket
\inferrule{\gvtyp{\Phi}{M}{\nu G}}{\gvtyp{\Phi}{M}{G (\nu G)}}
\right\rrbracket z =
\cut{y}{\mu \tocp{G}}{P}
       {\corec{y}{x}{\cpdual{\tocp{G}}(\nu \cpdual{\tocp{G}})}
              {\link{z}{x}}
              {\expand{G}{x,y}{\rec{x}.\link{x}{y}}}}
\]

\newcommand{\replicate}[2]{{!#1(#2)}}

\begin{multline*}
\left\llbracket
\inferrule{\gvtyp{x_i:T_i,f:\vec{T} \uto Q \uto \outterm,c:G(Q)}{M}{\outterm} \\
           \gvtyp{\Phi,f:\vec{T} \uto \nu G \uto \outterm}{N}{U}}
          {\gvtyp{\Phi}{\gvletrec{f\,x_1 \dots x_n\,c}{M}{N}}{U}}
\right\rrbracket z = \\
\replicate{f}{f_1}.f_1(x_1)\dots.\replicate{f_{n-1}}{f_n}.f_n(x_n).\corec{c}{ci}{}{\tocp{init_{ci}}^\star}{\tocp{M^\dagger_{ci}}^\star}
\end{multline*}

where

\[
  \tocp{M}^\star = \cut{z}{\bot}{\tocp{M}z}{z[].0}
\]

\[
 init_{ci} = \gvsend{x_n}{(\dots(\gvsend{x_1}{ci}))}
\]

\[\begin{array}{rcl}
M^\dagger_{ci} &=& \gvlet{f}{\lambda x_1\dots\lambda x_n.\lambda c.\gvsend{x_n}{(\dots(\gvsend{x_1}{c})\dots)}}
                {\\&&\gvlet{(x_1,ci)}{\gvreceive{ci}}
                {\\&&\vdots\\&&\gvlet{(x_n,ci)}{\gvreceive{ci}}{M}}}
\end{array}\]
}

\begin{theorem}
  If $\gvtyp{\Phi}{M}{T}$, then $\cptyp{\tocp{M}z}{\tocp{\Phi},z:\cpdual{\tocp{T}}}$.
\end{theorem}

\section{Related Work}

\section{Conclusion and Future Work}

\end{document}
