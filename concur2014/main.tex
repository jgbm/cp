\documentclass[orivec,envcountsame]{llncs}

\usepackage{amsmath,amssymb,mathwidth,stmaryrd,xcolor,xspace}
\addtolength{\jot}{-3px}

\usepackage{mathpartir}
\mprset{sep=1em}

\usepackage{float}
\floatstyle{boxed}
\restylefloat{figure}

\newcommand{\with}{\mathbin\binampersand}
\newcommand{\parr}{\mathbin\bindnasrepma}
\newcommand{\cpdual}[1]{#1^\perp}
\newcommand{\cpbang}[1]{{! #1}}
\newcommand{\cpquery}[1]{{? #1}}
\newcommand{\gvdual}[1]{\overline{#1}}
\newcommand{\gvout}[2]{{!#1.#2}}
\newcommand{\gvin}[2]{{?#1.#2}}
\newcommand{\lto}{\ensuremath{\multimap}}
\newcommand{\uto}{\ensuremath{\rightarrow}}
\newcommand{\outterm}{\mathrm{end}_!}
\newcommand{\interm}{\mathrm{end}_?}
\newcommand{\gvserver}[1]{\flat #1}
\newcommand{\gvservice}[1]{\sharp #1}
\newcommand{\trule}[1]{(\textit{#1})}
\newcommand{\cptyp}[2]{#1 \vdash #2}
\newcommand{\gvtyp}[3]{#1 \vdash #2 : #3}

\newcommand{\expand}[3]{\mathbf{map}^{#1}_{#2}(#3)}

\newcommand{\mkwd}[1]{\mathsf{#1}}
\newcommand{\tkwd}[1]{\textsf{#1}}
\newcommand{\link}[2]{#1 \leftrightarrow #2}
\newcommand{\cut}[4]{\mkwd{new}\:#1 \: (#3 \mid #4)}
\newcommand{\rec}[1]{\mkwd{rec}\:#1}
\newcommand{\corec}[5]{\mkwd{corec}\:#1 \langle #2 \rangle (#4,#5)}
\newcommand{\clabel}[1]{\mathrm{#1}}
\renewcommand{\case}[2]{\mkwd{case}\:#1\:\{#2\}}
\newcommand{\sel}[2]{#1[\clabel{#2}]}
\newcommand{\gvsend}[2]{\mkwd{send}\:#1\:#2}
\newcommand{\gvreceive}[1]{\mkwd{receive}\:#1}
\newcommand{\gvlet}[3]{\mkwd{let}\;#1 = #2\;\mkwd{in}\;#3}
\newcommand{\gvselect}[2]{\mkwd{select}\:#1\:#2}
\newcommand{\gvcase}[2]{\mkwd{case}\:#1\:\{#2\}}
\newcommand{\gvlink}[2]{\mkwd{link}\:#1\:#2}
\newcommand{\gvfork}[2]{\mkwd{fork}\:#1.#2}
\newcommand{\gvletrec}[3]{\mkwd{corec}\:#1 = #2\:\mkwd{in}\:#3}
\newcommand{\gvserve}[2]{\mkwd{serve}\:#1.#2}
\newcommand{\gvrequest}[1]{\mkwd{request}\:#1}

\newcommand{\key}{\mkwd}

\newcommand{\tocp}[1]{\llbracket #1 \rrbracket}
\newcommand{\De}{\mathcal{D}}

\newcommand{\topi}[1]{({#1})^\star}

\newcommand{\mucp}{$\mathrm{mooCP}$\xspace}
\newcommand{\mugv}{$\mathrm{mooGV}$\xspace}
\newcommand{\gvpi}{$\mathrm{mooGVpie}$\xspace}

\newcommand{\ba}{\begin{array}}
\newcommand{\ea}{\end{array}}

\newcommand{\bl}{\ba[t]{@{}l@{}}}
\newcommand{\el}{\ea}

\newenvironment{equations}{\[\ba{@{}r@{~}c@{~}l@{}}}{\ea\]}
\newenvironment{eqs}{\ba{@{}r@{~}c@{~}l@{}}}{\ea}

\newcommand{\isp}{\quad}

\title{Recursive Sessions and Linear Logic}
\author{J. Garrett Morris \and Sam Lindley \and Philip Wadler}
\institute{University of Edinburgh \\
           \email{Garrett.Morris@ed.ac.uk,\{slindley,wadler\}@inf.ed.ac.uk}}

\newcommand{\todo}[1]{{\noindent\small\color{red} \framebox{\parbox{\dimexpr\linewidth-2\fboxsep-2\fboxrule}{\textbf{TODO:} #1}}}}

\begin{document}

\maketitle

\begin{abstract}
  Pants!
\end{abstract}

\section{Introduction}

\section{A Session-Typed Functional Language}

\subsection{Types and Terms of \mugv}

\begin{figure}\small
\[\begin{array}{l@{\hspace{1mm}}r@{\hspace{2mm}}c@{\hspace{2mm}}l}
  \text{Types} & T,U,V & ::= & S \mid T \otimes U \mid T \lto U \mid T \uto U \\
  \text{Session types} & S & ::= & \gvout{T}{S} \mid \gvin{T}{S} \mid \oplus \{ l_i : S_i \} \mid \with \{ l_i : S_i \} \mid \outterm \mid \interm \\
   & & \mid & X \mid \gvdual{X} \mid \mu G \mid \nu G \mid \gvservice{S} \mid \gvserver{S} \\
  \text{Type operators} & G & ::= & X.S % \\
%  \text{Terms} & M,N & ::= & x \mid \lambda x.N \mid M\,N \mid (M,N) \mid \gvlet{(x,y)}{M}{N} \\
%   & & \mid & \gvsend{M}{N} \mid \gvreceive{M} \mid \gvselect{l_i}{M} \mid \gvcase{M}{l_i : N_i} \\
%   & & \mid & \gvlink{M}{N} \mid \gvfork{x}{M} \mid \gvletrec{x}{M}{N}
\end{array}\]
\caption{\mugv Types and Session Types}\label{fig:gv-syntax}
\end{figure}

In this section, we present \mugv, a simple functional language with session types patterned on the
language of Gay and Vasconcelos~\cite{} (which we term LAST) and Wadler's language GV.
Figure~\ref{fig:gv-syntax} gives the syntax of \mugv terms and types.  Among the types, we include
linear pairs ($T \otimes U$), and both linear ($T \lto U$) and unlimited ($T \uto U$) function
spaces.  The session types include input ($\gvin{T}{S}$), output ($\gvout{T}{S}$), selection
($\oplus\{ l_i:S_i \}$) and choice ($\with\{l_i:S_i\}$).  We include two variations on the closed
channel ($\interm$ and $\outterm$); this is forced by our interpretation of session types in LL,
where there is no self-dual proposition to implement closed channels.  $\gvservice{S}$ represents
replication of a channel the behaves like $S$; a channel of type $\gvserver{S}$ is the corresponding
provider of a replicated channel.  Finally, we include session variables and their duals
($X,\gvdual{X}$), and two forms of recursive session types, corresponding to least ($\mu X.S$) and
greatest ($\nu X.S$) fixed points.  If $G$ is an operator $X.S$, we write $G(S')$ for the
substitution instance $S[S'/X]$.  All types are linear except for unlimited functions $T \uto U$,
replicated channels $\gvservice{S}$, and closed channels $\interm$; we write $un(T)$ if $T$ is
unlimited.

The notions of duality are standard for input, output, selection, choice, and closed and replicated
channels:
{\small\begin{align*}
\gvdual{\gvout{T}{S}} &= \gvin{T}{\gvdual{S}} &
  \gvdual{\oplus \{ l_i: S_i \}} &= \with \{ l_i : \gvdual{S_i} \} &
  \gvdual{\interm} &= \outterm &
  \gvdual{\gvservice{S}} &= \gvserver{\gvdual{S}} \\
\gvdual{\gvin{T}{S}} &= \gvout{T}{\gvdual{S}} &
  \gvdual{\with \{ l_i: S_i \}} &= \oplus \{ l_i : \gvdual{S_i} \} &
  \gvdual{\outterm} &= \interm &
  \gvdual{\gvserver{S}} &= \gvservice{\gvdual{S}}
\end{align*}}
We introduce a notion of the dual of an operator: if $G = X.S$, then $\gvdual{G} =
X.\gvdual{G(\gvdual{X})}$.  This allows us to give a natural defintion of duality for fixed points:
{\small\begin{align*}
\gvdual{\mu G} &= \nu \gvdual{G} & \gvdual{\nu G} = \mu \gvdual{G}
\end{align*}}
Unlike many notions of duality for session types, our definition preserves duality when recursive
session types are unfolded, even when the recursion occurs in messages.  For example, consider the
operator $G = X.\gvin{X}{\interm}$, with its dual $\gvdual{G} = X.\gvout{\gvdual{X}}{\outterm}$, and
the (dual) session types $\mu G$ and $\nu \gvdual{G}$.  Unfolding the first type gives $F(\mu F)$, or
$\gvin{\mu F}{\interm}$.  Unfolding the second gives
{\small\[
\gvdual{G}(\nu \gvdual{G})
  = \gvout{\gvdual{\nu \gvdual{G}}}{\outterm}
  = \gvout{\mu G}{\outterm},
\]}
which is the dual of $\gvin{\mu F}{\interm}$.  Finally, to assure that the fixed points exist, we
require that all operators $X.S$ be monotonic, that is, that variables appear only as positive
subformulae of $S$, and negated variables only as negative subformulae.  The definition of positive
subformulae is slightly unusual: we have that the argument $T$ in $\gvout{T}{S}$ and the arguments
$T$ and $U$ in $T \otimes U, T \lto U, T \uto U$ are negative, and all other subformulae are
positive.  Thus, the operator $X.\gvout{X}{\outterm}$ is not monotonic, but the operators
$X.\gvout{\gvdual{X}}{\outterm}$ and $X.\gvout{X \otimes X}{\outterm}$ are.

\todo{The definition of monotonic is deranged.}

\begin{figure}\small
Structural rules
\begin{mathpar}
\inferrule{ }{\gvtyp{x:T}{x}{T}}

\inferrule{\gvtyp{\Phi}{M}{U} \\
           un(T)}
          {\gvtyp{\Phi,x:T}{M}{U}}

\inferrule{\gvtyp{\Phi,x:T,x':T}{M}{U} \\
           un(T)}
          {\gvtyp{\Phi,x:T}{M[x/x']}{U}}
\end{mathpar}
Lambda rules
\begin{mathpar}
\inferrule{\gvtyp{\Phi,x:T}{M}{U}}
          {\gvtyp{\Phi}{\lambda x.M}{T \lto U}}

\inferrule{\gvtyp{\Phi}{M}{T \lto U} \\
           \gvtyp{\Psi}{N}{T}}
          {\gvtyp{\Phi,\Psi}{M\,N}{U}}

\inferrule{\gvtyp{\Phi}{M}{T \lto U} \\
           un(\Phi)}
          {\gvtyp{\Phi}{M}{T \uto U}}

\inferrule{\gvtyp{\Phi}{M}{T \uto U}}
          {\gvtyp{\Phi}{M}{T \lto U}}

\inferrule{\gvtyp{\Phi}{M}{T} \\
           \gvtyp{\Psi}{N}{U}}
          {\gvtyp{\Phi,\Psi}{(M,N)}{T \otimes U}}

\inferrule{\gvtyp{\Phi}{M}{T \otimes U} \\
           \gvtyp{\Psi,x:T,y:U}{N}{V}}
          {\gvtyp{\Phi,\Psi}{\gvlet{(x,y)}{M}{N}}{V}}
\end{mathpar}
Session rules
\begin{mathpar}
\inferrule{\gvtyp{\Phi}{M}{S} \\
           \gvtyp{\Psi}{N}{\gvdual{S}}}
          {\gvtyp{\Phi,\Psi}{\gvlink{M}{N}}{\outterm}}

\inferrule{\gvtyp{\Phi}{M}{T} \\
           \gvtyp{\Psi}{N}{\gvout{T}{S}}}
          {\gvtyp{\Phi,\Psi}{\gvsend{M}{N}}{S}}

\inferrule{\gvtyp{\Phi}{M}{\gvin{T}{S}}}
          {\gvtyp{\Phi}{\gvreceive{M}}{T \otimes S}}

\inferrule{\gvtyp{\Phi,x:\gvdual{S}}{M}{\outterm}}
          {\gvtyp{\Phi}{\gvfork{x}{M}}{ S}}

\inferrule{\gvtyp{\Phi}{M}{\oplus \{ l_i:S_i \}}}
          {\gvtyp{\Phi}{\gvselect{l_i}{M}}{S_i}}

\inferrule{\gvtyp{\Phi}{M}{\with \{ l_i:S_i \}} \\
           \gvtyp{\Psi,x:S_i}{N_i}{T}}
          {\gvtyp{\Phi,\Psi}{\gvcase{M}{l_i\,x.N_i}}{T}}
\end{mathpar}
Replicated session rules
\begin{mathpar}
\inferrule{\gvtyp{\Phi,x:\gvdual{S}}{M}{\outterm} \\
           un(\Phi)}
          {\gvtyp{\Phi}{\gvserve{x}{M}}{\gvservice{S}}}

\inferrule{\gvtyp{\Phi}{M}{\gvservice{S}}}
          {\gvtyp{\Phi}{\gvrequest{M}}{S}}
\end{mathpar}
Recursive session rules
\begin{mathpar}
\inferrule{\gvtyp{\Phi}{M}{G(\mu G)}}
          {\gvtyp{\Phi}{M}{\mu G}}

\inferrule{\gvtyp{\Phi}{M}{\mu G}}
          {\gvtyp{\Phi}{M}{G (\mu G)}}

\inferrule{\gvtyp{\Phi}{M}{G(\nu G)}}
          {\gvtyp{\Phi}{M}{\nu G}}

\inferrule{\gvtyp{\Phi}{M}{\nu G}}
          {\gvtyp{\Phi}{M}{G(\nu G)}}

\inferrule{\gvtyp{x_i:T_i,f:\vec{T} \uto X \uto \outterm,c:G(X)}{M}{\outterm} \\
           \gvtyp{\Phi,f:\vec{T} \uto \nu G \uto \outterm}{N}{U}}
          {\gvtyp{\Phi}{\gvletrec{f\,x_1 \dots x_n\,c}{M}{N}}{U}}
\end{mathpar}
\caption{\mugv Terms and Typing Rules}\label{fig:gv-typing}
\end{figure}

Figure~\ref{fig:gv-typing} gives the terms and typing rules of \mugv.  The structural rules account
for variables, and for weakening and contraction on variables of unlimited type.  The rules for the
functional terms are standard; note that, to account for linearity, the context is split in the
rules for application and pair introduction and elimination, and is limited to unlimited types in
the introduction of unlimited arrows.

Among the session-typed terms, the rules for input, output, choice and selection are standard.  We
provide a term $\gvlink{M}{N}$ to implement channel forwarding; while a version of \tkwd{link}
exists for any session type $S$, it has no generic implementation in terms of other constructs of
\mugv.  Finally, \tkwd{fork} provides session initiation; like Wadler's GV, but unlike LAST (and
much other work on process calculi), our system is deterministic.

Channels of type $\gvservice{S}$ offer arbitrarily many sessions of type $S$; correspondingly,
channels of type $\gvserver{S}$ must consume arbitrarily many $S$ sessions. The rule for
$\gvserve{x}{M}$ parallels that for $\tkwd{fork}$: it defines the server (which replicates $M$) and
returns the channel by which it may be used (of type $\gvdual{\gvserver{S}} =
\gvservice{\gvdual{S}}$). As a consequence, there is no rule involving type $\gvserver{S}$.

Finally, we provide recursive channels.  The first four typing rules allow recursive types to be
used as their unfoldings, and vice versa.  Previous work has typically included an equivalence
relation on types, taking unfolding into account, and presented type rules upto equivalence.  We
present explicit rules to simplify the translation into \mucp, where these rules will correspond to
particular terms implementing the equivalences.  The expression $\gvletrec{f\,\vec{x}\,c}{M}{N}$
provides definition of recursive sessions.  The body $M$ provides one iteration of the recursion.
Thus, it has access to the coinvariant $x_i$, a channel $G(X)$, and limited recursive use of $f$;
the type variable $X$ ensures the use of recursive calls to $f$. Next, we will consider several
examples of recursive sessions.

\todo{Explanation of let rec that makes sense/explains anything.}

\subsection{Multi-function calculator}

Our first example is a simple multi-function calculator.  For the purposes of this example, we will
assume that our term language has been extended by integer constants, along with addition ($+$) and
multiplication ($\times$) operators.  Our goal is to provide a session that accepts an arbitrary
stream of addition and multiplication requests, and can at any time provide the accumulated result.
We can implement the provider of this session as follows:

\[\begin{array}{llll}
 \multicolumn{4}{l}{\mkwd{corec}\:calc\:accum\:c =} \\
 \quad & \multicolumn{3}{l}{\mkwd{case}\:c\;\mkwd{of}\:\{} \\
 & \quad & \clabel{add}\:c. &\mkwd{let}\:(x,c) = \gvreceive{c} \: \mkwd{in} \\
 & & & f\:(accum + x)\:c; \\
 & & \clabel{mul}\:c. &\mkwd{let}\:(x,c) = \gvreceive{c}\:\mkwd{in} \\
 & & & f\:(accum \times x)\:c \\
 & & \clabel{result}\:c. &\mkwd{let}\:c = \gvsend{accum}{c}\:\mkwd{in} \\
 & & & f\:accum\:c; \\
 & & \clabel{done}\:c.& c \; \}
\end{array}\]
In this case, the type of the recursive channel is
\[
 \nu X. \with \{ \clabel{add}: \gvin{Int}{X}, \clabel{mul}: \gvin{Int}{X}, \clabel{result}: \gvout{Int}{X}, \clabel{done}: \outterm \}.
\]
We can implement a consumer of the service as follows:
\[\begin{array}{l}
  \gvlet{myCalc}{\gvfork{c}{calc\:0\:c}}{} \\
  \gvlet{d}{\gvsend{6}{(\gvselect{\clabel{add}}{myCalc})}}{} \\
  \gvlet{myCalc}{\gvsend{7}{(\gvselect{\clabel{mul}}{myCalc})}}{} \\
  \gvlet{(x,d)}{\gvreceive{(\gvselect{\clabel{result}}{myCalc})}}{} \\
  \gvlet{myCalc}{\gvselect{\clabel{done}}{myCalc}}{x}
\end{array}\]
We begin by constructing an instance of the calculator with the accumulator set to 0; in the body of
\tkwd{fork}, $c$ has the $\nu$-type given above, so the result of \tkwd{fork} (called $myCalc$), has
type
\[
\mu X. \oplus \{ \clabel{add}: \gvout{Int}{X}, \clabel{mul}: \gvout{Int}{X}, \clabel{result}: \gvin{Int}{X}, \clabel{done}: \interm \}.
\]
We perform several calculuations, adding 6 to the accumulator and multiplying by 7.  Finally, we get
the result and close the channel.

\subsection{Bit Strings of DOOM!}

\todo{Translate to \mugv. Note that validating the translation would require extending the GV
  interpreter with Booleans, addition and multiplication.}

Introducing some more syntactic sugar: the restriction of output to bound output is tedious in
practice.  For example, to read a value from channel $m$, send it on $n$, and continue as process
$P$ requires an unintuitive use of link: $m(x).n[x'].(\link{x}{x'} \mid P)$.  In this section, I'll
write $x[y].P$ as syntactic sugar for $x[x'].(\link{x'}{y} \mid P)$.  I'll assume that we have a
collection of mathematical operations on naturals built up, and apply similar syntactic sugar, so I
can write $x[m + 1].P$, for instance, instead of $x[x'].(Inc_{m,x'} \mid P)$.

We begin with the type of intermediate nodes in the chain.  Each supports three operations: one to
compute the value of the string, one to increment the string, and one to dispose of the bit string:
%
{\small\[\begin{array}{l@{\hspace{1mm}}l}
 NodeT = \nu X. \with \{ &\clabel{val}: \cpdual{Nat} \parr (Nat \otimes X), \\
 & \clabel{inc}: \oplus \{ \clabel{carry}: X, \clabel{done}: X \}, \\
 & \clabel{halt}: 1 \}.
\end{array}\]}

\begin{verbatim}
NodeT = nu X. &{ val: ?Nat.!Nat.X,
                 inc: +{ carry: X, done:X },
                 halt: end! }
\end{verbatim}

The simplest node is the terminator $Epsilon$: it adds nothing to the value of the string, and
cannot store a value so it must respond to increment requests with carry.
%
{\small\[\begin{array}{rcll}
  Epsilon_x & = & \multicolumn{2}{l}{\mkwd{corec}\:x\langle y \rangle ( y[].0,} \\
  & & \quad \mkwd{case}\:x\: \{ &\clabel{val}: x(n).x[n].\link{y}{x}; \\
  & & &\clabel{inc}:\sel{x}{carry}.\link{y}{x}; \\
  & & &\clabel{halt}: \link{y}{x} \}).
\end{array}\]}

\begin{verbatim}
let rec Epsilon c =
   case c of {
     val c => let (n, c) = receive c in
              let c = send n c in
              Epsilon c;
     inc c => let c = select carry c in
              Epsilon c;
     halt c => c }
\end{verbatim}

To give internal nodes in the string, we need some representation of the bit each stores.  Let's use
Booleans!
%
{\small\begin{align*}
Bool &= \oplus \{ \clabel{t}:1, \clabel{f}:1 \}. \\
True_x &= \sel{x}{t}.x[].0. \\
False_x &= \sel{x}{f}.x[].0.
\end{align*}}
%
As for numeric operations, I'll write $x[True].P$ for $x[b].(True_b \mid P)$.
\\\todo{Add more syntactic sugar?  How about:
{\small\begin{align*}
  \mkwd{if}\:x\:\mkwd{then}\:M\:\mkwd{else}\:N &= \case{x}{\clabel{t}:x().M; \clabel{f}:x().N} \\
  \mkwd{drop}\:x.M &= \mkwd{if}\:x\:\mkwd{then}\:M\:\mkwd{else}\:M
\end{align*}}}

We're now set to define internal nodes.  Again, the intuition is relatively simple.  In response to
an increment request, the bit flips, passing on a carry option if needed.  In response to a value
request, it adds its value to the value so far and passes the result down the string.  The syntax is
complicated by several side concerns: in particular, since our Booleans are linear, we have to use
the stored Boolean in all cases (even, like halt, when it is not strictly speaking needed).  Note
that the coinvariant $x$ is of type $Bool \otimes NodeT$: it contains both the stored bit and the
remainder of the string.
%
{\small\[\begin{array}{rcllll}
  Node_{i,y,n} & = & \multicolumn{4}{l}{\mkwd{corec}\:n \langle x \rangle (x[j].(\link{j}{i} \mid \link{x}{y}),} \\
  & & \quad x(b).\mkwd{case}\:n\: \{ &\multicolumn{3}{l}{\clabel{val}: \rec{x}.\sel{x}{val}.n(m).} \\
  & & & \quad \mkwd{case}\:b\: \{ &\multicolumn{2}{l}{\clabel{t}: b().x[2m + 1].x(m).} \\
  & & & & \multicolumn{2}{l}{\quad n[m].n[True].\link{x}{n};} \\
  & & & & \multicolumn{2}{l}{\clabel{f}: b().x[2m].x(m).} \\
  & & & & \multicolumn{2}{l}{\quad n[m].n[False].\link{x}{n} \};} \\
  & & & \multicolumn{3}{l}{\clabel{inc}: \rec{x}.\sel{x}{inc}.} \\
  & & & \quad \mkwd{case}\:x\:\{ &\multicolumn{2}{l}{\clabel{done}: \sel{n}{done}.n[b].\link{x}{n}} \\
  & & & &\clabel{carry}: \mkwd{case}\:b\: \{ &\clabel{t}: b().\sel{n}{carry}.n[False].\link{x}{n} \\
  & & & & &\clabel{f}: b().\sel{n}{done}.n[True].\link{x}{n} \} \}; \\
  & & &\clabel{halt}: \\
  & & &\quad \mkwd{case}\:b\:\{ &\multicolumn{2}{l}{\clabel{t}: b().\rec{x}.\sel{x}{halt}.x().n[].0;} \\
  & & & &\multicolumn{2}{l}{\clabel{f}: b().\rec{x}.\sel{x}{halt}.x().n[].0 \} \})}.
\end{array}\]}
We have that
{\small\[
  \cptyp{Node_{i,y,n}}{i:\cpdual{Bool},y:\cpdual{NodeT},n:NodeT}
\]}

\begin{verbatim}
let rec Node b d c =
   case c of {
     val c => let m = receive c in
              let d = send (if b then 2*m + 1 else 2*m) (select val d) in
              let (n, d) = receive d in
              let c = send n c in
              Node b d c;
     inc c => case (select inc d) of {
                done d => Node b d (select done c);
                carry d => let c = if b then select carry c else select done c in
                           Node (not b) d c };
     halt c => let d = select halt d in c }
\end{verbatim}

Now, we define a top level interface to bit strings.  We support three operations: one to compute
the value of the string, one to increment the string, and one to dispose of the string.
%
{\small\[
 CounterT = \nu X. \with \{ \clabel{val}: Nat \otimes X, \clabel{inc}:X, \clabel{halt}:1 \}.
\]}

\begin{verbatim}
CounterT = nu X. &{ val: !Nat.X, inc: X, halt: end! }
\end{verbatim}

The implementation of the top-level interface is less complex than that for the internal nodes; the
only complication arises when an increment results in a carry, and so a new node needs to be added
to the string.  The coinvariant $x$ stores the first internal node in the string, and is of type
$NodeT$.
%
{\small\[\begin{array}{rclll}
  Counter_z & = & \multicolumn{3}{l}{\mkwd{corec}\:z \langle x \rangle (Epsilon_x,} \\
  & & \quad \mkwd{case}\:z\:\{ &\multicolumn{2}{l}{\clabel{val}: \rec{x}.\sel{x}{val}.x[Zero].x(n).z[n].\link{z}{x};} \\
  & & &  \multicolumn{2}{l}{\clabel{inc}: \rec{x}.\sel{x}{inc}.} \\
  & & & \quad \mkwd{case}\:x\:\{ &\clabel{carry}: \cut{n}{CImp}{\cut{i}{Bool}{True_i}{Node_{i,x,n}}}{\link{z}{n}}; \\
  & & & &\clabel{done}: \link{z}{x} \} \\
  & & &\multicolumn{2}{l}{\clabel{halt}:\rec{x}.\sel{x}{halt}.x().z[].0 \}).}
\end{array}\]}

\begin{verbatim}
let rec CounterImpl d c =
  case c of {
    val c => let (n, d) = receive (send 0 (select val d)) in
             CounterImpl d (send n c);
    inc c => case (select inc d) of {
               carry d => let e = fork e => Node True d e in
                          CounterImpl e c
               done d => CounterImpl d c };
    halt c => let d = select halt d in c } in
let Counter z = CounterImpl (fork c => Epsilon c) z
\end{verbatim}

Here's the example from the source file.  I don't think it's necessarily the best thing, so I can't
be bothered to typeset it right now.
\begin{verbatim}
new [z:Counter]
  (Counter(z) |
   rec z.z[val].z(i).
   rec z.z[inc].
   rec z.z[val].z(j).
   rec z.z[inc].rec z.z[inc].
   rec z.z[val].z(k).
   rec z.z[halt].z().a[i].a[j].a[k].a[].0)
 |- a:int * (int * (int * 1)).
\end{verbatim}

\begin{verbatim}
let d = fork c => Counter c in
let (i, d) = select val d in
let (j, d) = select val (select inc d) in
let (k, d) = select val (select inc (select inc d)) in
let d = select halt d in
(i,j,k)
\end{verbatim}

\section{\mucp Syntax and Semantics}

\todo{
\begin{itemize}
\item There are a couple of changes from previous presentations of CP.  First, I've changed the
  scoping operator from $\nu$ to \tkwd{new} to avoid confusion with fixed points.  Second, I've
  attempted to make $.$ mean sequencing, as it does in $\pi$-calculus; this meant changing the
  syntax of \tkwd{new} and \tkwd{case} to eliminate extra $.$'s.
\item I'm unsure on whether to prefer a minimal presentation, to simplify the later technical
  development, or a full presentation, to make it look most like a complete language.  For example,
  as it is, I've left out second-order quantification; this isn't because there's any particular
  problem with it, but because I haven't used it in any of the examples and it doesn't interact
  surprisingly with any of the new features.  Some places the paper is schizophrenic: the syntax and
  cut rules use binary sums, but the examples assume $n$-ary sums.
\end{itemize}\vspace{-2mm}}

Types and terms:

{\small
\[\begin{array}{l@{\hspace{7mm}}r@{\hspace{2mm}}c@{\hspace{2mm}}l}
  \text{Types} & A,B & ::= & A \otimes B \mid A \parr B \mid \bot \mid 1 \mid A \oplus B \mid A \with B \mid 0 \mid \top \\
   & & \mid & X \mid \cpdual{X} \mid \mu F \mid \nu F \\
   & F & ::= & X.A \\
  \text{Terms} & P,Q & ::= & \link{x}{y} \mid x(y).P \mid x[y].(P \mid Q) \mid x().P \mid x[].0 \\
   & & \mid & \sel{x}{inl}.P \mid \sel{x}{inr}.Q \mid \case{x}{P;Q} \mid \case{x}{} \\
   & & \mid & \cut{x}{A}{P}{Q} \mid \rec{x}.P \mid \corec{x}{y}{A}{P}{Q}
\end{array}\]}

If $F = X.A$, define $F(B) = A[B/X]$.  Definition of duality is standard:

{\small\begin{gather*}
\begin{aligned}
  \cpdual{(A \otimes B)} &= \cpdual{A} \parr \cpdual{B} & \cpdual{1} &= \bot &
    \cpdual{(A \oplus B)} &= \cpdual{A} \with \cpdual{B} & \cpdual{\top} &= 0 \\
  \cpdual{(A \parr B)} &= \cpdual{A} \otimes \cpdual{B} & \cpdual{\bot} &= 1 &
    \cpdual{(A \with B)} &= \cpdual{A} \oplus \cpdual{B} & \cpdual{0} &= \top
\end{aligned}\\
\begin{aligned}
\cpdual{F} &= X.\cpdual{(F(\cpdual{X}))} & \cpdual{(\nu F)} &= \mu \cpdual{F} & \cpdual{(\mu F)} &= \nu \cpdual{F}
\end{aligned}
\end{gather*}}

\begin{lemma}
  $\cpdual{(F(A))} = \cpdual{F}(\cpdual{A})$.
\end{lemma}

\subsection{Axiom and Composition}

This seems like an odd section.

{\small\begin{mathpar}
\inferrule{ }{\cptyp{\link{x}{y}}{x:A,y:\cpdual{A}}}

\inferrule{\cptyp{P}{\Gamma,x:A} \\
           \cptyp{Q}{x:\cpdual{A},\Delta}}
          {\cptyp{\cut{x}{A}{P}{Q}}{\Gamma,\Delta}}
\end{mathpar}}

However, it does serve as a place to introduce the equivalences, which I'd forgotten otherwise.

{\small
\begin{align*}
  \cut{x}{A}{P}{\link{x}{y}} &\equiv P[y/x] \\
  \cut{x}{A}{P}{Q} &\equiv \cut{x}{\cpdual{A}}{Q}{P} \\
  \cut{x}{A}{P}{\cut{y}{B}{Q}{R}} &\equiv \cut{y}{B}{Q}{\cut{x}{A}{P}{R}} &&\text{if $x \not\in fn(Q)$}
\end{align*}}

\subsection{Input and Output}

Binary...

{\small\begin{mathpar}
\inferrule{\cptyp{P}{y:A,\Gamma} \\
           \cptyp{Q}{x:B,\Delta}}
          {\cptyp{x[y].(P \mid Q)}{x:A \otimes B,\Gamma,\Delta}}

\inferrule{\cptyp{P}{y:A,x:B,\Gamma}}
          {\cptyp{x(y).P}{x:A \parr B,\Gamma}}
\end{mathpar}}

{\small\begin{multline*}
\inferrule
  {\inferrule*
     {\cptyp{P}{y:A,\Gamma} \\
      \cptyp{Q}{x:B,\Gamma'}}
     {\cptyp{x[y].(P \mid Q)}{x: A \otimes B,\Gamma,\Gamma'}} \\
   \inferrule*
     {\cptyp{R}{x:\cpdual{B},y:\cpdual{A},\Delta}}
     {\cptyp{x(y).R}{x:\cpdual{A} \parr \cpdual{B},\Delta}}}
  {\cptyp{\cut{x}{A \otimes B}{x[y].(P \mid Q)}{x(y).R}}{\Gamma,\Gamma',\Delta}}
\Longrightarrow \\
\inferrule
  {\cptyp{Q}{y:A,\Gamma} \\
   \inferrule*
     {\cptyp{P}{x:B,\Gamma'} \\
      \cptyp{R}{x:\cpdual{B},y:\cpdual{A},\Delta}}
     {{\cptyp{\cut{x}{B}{P}{R}}{y:\cpdual{A},\Gamma',\Delta}}}}
  {\cptyp{\cut{y}{A}{Q}{\cut{x}{B}{P}{R}}}{\Gamma,\Gamma',\Delta}}
\end{multline*}}

And nullary...

{\small\begin{mathpar}
\inferrule{ }{\cptyp{x[].0}{x:1}}

\inferrule{\cptyp{P}{\Gamma}}
          {\cptyp{x().P}{x:\bot,\Gamma}}
\end{mathpar}}

{\small\[
\inferrule
  {\inferrule*
     { }{\cptyp{x[].0}{x:1}} \\
   \inferrule*
     {\cptyp{P}{\Gamma}}
     {\cptyp{x().P}{x:\bot,\Gamma}}}
  {\cptyp{\cut{x}{1}{x[].0}{x().P}}{\Gamma}}
\Longrightarrow
\cptyp{P}{\Gamma}
\]}

\subsection{Selection and Choice}

{\small\begin{mathpar}
\inferrule{\cptyp{P}{x:A,\Gamma}}
          {\cptyp{\sel{x}{inl}.P}{x:A \oplus B,\Gamma}}

\inferrule{\cptyp{P}{x:A,\Gamma} \\
           \cptyp{Q}{x:B,\Gamma}}
          {\cptyp{\case{x}{P;Q}}{x:A \with B,\Gamma}}

\inferrule{ }{\cptyp{\case{x}{}}{x:\top,\Gamma}}
\end{mathpar}}

{\small\begin{multline*}
\inferrule
  {\inferrule*
     {\cptyp{P}{x:A,\Gamma}}
     {\cptyp{\sel{x}{inl}.P}{x:A \oplus B, \Gamma}} \\
   \inferrule*
     {\cptyp{Q}{x:\cpdual{A},\Delta} \\
      \cptyp{R}{x:\cpdual{B},\Delta}}
     {\cptyp{\case{x}{Q;R}}{x:\cpdual{A} \with \cpdual{B},\Delta}}}
  {\cptyp{\cut{x}{A \oplus B}{\sel{x}{inl}.P}{\case{x}{Q;R}}}{\Gamma,\Delta}}
\Longrightarrow \\
\inferrule
  {\cptyp{P}{x:A,\Gamma} \\
   \cptyp{Q}{x:\cpdual{A},\Delta}}
  {\cptyp{\cut{x}{A}{P}{Q}}{\Gamma,\Delta}}
\end{multline*}}

No term to prove 0, and so no cut reduction for $\top$.

\subsection{Recursion and Corecursion}

{\small\begin{mathpar}
\inferrule{\cptyp{P}{x:F(\mu F), \Gamma}}
          {\cptyp{\rec{x}.P}{x:\mu F,\Gamma}}

\inferrule{\cptyp{P}{y:A,\Gamma} \\
           \cptyp{Q}{y:\cpdual{A},x:F(A)}}
          {\cptyp{\corec{x}{y}{A}{P}{Q}}{x:\nu F,\Gamma}}
\end{mathpar}}

\todo{Show that rules for introduction and elimination of $\mu$ and $\nu$ collapse?}

The new bits are to do with $\mu,\nu$.  The rule for $\mu$ is straightforward---given a process of
type $\mu F$, it unfolds the recursive type once giving a process of type $F(\mu F)$.  The rule for
$\nu$ is less obvious: it implements one expansion of the recursive type, along with an initial
coinvariant.  As a simple example, consider a Haskell definition of the stream of Fibonacci numbers:
\begin{verbatim}
fibs = iter (0,1)
  where iter (m,n) = m : iter (n, m+n)
\end{verbatim}
In this case, the pair \texttt{(m,n)} is the coinvariant, and the \texttt{iter} function behaves
like the step function (albeit with the recursion inlined).
%
\\\todo{That example is miserable, and assumes familiarity with Haskell.  In Glasgow, Phil wanted to
  see the unfoldr equivalent, which is $$unfoldr (\lambda (m,n) \to Just(m, (n,m+n))) (0,1).$$}

Cut reduction for fixed points corresponds to one step of unrolling, and depends on a subsidiary
function $\mathbf{map}$, defined below:

\todo{\begin{itemize}
  \item Can we fix inference lines extending to the edge of the page?
  \item Requires more page width than we have.
\end{itemize}
We could fix both of these problems by not including the derivations...}

\parbox{1.2\textwidth}
{\small\begin{multline*}
\inferrule
  {\inferrule*
     {\cptyp{P}{y:B,\Gamma} \\
      \cptyp{Q}{y:\cpdual{B},x:F(B)}}
     {\cptyp{\corec{x}{y}{B}{P}{Q}}{x:\nu F,\Gamma}} \\
   \inferrule*
     {\cptyp{R}{x:\cpdual{F}(\mu (\cpdual{F})),\Delta}}
     {\cptyp{\rec{x}.R}{x:\mu (\cpdual{F}),\Delta}}}
  {\cptyp{\cut{x}{\nu F}{\corec{x}{y}{B}{P}{Q}}{\rec{x}.R}}{\Gamma,\Delta}}
\Longrightarrow \\
\inferrule
  {\cptyp{P}{y:B,\Gamma} \\
   \inferrule*
     {\cptyp{Q}{y:\cpdual{B},x:F(B)} \\
      \inferrule*
        {\cptyp{E}{x:\cpdual{F}(\cpdual{B}),z:F(\nu F)} \\
         \cptyp{R[z/x]}{z:\cpdual{F}(\mu \cpdual{F}),\Delta}}
        {\cptyp{\cut{z}{F(\nu F)}{E}{R[z/x]}}{x:\cpdual{F}(\cpdual{B}),\Delta}}}
     {\cptyp{\cut{x}{F(B)}{Q}{\cut{z}{F(\nu F)}{E}{R[z/x]}}}{y:\cpdual{B},\Delta}}}
  {\cptyp{\cut{y}{B}{P}{\cut{x}{F(B)}{Q}{\cut{z}{F(\nu F)}{E}{R[z/x]}}}}{\Gamma,\Delta}}
\end{multline*}}

where $E = \expand{F}{z,x}{\corec{z}{y}{B}{\link{x}{y}}{Q[z/x]}}$.

The cases of $\mathbf{map}$ for the positive combinators are as follow:
{\small\begin{align*}
  \expand{X.C}{x,w}{Q} &= \link{x}{w} \\
  \expand{X.X}{x,w}{Q} &= Q \\
  \expand{X.C_1 \otimes C_2}{x,w}{Q} &= w(z).x[y].(\expand{X.C_1}{y,z}{Q[y/x,z/w]} \mid \expand{X.C_2}{x,w}{Q}) \\
  \expand{X.C_1 \oplus C_2}{x,w}{Q} &= \case{w}{\sel{x}{inl}.\expand{X.C_1}{x,w}{Q}; \sel{x}{inr}.\expand{X.C_2}{x,w}{Q}} \\
  \expand{X.\mu F'}{x,w}{Q} &= \corec{w}{y}{\nu(\cpdual{C}(A))}{\link{x}{y}}{\rec{y}.\expand{X.F' (\mu F')}{y,w}{Q[y/x]}}
\end{align*}}
The remaining cases can be obtained by exchanging channels $x$ and $w$.


\begin{lemma}
  If $\cptyp{Q}{x:A,w:B}$ then \(\cptyp{\expand{F}{x,w}{Q}}{x:F(A), w:\cpdual{F}(B)}.\)
\end{lemma}

\subsection{Commuting Conversions}

Commuting conversions are unsurprising:
{\small\begin{align*}
  \cut{x}{A}{z(y).P}{Q} &\Longrightarrow z(y).\cut{x}{A}{P}{Q} \\
  \cut{x}{A}{z[y].(P \mid Q)}{R} &\Longrightarrow z[y].(\cut{x}{A}{P}{R} \mid Q) &&\text{if $x \not\in fn(Q)$} \\
  \cut{x}{A}{z[y].(P \mid Q)}{R} &\Longrightarrow z[y].(P \mid \cut{x}{A}{Q}{R}) &&\text{if $x \not\in fn(P)$} \\
  \cut{x}{A}{\sel{z}{inl}.P}{Q} &\Longrightarrow \sel{z}{inl}.\cut{x}{A}{P}{Q} \\
  \cut{x}{A}{\case{z}{P;Q}}{R} &\Longrightarrow \case{z}{\cut{x}{A}{P}{R}; \cut{x}{A}{Q}{R}} \\
  \cut{x}{A}{\rec{z}.P}{Q} &\Longrightarrow \rec{z}.\cut{x}{A}{P}{Q} \\
  \cut{x}{A}{\corec{z}{y}{B}{P}{Q}}{R} &\Longrightarrow \corec{z}{y}{B}{\cut{x}{A}{P}{R}}{Q}
\end{align*}}

\subsection{Cut Elimination}

\begin{theorem}
  If $\cptyp{P}{\Gamma}$ and $P \Longrightarrow Q$, then $\cptyp{Q}{\Gamma}.$
\end{theorem}

Define $\Longrightarrow^\star$ to be the reflexive, transitive closure of $\equiv\Longrightarrow\equiv$.

\begin{theorem}
  If $\cptyp{P}{\Gamma}$, then there is a $Q$ such that $P \Longrightarrow^\star Q$ and $Q$ is cut-free.
\end{theorem}

\section{\mucp Examples}

We will use $n$-ary sums $\oplus\{\overline{l:A}\}$,$\with\{\overline{l:A}\}$ with correspondingly
generalized \tkwd{case} and selection expressions.

\subsection{Church Numerals}

\todo{Leave this section out entirely and introduce replication when introducing streams?}

Basic idea: can code a type $?A$ by a least fixed point, and its dual $!(\cpdual{A})$ by the dual
greatest fixed point.  Will replicate Phil's Church numeral example using this coding.  Begin with
type abbreviations:
%
{\small\begin{align*}
  Query(A) &= \mu X.\oplus\{\clabel{w}:\bot,\clabel{c}:X \parr X,\clabel{d}:A\}, \\
  Bang(A) &= \nu X.\with\{\clabel{w}:1,\clabel{c}:X \otimes X,\clabel{d}:A\}.
\end{align*}}
%
Can translate type of Church numerals:
{\small\[
  Church = \forall A. Query(A \otimes \cpdual{A}) \parr (\cpdual{A} \parr A).
\]}
\todo{This requires second-order quantification.  To me, this argues for its removal.}
Now, expressing numbers is sarcasm-quotes obvious:
{\small\begin{align*}
  Zero_x &= x(A).x(s).x(z).\rec{s}.\sel{s}{w}.s().\link{z}{x}, \\
  One_x &= x(A).x(s).x(z).\rec{s}.\sel{s}{d}.s[a].(\link{a}{z} \mid \link{s}{x}).
\end{align*}}
Note the two different uses of the value $s$ of type $Query(A)$.  In $Zero$, we have no use of $s$,
so we select weakening and discard the resulting value of type $\bot$.  In $One$, we make one use of
it, and so select dereliction instead.

Of course, we don't want to have to code all the numbers manually.  Instead, we can devise a general
pattern for incrementing a Church numeral:
{\small\begin{align*}
  Inc_{x,y} =\ &y(A).y(s).y(z).\rec{s}.\sel{s}{c}.s(f).\rec{f}.\sel{f}{d}. \\
             &f[a].(\link{a}{z} \mid x[A].x[w].(\link{w}{s} \mid x[v].(\link{v}{f} \mid \link{y}{x}))).
\end{align*}}
%
We have that $\cptyp{Inc_{x,y}}{x:\cpdual{Church},y:Church}$, confirming that $Inc_{x,y}$ has the
expected type.  Finally, we can confirm that $Inc$ behaves as expected by showing, for example, that
{\small\[
  \cut{x}{Church}{Zero_x}{Inc_{x,y}} \Longrightarrow^\star One_{y}.
\]}
\todo{Use of $\Longrightarrow^\star$ before definition.}

\subsection{Peano Numerals}

As an alternative to the Church encodings in the previous section, we could use recursive types
directly to express Peano encodings of the naturals.  The type is natural:
%
{\small\[
  Peano = \mu X.\oplus\{zero: 1, succ: X\}.
\]}
%
The representation of values is more natural in this encoding, however.  For example, we have 0 and
increment encoded as follows:
%
{\small\begin{align*}
  Zero_x &= \rec{x}.\sel{x}{zero}.x[].0 \\
  Inc_{x,y} &= \rec{y}.\sel{y}{succ}.\link{x}{y}
\end{align*}}
Again, we can show that increment behaves as we expect; for example, we have that
%
{\small\[
  \cut{x}{Peano}{Zero_x}{Inc_{x,y}} \Longrightarrow^\star \rec{y}.\sel{y}{succ}.\rec{y}.\sel{y}{zero}.y[].0.
\]}

{\small\[\begin{array}{rcl@{\hspace{0mm}}ll}
  Add_{x,y,z} & = & \multicolumn{3}{l}{\mkwd{corec}\:x\langle a \rangle} \\
  & & \quad (&\multicolumn{2}{l}{a[y].\link{a}{z},} \\
  & & & a(b).\mkwd{case}\:x\:\{&\clabel{zero}: x().\link{a}{b}; \\
  & & & & \clabel{succ}: x[b'].(Inc_{b,b'} \mid  \link{a}{x}) \}).
\end{array}\]}
We can show that $\cptyp{Add_{x,y,z}}{x:\cpdual{Peano}, y:\cpdual{Peano}, z:Peano}$ and, for instance,
that
%
{\small\[
  \cut{x}{Peano}{One_x}{\cut{y}{Peano}{One_y}{Add_{x,y,z}}} \Longrightarrow^\star Two_z.
\]}

\subsection{Streams}

Another obvious thing to do with a recursion is streams.  The types are again quite intuitive:
{\small\begin{align*}
  Sink(A) &= \mu X. \oplus \{ \clabel{end}: \bot, \clabel{more}: \cpdual{A} \parr X \}, \\
  Source(A) &= \nu X. \with \{ \clabel{end}: 1, \clabel{more}: A \otimes X \}.
\end{align*}}
Note the use of the dual in $Sink$; as a result, we have that $\cpdual{(Sink(A))} = Source(A)$ (and
not $Source(\cpdual{A})$: would the other formulation make more sense, tho).

Now, let's define some streams of naturals!  Let $Nat$ stand in for either of the encodings of
naturals.  We'll start with a stream of zeros.  Our form for defining greatest fixed points, called
\tkwd{corec}, allows an arbitrary coinvariant; in this case, we don't need one, so we'll just use 1:
%
{\small\begin{align*}
  Zeros_y =\ &\corec{y}{z}{1}{z[].0}{z().\case{y}{\clabel{end}: y[].0; \clabel{more}: y[x].(Zero_x | y[].0)}}.
\end{align*}}
%
In the \textrm{more} case, we rely on our earier definition of $Zero$.  Building the stream of
naturals $0,1,2,\dots$ is more involved, but little more complicated. Note that we will need two
copies of each number in the stream: the one that appears in the stream itself, and the one used to
generate the remainder of the stream.  Therefore, we'll use a $Bang(Nat)$ as our coinvariant.  We
begin by lifting $Zero$ to type $Bang(Nat)$:
%
{\small\[\begin{array}{r@{\hspace{2mm}}c@{\hspace{2mm}}l@{\hspace{0mm}}l@{\:}l}
  LiftZero_z & = & \multicolumn{3}{l}{\mkwd{corec} \: z \langle a \rangle (a[].0,} \\
  & & \quad & a().\mkwd{case}\: z \: \{ &\clabel{w}: z[].0; \\
  & & & & \clabel{d}: Zero_z; \\
  & & & & \clabel{c}: z[w].(w[].0 \mid z[].0) \}).
\end{array}\]}
%
Again, we don't need a coinvariant, so we use 1.  The only interesting behavior is in the case of
dereliction, in which we rely (again) on our existing definition of $Zero$.  Next, we can lift the
$Inc$ definition above to operate on $Bang(Nat)$ processes:
%
{\small\[\begin{array}{r@{\hspace{2mm}}c@{\hspace{2mm}}l@{\hspace{0mm}}l@{\:}l}
  LiftInc_{x,y} & = & \multicolumn{3}{l}{\mkwd{corec} \: y \langle z \rangle (\link{x}{z},} \\
  & & \quad & \mkwd{case} \: y \: \{ & \clabel{w}: \rec{z}.\sel{z}{w}.y[].0; \\
  & & & & \clabel{d}: \rec{z}.\sel{z}{d}.Inc_{z,y}; \\
  & & & & \clabel{c}: \rec{z}.\sel{z}{c}.z(w).y[x].(\link{x}{w} \mid \link{y}{z}) \}).
\end{array}\]}
%
The invariant $z$ is of type $Bang(Nat)$.  In the case of dereliction, $LiftInc$ behaves as
$Inc$; the other cases are implemented in terms of the corresponding cases of the coinvariant.
Thus, we have that
\[
  \cptyp{LiftInc_{x,y}}{x:Query(\cpdual{Nat}),y:Bang(Nat)}.
\]
Finally, we can define a stream of naturals: the invariant is of type $Bang(Church)$, initialized by
$LiftZero$, and the \textrm{more} case relies on $LiftInc$:
%
{\small\[\begin{array}{r@{\hspace{2mm}}c@{\hspace{2mm}}l@{\hspace{0mm}}l@{\:}l}
  CNats_y & = & \multicolumn{3}{l}{\mkwd{corec} \: y \langle z \rangle (Zero_z,} \\
  & & \quad & \mkwd{case}\:y \{ & \clabel{end}: \rec{z}.\sel{z}{w}.z().y[].0; \\
  & & & & \clabel{more}: \rec{z}.\sel{z}{c}.z(w).y[x].\\
  & & & & \quad (\rec{w}.\sel{w}{d}.\link{x}{w} \mid LiftInc_{z,y}) \}).
\end{array}\]}
%
As we expect, we have that $\cptyp{CNats_y}{y:Stream(Nat)}$.
\\\todo{Example of using streams?  They're not terribly surprising.}

\section{Translation from \mugv to \gvpi}

\[
\ba{@{}rclcl@{}}
\topi{T \lto U}    &=& \gvdual{\gvin{\gvdual{\topi{T}}}{\topi{U}}}
                   &=& \gvout{\topi{T}}{\gvdual{\topi{U}}} \\
\topi{T \uto U}    &=& \gvdual{\gvserver{(\gvin{\topi{\gvdual{T}}}{\topi{U}})}}
                   &=& \gvservice{(\gvout{\topi{T}}{\gvdual{\topi{U}}})} \\
\topi{T \otimes U} &=& \gvdual{\gvout{\gvdual{T}}{\topi{U}}}
                   &=& \gvin{\gvdual{\topi{T}}}{\gvdual{\topi{U}}} \\
\ea
\]

\begin{equations}
\topi{\lambda x.M} &=& \gvfork{z}{\gvlet{(x, z)}{\gvreceive{z}}{\gvlink{\topi{M}}{z}}} \\
\topi{L\,M} &=& \gvsend{\topi{M}}{\topi{L}} \\
\topi{(M, N)} &=&
  \gvfork{z}
    {\gvlink{(\gvsend{\topi{M}}{z})}{\topi{N}}} \\
\topi{\gvlet{(x, y)}{M}{N}} &=&
    \gvlet{(x, y)}{\gvreceive{\topi{M}}}{\topi{N}} \\
\topi{L : T \uto U} &=&
  \gvfork{z}{\gvlink{z}{(\gvserve{y}{\gvlink{\topi{L}}{y}})}} \\
\topi{L : T \lto U} &=& \gvrequest{\topi{L}} \\
\topi{\gvreceive{M}} &=& \topi{M}
\\[1ex]
\topi{\gvletrec{f\,\vec{x}\,c}{M}{N}} &=&
  \gvletrec{p\,z\,c}{\gvlet{\vec{x}}{z}{M[L/f]}}{N[L/f]} \\
&& \text{where }L = \lambda \vec{x} c.\gvsend{c}{(\gvsend{\vec{x}}{p})} \\
\end{equations}%

Syntactic sugar for multi argument functions
\[
\langle T_0, T_1, \dots, T_n \rangle \uto U
\equiv
T_0 \uto T_1 \lto \dots \lto T_n \lto U
\]
The right hand side is isomorphic to
\[
(T_0 \otimes \dots \otimes T_n) \uto U
\]

Syntactic sugar for output
\[
x[y].P \equiv x[y'].(\link{y}{y'} \mid P)
\]


\begin{mathpar}
%% \inferrule{un(\Psi) \\
%%            \gvtyp{\Psi,\vec{x}:\vec{T},f:\langle \vec{T}, X \rangle \uto \outterm, c:G(X)}{M}{\outterm} \\
%%            \gvtyp{\Phi,\Psi,f:\langle \vec{T}, \nu G \rangle \uto \outterm}{N}{U}}
%%           {\gvtyp{\Phi,\Psi}{\gvletrec{f\,\vec{x}\,c}{M}{N}}{U}}

\inferrule{\gvtyp{\vec{x}:\vec{T},f:\langle \vec{T}, X \rangle \uto \outterm, c:G(X)}{M}{\outterm} \\
           \gvtyp{\Phi,f:\langle \vec{T}, \nu G \rangle \uto \outterm}{N}{U}}
          {\gvtyp{\Phi}{\gvletrec{f\,\vec{x}\,c}{M}{N}}{U}}


%% \inferrule{\gvtyp{\vec{x}:\vec{T},f:\langle \vec{T}, X \rangle \uto \outterm, c:G(X)}{M}{\outterm} \\
%%            \gvtyp{\Phi,f:\langle \vec{T}, \nu G \rangle \uto \outterm}{N}{U}}
%%           {\gvtyp{\Phi}{\gvletrec{f\,\vec{x}\,c}{M}{N}}{U}}

%% \inferrule{\gvtyp{\vec{x}:\vec{T},p:\gvout{\langle \vec{T}, X \rangle}{\outterm}, c:G(X)}{M}{\outterm} \\
%%            \gvtyp{\Phi,p:\gvout{\langle \vec{T}, \nu G \rangle}{\outterm}}{N}{U}}
%%           {\gvtyp{\Phi}{\gvletrec{p\,\vec{x}\,c}{M}{N}}{U}}

%% \inferrule{\gvtyp{x:T, f:T \uto X \lto \outterm, c:G(X)}{M}{\outterm} \\
%%            \gvtyp{\Phi, f:T \uto \nu G \lto \outterm}{N}{U}}
%%           {\gvtyp{\Phi}{\gvletrec{f\,x\,c}{M}{N}}{U}}

%% \inferrule{\gvtyp{x:T, f:(T \otimes X) \uto \outterm, c:G(X)}{M}{\outterm} \\
%%            \gvtyp{\Phi, f:(T \otimes \nu G) \uto \outterm}{N}{U}}
%%           {\gvtyp{\Phi}{\gvletrec{f\,x\,c}{M}{N}}{U}}


\inferrule{\gvtyp{x:T,p:\gvservice{(\gvout{T}{\gvout{X}{\outterm}})}, c:G(X)}{M}{\outterm} \\
           \gvtyp{\Phi,p:\gvservice{(\gvout{T}{\gvout{\nu G}{\outterm}})}}{N}{U}}
          {\gvtyp{\Phi}{\gvletrec{p\,x\,c}{M}{N}}{U}}
\end{mathpar}


\newcommand{\replicate}[2]{{!#1(#2)}}
\newcommand{\derelict}[2]{{?#1[#2]}}

\[
\bl
\left\llbracket
\inferrule{\gvtyp{x:T,p:\gvservice{(\gvout{T}{\gvout{X}{\outterm}})},c:G(X)}{M}{\outterm} \\
           \gvtyp{\Phi,p:\gvservice{(\gvout{T}{\gvout{\nu G}{\outterm}})}}{N}{U}}
          {\gvtyp{\Phi}{\gvletrec{p\,x\,c}{M}{N}}{U}}
\right\rrbracket z = \\
\qquad \cut{p}{}{\replicate{p}{y}.y(x).y(c).y().\corec{c}{w}{}{w[x].w[].0}{P}}{\tocp{N}z} \\
%%\cut{p}{}{\replicate{p}{y}.y(x).y(c).y().\corec{c}{ci}{}{\tocp{init}^\star}{\tocp{M^\dagger}^\star}}{\tocp{N}z}
\qquad \qquad \text{where }
P = \cut{p}{}{\replicate{p}{y}.y(x).y(c).y().c[x].c[].0}{w(x).\tocp{M}w} \\
\el
\]


%% \[
%%   \tocp{M}^\star = \cut{z}{\bot}{\tocp{M}z}{z[].0}
%% \]

%% \[
%%  init = \gvsend{x}{ci}
%% \]

%% \[
%% M^\dagger =
%%   \bl
%%   \key{let}\,p=\,\gvfork{p}
%%                    {\bl
%%                     \key{let}\,(x,y) = \gvreceive{(\gvrequest{p})}\,\key{in} \\
%%                     \key{let}\,(c,y) = \gvreceive{y}\,\key{in} \\
%%                     \quad \gvsend{x}{c}\,\key{in}
%%                     \el} \\
%%   \gvlet{(x,ci)}{\gvreceive{ci}}{M} \\
%%   \el
%% \]


\section{Translation from \gvpi to \mucp}

\todo{\begin{itemize}
  \item Translating unlimited GV terms (at the moment, this is only unlimited lambdas) requires
    exponentials, either directly or encoded, in CP.  Adding exponentials to CP requires a
    significant expansion of the existing typing and cut reduction rules (not technically difficult,
    but increasingly overwhelming the actual point of the paper).  Using coding would not require
    extension of the CP rules, but differs from the existing GV $\to$ CP translations.
  \item This translation doesn't take advantage of the previous GV $\to$ GV$\pi$ translation.  Doing
    so would require a ``modified'' form of $\mkwd{corec}$, analogous to the modified form of
    $\mkwd{receive}$, which replaced the unlimited arrows with servers.
\end{itemize}}

Translation of session types from \gvpi to \mucp.

\begin{align*}
\tocp{\gvout{T}{S}}        &= \cpdual{\tocp{T}} \otimes \tocp{S} \\
\tocp{\gvin{T}{S}}         &= \tocp{T} \parr \tocp{S} \\
\tocp{\outterm}            &= 1 \\
\tocp{\oplus \{l_i:S_i \}} &= \oplus \{l_i:\tocp{S_i}\} \\
\tocp{\with \{l_i:S_i \}}  &= \with \{l_i:\tocp{S_i}\} \\
\tocp{\interm}             &= \bot \\
\tocp{\gvserver{S}}        &= \cpbang{\tocp{S}} \\
\tocp{\gvservice{S}}       &= \cpquery{\tocp{S}} \\
\tocp{X}                   &= X \\
 \tocp{\gvdual{X}}          &= \cpdual{X}
\end{align*}

%% \newcommand{\replicate}[2]{{!#1(#2)}}
%% \newcommand{\derelict}[2]{{?#1[#2]}}

\begin{align*}
\left\llbracket \inferrule{\gvtyp{\Phi}{N}{S}}{\gvtyp{\Phi,x:\interm}{N}{S}} \right\rrbracket\!\!z &=
  \inferrule
    {\cptyp{\tocp{N}z}{\tocp{\Phi},z:\cpdual{\tocp{S}}}}
    {\cptyp{x().\tocp{N}z}{\tocp{\Phi},x:\bot,z:\cpdual{\tocp{S}}}}
\\[3ex]
\left\llbracket \inferrule{\gvtyp{\Phi,x:\interm,x':\interm}{N}{S}}
                          {\gvtyp{\Phi,x:\interm}{N[x/x']}{S}} \right\rrbracket \!\!z &=
  \inferrule
    {\cptyp{\tocp{N}z}{\tocp{\Phi},x:\bot,x':\bot,z:\cpdual{\tocp{S}}}}
    {\cptyp{\cut{x'}{}{\tocp{N}z}{x'[].0}}{\tocp{\Phi},x:\bot,z:\cpdual{\tocp{S}}}}
\\[3ex]
\tocp{x}z &= \link{x}{z} \\
\tocp{\gvsend{M}{N}}z &= \cut{x}{}{x[y].(\tocp{M}y \mid \link{x}{z})}{\tocp{N}x} \\
\tocp{\gvlet{(x,y)}{\gvreceive{M}}{M}}z &= \cut{y}{}{\tocp{M}y}{y(x).\tocp{N}z} \\
\tocp{\gvselect{l}{M}}z &= \cut{x}{}{\tocp{M}x}{x[l].\link{x}{z}} \\
\tocp{\gvcase{M}{l_n\,x.N_i}}z &=  \cut{x}{}{\tocp{M}x}{\case{x}{l_i.\tocp{N_i}z}} \\
\tocp{\gvfork{x}{M}}z &= \cut{x}{}{\cut{y}{}{\tocp{M}y}{y[].0}}{\link{x}{z}} \\
\tocp{\gvlink{M}{N}}z &= z().\cut{x}{}{\tocp{M}x}{\tocp{N}x} \\
%\tocp{\gvSendType{S}{M}}z &=
%  \cut{x}{\tocp{M}x}{\cpSendType{x}{\tocp{S}}{\cpLink{x}{z}}} \\
%\tocp{\gvReceiveType{X}{M}}z &=
%  \cut{x}{\tocp{M}x}{\cpReceiveType{x}{X}{\cpLink{x}{z}}} \\
\tocp{\gvserve{y}{M}}z &= \replicate{z}{y}.\cut{x}{}{\tocp{M}x}{x[].0} \\
\tocp{\gvrequest{M}}z &= \cut{x}{}{\tocp{M}x}{\derelict{x}{y}.\link{y}{z}} \\
\end{align*}

{\small
\[
\left\llbracket
\inferrule{\gvtyp{\Phi}{M}{\mu G}}{\gvtyp{\Phi}{M}{G (\mu G)}}
\right\rrbracket z =
\cut{y}{\nu \tocp{G}}{\tocp{\gvtyp{\Phi}{M}{\mu G}}y}{\rec{y}.\link{y}{z}}
\]

\[
\left\llbracket
\inferrule{\gvtyp{\Phi}{M}{G(\nu G)}}{\gvtyp{\Phi}{M}{\nu G}}
\right\rrbracket z =
\cut{y}{\nu \tocp{G}}{\tocp{\gvtyp{\Phi}{M}{G(\nu G)}}y}{\rec{z}.\link{y}{z}}
\]

\[
\left\llbracket
\inferrule{\gvtyp{\Phi}{M}{G(\mu G)}}{\gvtyp{\Phi}{M}{\mu G}}
\right\rrbracket z =
\cut{y}{\tocp{G}(\mu \tocp{G})}{P}
       {\corec{z}{x}{\tocp{G}(\mu \tocp{G})}
              {\link{y}{x}}
              {\expand{G}{x,z}{\rec{x}.\link{x}{z}}}}
\]

\[
\left\llbracket
\inferrule{\gvtyp{\Phi}{M}{\nu G}}{\gvtyp{\Phi}{M}{G (\nu G)}}
\right\rrbracket z =
\cut{y}{\mu \tocp{G}}{P}
       {\corec{y}{x}{\cpdual{\tocp{G}}(\nu \cpdual{\tocp{G}})}
              {\link{z}{x}}
              {\expand{G}{x,y}{\rec{x}.\link{x}{y}}}}
\]

\begin{multline*}
\left\llbracket
\inferrule{\gvtyp{x_i:T_i,f:\vec{T} \uto Q \uto \outterm,c:G(Q)}{M}{\outterm} \\
           \gvtyp{\Phi,f:\vec{T} \uto \nu G \uto \outterm}{N}{U}}
          {\gvtyp{\Phi}{\gvletrec{f\,x_1 \dots x_n\,c}{M}{N}}{U}}
\right\rrbracket z = \\
\replicate{f}{f_1}.f_1(x_1)\dots.\replicate{f_{n-1}}{f_n}.f_n(x_n).\corec{c}{ci}{}{\tocp{init_{ci}}^\star}{\tocp{M^\dagger_{ci}}^\star}
\end{multline*}

where

\[
  \tocp{M}^\star = \cut{z}{\bot}{\tocp{M}z}{z[].0}
\]

\[
 init_{ci} = \gvsend{x_n}{(\dots(\gvsend{x_1}{ci}))}
\]

\[\begin{array}{rcl}
M^\dagger_{ci} &=& \gvlet{f}{\lambda x_1\dots\lambda x_n.\lambda c.\gvsend{x_n}{(\dots(\gvsend{x_1}{c})\dots)}}
                {\\&&\gvlet{(x_1,ci)}{\gvreceive{ci}}
                {\\&&\vdots\\&&\gvlet{(x_n,ci)}{\gvreceive{ci}}{M}}}
\end{array}\]
}

\begin{theorem}
  If $\gvtyp{\Phi}{M}{T}$, then $\cptyp{\tocp{M}z}{\tocp{\Phi},z:\cpdual{\tocp{T}}}$.
\end{theorem}

\section{Related Work}

\section{Conclusion and Future Work}

\begin{itemize}
\item Translation of \mucp{} into \mugv{}?
\item Direct (asynchronous) semantics of \mugv{}?
\item Recursive types (instead of just recursive sessions)?
\item $\mathrm{MIX}_0,\mathrm{MIX}_2$ and the treatment of closed channels.
\end{itemize}

\appendix

\section{\mucp}

\begin{figure}
{\small\begin{mathpar}
\inferrule{ }{\cptyp{\link{x}{y}}{x:A,y:\cpdual{A}}}

\inferrule{\cptyp{P}{\Gamma,x:A} \\
           \cptyp{Q}{x:\cpdual{A},\Delta}}
          {\cptyp{\cut{x}{A}{P}{Q}}{\Gamma,\Delta}}

\inferrule{\cptyp{P}{y:A,\Gamma} \\
           \cptyp{Q}{x:B,\Delta}}
          {\cptyp{x[y].(P \mid Q)}{x:A \otimes B,\Gamma,\Delta}}

\inferrule{\cptyp{P}{y:A,x:B,\Gamma}}
          {\cptyp{x(y).P}{x:A \parr B,\Gamma}}

\inferrule{ }{\cptyp{x[].0}{x:1}}

\inferrule{\cptyp{P}{\Gamma}}
          {\cptyp{x().P}{x:\bot,\Gamma}}

\inferrule{\cptyp{P}{x:A,\Gamma}}
          {\cptyp{\sel{x}{inl}.P}{x:A \oplus B,\Gamma}}

\inferrule{\cptyp{P}{x:A,\Gamma} \\
           \cptyp{Q}{x:B,\Gamma}}
          {\cptyp{\case{x}{P;Q}}{x:A \with B,\Gamma}}

\inferrule{ }{\cptyp{\case{x}{}}{x:\top,\Gamma}}

\inferrule{\cptyp{P}{x:F(\mu F), \Gamma}}
          {\cptyp{\rec{x}.P}{x:\mu F,\Gamma}}

\inferrule{\cptyp{P}{y:A,\Gamma} \\
           \cptyp{Q}{y:\cpdual{A},x:F(A)}}
          {\cptyp{\corec{x}{y}{A}{P}{Q}}{x:\nu F,\Gamma}}
\end{mathpar}}

\caption{Typing rules of \mucp}
\end{figure}


\end{document}
